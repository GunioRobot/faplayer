diff -Nurp vlc-a/Android.mk vlc-b/Android.mk
--- vlc-a/Android.mk	1970-01-01 08:00:00.000000000 +0800
+++ vlc-b/Android.mk	2011-07-10 01:53:48.803261071 +0800
@@ -0,0 +1,191 @@
+
+LOCAL_PATH:= $(call my-dir)
+
+include $(CLEAR_VARS)
+
+LOCAL_ARM_MODE := arm
+ifeq ($(BUILD_WITH_NEON),1)
+LOCAL_ARM_NEON := true
+endif
+
+LOCAL_MODULE := vlccore
+
+LOCAL_CFLAGS += \
+    -DICONV_CONST=
+
+LOCAL_CFLAGS += \
+    -std=c99 \
+    -DHAVE_CONFIG_H \
+    -DMODULE_STRING=\"main\" \
+    -DPACKAGENAME=\"org.stagex.danmaku\" \
+    -DLOCALEDIR=\"/data/data/\"PACKAGENAME\"/cache/locale\" \
+    -DSYSCONFDIR=\"/data/data/\"PACKAGENAME\"/cache/etc\" \
+    -DDATA_PATH=\"/data/data/\"PACKAGENAME\"/cache/share\" \
+    -DPKGLIBDIR=\"/data/data/\"PACKAGENAME\"/cache/lib\"
+
+LOCAL_C_INCLUDES += \
+    $(EXTROOT)/iconv/include
+
+LOCAL_C_INCLUDES += \
+    $(VLCROOT) \
+    $(VLCROOT)/include \
+    $(VLCROOT)/src
+
+LOCAL_SRC_FILES := \
+    src/libvlc.c \
+    src/libvlcjni.c \
+    src/libvlc-module.c \
+    src/missing.c \
+    src/revision.c \
+    src/version.c \
+    src/audio_output/common.c \
+    src/audio_output/dec.c \
+    src/audio_output/filters.c \
+    src/audio_output/input.c \
+    src/audio_output/intf.c \
+    src/audio_output/mixer.c \
+    src/audio_output/output.c \
+    src/config/chain.c \
+    src/config/cmdline.c \
+    src/config/core.c \
+    src/config/dirs.c \
+    src/config/file.c \
+    src/config/getopt.c \
+    src/config/intf.c \
+    src/config/keys.c \
+    src/control/audio.c \
+    src/control/core.c \
+    src/control/error.c \
+    src/control/event.c \
+    src/control/event_async.c \
+    src/control/log.c \
+    src/control/media.c \
+    src/control/media_discoverer.c \
+    src/control/media_library.c \
+    src/control/media_list.c \
+    src/control/media_list_player.c \
+    src/control/media_player.c \
+    src/control/playlist.c \
+    src/control/video.c \
+    src/extras/libc.c \
+    src/extras/tdestroy.c \
+    src/input/access.c \
+    src/input/clock.c \
+    src/input/control.c \
+    src/input/decoder.c \
+    src/input/decoder_synchro.c \
+    src/input/demux.c \
+    src/input/es_out.c \
+    src/input/es_out_timeshift.c \
+    src/input/event.c \
+    src/input/input.c \
+    src/input/item.c \
+    src/input/meta.c \
+    src/input/resource.c \
+    src/input/stream.c \
+    src/input/stream_demux.c \
+    src/input/stream_filter.c \
+    src/input/stream_memory.c \
+    src/input/subtitles.c \
+    src/input/var.c \
+    src/interface/dialog.c \
+    src/interface/interface.c \
+    src/interface/intf_eject.c \
+    src/misc/atomic.c \
+    src/misc/block.c \
+    src/misc/cpu.c \
+    src/misc/epg.c \
+    src/misc/error.c \
+    src/misc/es_format.c \
+    src/misc/events.c \
+    src/misc/exit.c \
+    src/misc/filter.c \
+    src/misc/filter_chain.c \
+    src/misc/fourcc.c \
+    src/misc/http_auth.c \
+    src/misc/image.c \
+    src/misc/md5.c \
+    src/misc/media_library.c \
+    src/misc/messages.c \
+    src/misc/mtime.c \
+    src/misc/objects.c \
+    src/misc/picture.c \
+    src/misc/picture_fifo.c \
+    src/misc/picture_pool.c \
+    src/misc/probe.c \
+    src/misc/rand.c \
+    src/misc/sql.c \
+    src/misc/stats.c \
+    src/misc/subpicture.c \
+    src/misc/text_style.c \
+    src/misc/threads.c \
+    src/misc/update.c \
+    src/misc/update_crypto.c \
+    src/misc/variables.c \
+    src/misc/xml.c \
+    src/modules/cache.c \
+    src/modules/entry.c \
+    src/modules/modules.c \
+    src/modules/textdomain.c \
+    src/network/acl.c \
+    src/network/getaddrinfo.c \
+    src/network/io.c \
+    src/network/poll.c \
+    src/network/rootbind.c \
+    src/network/tcp.c \
+    src/network/tls.c \
+    src/network/udp.c \
+    src/osd/osd.c \
+    src/osd/osd_text.c \
+    src/playlist/art.c \
+    src/playlist/control.c \
+    src/playlist/engine.c \
+    src/playlist/fetcher.c \
+    src/playlist/item.c \
+    src/playlist/loadsave.c \
+    src/playlist/preparser.c \
+    src/playlist/search.c \
+    src/playlist/services_discovery.c \
+    src/playlist/sort.c \
+    src/playlist/thread.c \
+    src/playlist/tree.c \
+    src/posix/dirs.c \
+    src/posix/filesystem.c \
+    src/posix/linux_specific.c \
+    src/posix/plugin.c \
+    src/posix/thread.c \
+    src/text/charset.c \
+    src/text/filesystem.c \
+    src/text/iso_lang.c \
+    src/text/strings.c \
+    src/text/unicode.c \
+    src/video_output/control.c \
+    src/video_output/display.c \
+    src/video_output/inhibit.c \
+    src/video_output/interlacing.c \
+    src/video_output/opengl.c \
+    src/video_output/postprocessing.c \
+    src/video_output/snapshot.c \
+    src/video_output/video_epg.c \
+    src/video_output/video_output.c \
+    src/video_output/video_text.c \
+    src/video_output/video_widgets.c \
+    src/video_output/vout_intf.c \
+    src/video_output/vout_subpictures.c \
+    src/video_output/vout_wrapper.c \
+    src/video_output/window.c
+
+LOCAL_LDLIBS += -ldl -llog -lz
+
+include $(LOCAL_PATH)/Modules.mk
+
+LOCAL_STATIC_LIBRARIES += compat
+
+ifeq ($(BUILD_WITH_NEON),1)
+LOCAL_STATIC_LIBRARIES += arm_neon
+endif
+
+include $(BUILD_SHARED_LIBRARY)
+
+include $(call all-makefiles-under,$(LOCAL_PATH))
+
diff -Nurp vlc-a/compat/Android.mk vlc-b/compat/Android.mk
--- vlc-a/compat/Android.mk	1970-01-01 08:00:00.000000000 +0800
+++ vlc-b/compat/Android.mk	2011-07-10 01:53:48.808261100 +0800
@@ -0,0 +1,25 @@
+LOCAL_PATH:= $(call my-dir)
+
+include $(CLEAR_VARS)
+
+LOCAL_ARM_MODE := arm
+
+LOCAL_MODULE := compat
+
+LOCAL_CFLAGS += \
+    -std=c99 \
+    -DHAVE_CONFIG_H
+
+LOCAL_C_INCLUDES += \
+    $(VLCROOT) \
+    $(VLCROOT)/include \
+    $(VLCROOT)/src
+
+LOCAL_SRC_FILES := \
+    getdelim.c \
+    pthread-cancel.c \
+    swab.c \
+    tdestroy.c
+
+include $(BUILD_STATIC_LIBRARY)
+
diff -Nurp vlc-a/compat/pthread-cancel.c vlc-b/compat/pthread-cancel.c
--- vlc-a/compat/pthread-cancel.c	1970-01-01 08:00:00.000000000 +0800
+++ vlc-b/compat/pthread-cancel.c	2011-07-10 01:53:48.810261111 +0800
@@ -0,0 +1,330 @@
+/*****************************************************************************
+ * pthread_cancel.c: pthread deferred cancellation replacement
+ *****************************************************************************
+ * Copyright © 2011 VideoLAN
+ *
+ * Author: Jean-Philippe André <jpeg # videolan.org>
+ *
+ * License: LGPL
+ *****************************************************************************/
+
+//#ifdef HAVE_CONFIG_H
+//# include <config.h>
+//#endif
+
+//#include <vlc_common.h>
+//#include <vlc_fixups.h>
+#include <pthread.h>
+#include <assert.h>
+#include <jni.h>
+
+extern JavaVM *gJVM;
+
+// FIXME: Used for debugging purposes only. Remove once the code is stable
+// and well tested
+#if defined(HAVE_ANDROID) && !defined(NDEBUG)
+# include <android/log.h>
+# define LOG_TAG "pthread"
+# define LOGV(...) __android_log_print(ANDROID_LOG_VERBOSE,LOG_TAG,__VA_ARGS__)
+# define LOGE(...) __android_log_print(ANDROID_LOG_ERROR,LOG_TAG,__VA_ARGS__)
+#else
+# define LOGV(...)
+# define LOGE(...)
+#endif
+
+#define bool int
+#define true 1
+#define false 0
+#ifdef __GNUC__
+#   define likely(p)   __builtin_expect(!!(p), 1)
+#   define unlikely(p) __builtin_expect(!!(p), 0)
+#else
+#   define likely(p)   (!!(p))
+#   define unlikely(p) (!!(p))
+#endif
+
+#define PTHREAD_CANCEL_ENABLE 0
+#define PTHREAD_CANCEL_DISABLE 1
+
+/*
+ * This file provide fixups for the following functions:
+ * - pthread_cancel
+ * - pthread_testcancel
+ * - pthread_setcancelstate
+ * As a result of the implementation design, we must also wrap
+ * pthread_create into a cancellation-aware function
+ */
+
+static void* thread_wrapper_routine (void *arg);
+static void  thread_cancel_handler (int signal);
+static void  thread_cancel_destructor (void *data);
+static void  pthread_exit_wrapper (void *ret);
+
+// Functions used by LibVLC
+void pthread_cancel_initialize (void);
+void pthread_cancel_deinitialize (void);
+
+/*
+ * Some static variables used for initialization
+ */
+static pthread_key_t cancel_key = 0; /// Key for the thread-local variable
+
+/*
+ * These objects define the thread-local variable tracking the thread's
+ * cancellation status (cancellable, cancelled)
+ */
+typedef struct cancel_t cancel_t;
+struct cancel_t
+{
+    int state;      /// PTHREAD_CANCEL_ENABLE (0) or PTHREAD_CANCEL_DISABLE (1)
+    pthread_cond_t *cond; /// Non-null if thread waiting on cond
+
+    /* Booleans at the end for packing purposes */
+    bool cancelled; /// Non-zero means this thread has been cancelled
+};
+
+/*
+ * This is the thread wrapper data
+ */
+typedef struct thread_wrapper_t thread_wrapper_t;
+struct thread_wrapper_t
+{
+    void     *(*routine) (void*); /// Main thread routine to call
+    void     *arg;                /// Argument to pass to the thread routine
+    cancel_t *cancel; /// The cancel structure is allocated before the thread
+};
+
+/**
+ * Initialize pthread cancellation
+ * Creates thread-local variable's key and catches SIGRTMIN in main thread
+ **/
+void pthread_cancel_initialize (void)
+{
+    // Set up signal handler
+    struct sigaction act;
+    memset (&act, 0, sizeof (act));
+    sigemptyset (&act.sa_mask);
+    act.sa_flags = 0;
+    act.sa_handler = thread_cancel_handler;
+    sigaction (SIGRTMIN, &act, NULL);
+
+    // Create thread-local variable key
+    pthread_key_create (&cancel_key, thread_cancel_destructor);
+}
+
+/**
+ * Deinitialize pthread cancellation
+ **/
+void pthread_cancel_deinitialize (void)
+{
+    struct sigaction act;
+    memset (&act, 0, sizeof (act));
+    sigemptyset (&act.sa_mask);
+    sigaction (SIGRTMIN, &act, NULL);
+    pthread_key_delete (cancel_key);
+    cancel_key = 0;
+}
+
+/**
+ * Replacement for pthread_cancel
+ * Sends a SIGRTMIN signal to the thread
+ **/
+int pthread_cancel (pthread_t thread_id)
+{
+    return pthread_kill (thread_id, SIGRTMIN);
+}
+
+/**
+ * Replacement for pthread_create with support for cancellation
+ **/
+int pthread_create_cancel (pthread_t *thread_id,
+                           const pthread_attr_t *attr,
+                           void *(*routine) (void *),
+                           void *arg)
+{
+    thread_wrapper_t *wrapper_data =
+            (thread_wrapper_t*) calloc (1, sizeof (thread_wrapper_t));
+    if (unlikely (!wrapper_data))
+        return -1;
+
+    wrapper_data->routine = routine;
+    wrapper_data->arg     = arg;
+    wrapper_data->cancel  = (cancel_t*) calloc (1, sizeof (cancel_t));
+
+    if (unlikely (!wrapper_data->cancel))
+    {
+        free (wrapper_data);
+        return -1;
+    }
+
+    int ret = pthread_create (thread_id, attr, thread_wrapper_routine,
+                              wrapper_data);
+    if (unlikely (ret != 0))
+    {
+        // The thread wrapper should free these variables but it didn't start
+        free (wrapper_data->cancel);
+        free (wrapper_data);
+    }
+    return ret;
+}
+
+/**
+ * Thread wrapper
+ * Sets up signal handlers and thread-local data before running the routine
+ **/
+static void* thread_wrapper_routine (void *arg)
+{
+    thread_wrapper_t *wrapper_data = (thread_wrapper_t*) arg;
+
+    // Set up signal handler
+    struct sigaction act;
+    memset (&act, 0, sizeof (act));
+    sigemptyset (&act.sa_mask);
+    act.sa_flags = 0;
+    act.sa_handler = thread_cancel_handler;
+    sigaction (SIGRTMIN, &act, NULL);
+
+    // Place specific data (cancel state stack)
+    cancel_t *canc = wrapper_data->cancel;
+    memset (canc, 0, sizeof (cancel_t));
+    if (unlikely (pthread_setspecific (cancel_key, canc) != 0))
+        return NULL;
+
+    JNIEnv *env = NULL;
+    (*gJVM)->AttachCurrentThread(gJVM, &env, NULL);
+    void *ret = wrapper_data->routine (wrapper_data->arg);
+    // Don't free wrapper_data->cancel. It will be destroyed automatically.
+    free (wrapper_data);
+    (*gJVM)->DetachCurrentThread(gJVM);
+    return ret;
+}
+
+/**
+ * Create a cancellation point
+ **/
+void pthread_testcancel (void)
+{
+    cancel_t *canc = pthread_getspecific (cancel_key);
+    if (unlikely (!canc))
+        return; // Don't mess with the main thread
+
+    assert (canc->cond == NULL);
+
+    if (canc->cancelled) // Don't check PTHREAD_CANCEL_ENABLE
+        pthread_exit_wrapper (NULL);
+}
+
+/**
+ * Change thread's cancellation state (enable/disable)
+ **/
+int pthread_setcancelstate (int state, int *oldstate)
+{
+    cancel_t *canc = pthread_getspecific (cancel_key);
+    if (unlikely (canc == NULL))
+    {
+        /// FIXME
+        // Let's just add this missing variable since the main thread
+        // uses these features but wasn't created by pthread_create_cancel
+        canc = (cancel_t*) calloc (1, sizeof (cancel_t));
+        pthread_setspecific (cancel_key, canc);
+    }
+
+    if (oldstate)
+        *oldstate = canc->state;
+    canc->state = state;
+
+    if (state == PTHREAD_CANCEL_ENABLE)
+        pthread_testcancel ();
+
+    return 0;
+}
+
+/**
+ * Cancellation signal handler
+ **/
+static void thread_cancel_handler (int signal)
+{
+    assert (signal == SIGRTMIN);
+
+    cancel_t *canc = (cancel_t*) pthread_getspecific (cancel_key);
+    if (unlikely (!canc))
+        return; // Main thread, can't be cancelled
+
+    canc->cancelled = true;
+    if (canc->cond)
+    {
+        /* Wakeup all threads waiting on cond. As we are supposed to expect
+         * spurious wakeups, this should not be an issue
+         */
+        pthread_cond_t *cond = canc->cond;
+        canc->cond = NULL;
+        pthread_cond_broadcast (cond);
+        /* FIXME: not calling pthread_exit (crashes in input thread). Why? */
+        // pthread_exit (NULL);
+        return;
+    }
+    if (canc->state == PTHREAD_CANCEL_ENABLE)
+        pthread_exit_wrapper (NULL);
+}
+
+/**
+ * Destroy a cancel_t variable. Nothing fancy.
+ **/
+static void thread_cancel_destructor (void *data)
+{
+    cancel_t *canc = (cancel_t*) data;
+    free (canc);
+}
+
+int pthread_cond_wait_cancel( pthread_cond_t *cond,
+                                     pthread_mutex_t *mutex )
+{
+    int oldstate;
+    pthread_setcancelstate (PTHREAD_CANCEL_DISABLE, &oldstate);
+    cancel_t *canc = pthread_getspecific (cancel_key);
+    if (canc)
+    {
+        assert (!canc->cond);
+        canc->cond = cond;
+    }
+
+    int ret = pthread_cond_wait (cond, mutex);
+
+    if (canc)
+        canc->cond = NULL;
+
+    /// FIXME: We should call testcancel() here, but it leads to crashes.
+    // pthread_testcancel ();
+    pthread_setcancelstate (oldstate, NULL);
+    return ret;
+}
+
+int pthread_cond_timedwait_cancel( pthread_cond_t *cond,
+                                   pthread_mutex_t *mutex,
+                                   const struct timespec *abstime )
+{
+    int oldstate;
+    pthread_setcancelstate (PTHREAD_CANCEL_DISABLE, &oldstate);
+    cancel_t *canc = pthread_getspecific (cancel_key);
+    if (canc)
+    {
+        assert (!canc->cond);
+        canc->cond = cond;
+    }
+
+    int ret = pthread_cond_timedwait (cond, mutex, abstime);
+
+    if (canc)
+        canc->cond = NULL;
+
+    /// FIXME: We should call testcancel() here, but it leads to crashes.
+    // pthread_testcancel ();
+    pthread_setcancelstate (oldstate, NULL);
+    return ret;
+}
+
+static void pthread_exit_wrapper(void *ret) {
+    (*gJVM)->DetachCurrentThread(gJVM);
+    pthread_exit(ret);
+}
+
diff -Nurp vlc-a/config.h vlc-b/config.h
--- vlc-a/config.h	1970-01-01 08:00:00.000000000 +0800
+++ vlc-b/config.h	2011-07-18 15:13:03.521867926 +0800
@@ -0,0 +1,840 @@
+/* config.h.  Generated from config.h.in by configure.  */
+/* config.h.in.  Generated from configure.ac by autoheader.  */
+
+/* Define if building universal (internal helper macro) */
+/* #undef AC_APPLE_UNIVERSAL_BUILD */
+
+/* Define to 1 to allow running VLC as root (uid 0). */
+/* #undef ALLOW_RUN_AS_ROOT */
+
+/* Define to 1 if the operating system uses UTF-8 internally */
+#define ASSUME_UTF8 1
+
+/* Maximum supported data alignment */
+#define ATTRIBUTE_ALIGNED_MAX 64
+
+/* Define to 1 if 3D Now! inline assembly is available. */
+/* #undef CAN_COMPILE_3DNOW */
+
+/* Define to 1 if AltiVec inline assembly is available. */
+/* #undef CAN_COMPILE_ALTIVEC */
+
+/* Define to 1 if C AltiVec extensions are available. */
+/* #undef CAN_COMPILE_C_ALTIVEC */
+
+/* Define to 1 inline MMX assembly is available. */
+/* #undef CAN_COMPILE_MMX */
+
+/* Define to 1 if MMX EXT inline assembly is available. */
+/* #undef CAN_COMPILE_MMXEXT */
+
+/* Define to 1 if SSE inline assembly is available. */
+/* #undef CAN_COMPILE_SSE */
+
+/* Define to 1 if SSE2 inline assembly is available. */
+/* #undef CAN_COMPILE_SSE2 */
+
+/* Define to 1 if SSE3 inline assembly is available. */
+/* #undef CAN_COMPILE_SSE3 */
+
+/* Define to 1 if SSE4A inline assembly is available. */
+/* #undef CAN_COMPILE_SSE4A */
+
+/* Define to 1 if SSE4_1 inline assembly is available. */
+/* #undef CAN_COMPILE_SSE4_1 */
+
+/* Define to 1 if SSE4_2 inline assembly is available. */
+/* #undef CAN_COMPILE_SSE4_2 */
+
+/* Define to 1 if SSSE3 inline assembly is available. */
+/* #undef CAN_COMPILE_SSSE3 */
+
+/* The ./configure command line */
+#define CONFIGURE_LINE "./../../../configure  '--host=arm-eabi-linux' '--build=x86_64-unknown-linux' '--enable-static-modules' '--disable-vlc' '--disable-debug' '--disable-vlm' '--disable-sout' '--disable-dbus' '--disable-lua' '--disable-httpd' '--disable-libgcrypt' '--disable-a52' '--enable-live555' '--disable-vcd' '--disable-v4l2' '--disable-gnomevfs' '--disable-dvdread' '--disable-dvdnav' '--disable-bluray' '--disable-linsys' '--disable-decklink' '--enable-avformat' '--enable-swscale' '--enable-avcodec' '--disable-postproc' '--disable-libva' '--enable-mkv' '--disable-dv' '--disable-mod' '--disable-sid' '--disable-x264' '--disable-mad' '--disable-schroedinger' '--disable-dirac' '--disable-sdl-image' '--disable-zvbi' '--disable-fluidsynth' '--enable-opensles' '--disable-jack' '--disable-pulse' '--disable-alsa' '--disable-portaudio' '--disable-sdl' '--disable-xcb' '--disable-atmo' '--disable-qt4' '--disable-skins2' '--disable-mtp' '--disable-taglib' '--disable-notify' '--enable-freetype' '--enable-libass' '--disable-svg' '--disable-sqlite' '--disable-udev' '--disable-libxml2' '--enable-android-surface' '--disable-caca' '--disable-glx' '--disable-egl' '--disable-gl' '--disable-gles1' '--disable-gles2' '--disable-goom' '--disable-projectm' 'build_alias=x86_64-unknown-linux' 'host_alias=arm-eabi-linux' 'CC=/opt/android/android-ndk-r5c/toolchains/arm-linux-androideabi-4.4.3/prebuilt/*-x86/bin//arm-linux-androideabi-gcc' 'CFLAGS=-nostdlib -mlong-calls -fstrict-aliasing -fprefetch-loop-arrays -ffast-math -mfpu=neon -mtune=cortex-a8 -ftree-vectorize -mvectorize-with-neon-quad -O2' 'LDFLAGS=-Wl,-rpath-link=/opt/android/android-ndk-r5c/platforms/android-9/arch-arm/usr/lib,-Bdynamic,-dynamic-linker=/system/bin/linker -Wl,--no-undefined -Wl,-shared -L/opt/android/android-ndk-r5c/platforms/android-9/arch-arm/usr/lib -Wl,--fix-cortex-a8' 'LIBS=-lc -ldl -lgcc' 'CPPFLAGS=-I/opt/android/android-ndk-r5c/platforms/android-9/arch-arm/usr/include' 'CXX=/opt/android/android-ndk-r5c/toolchains/arm-linux-androideabi-4.4.3/prebuilt/*-x86/bin//arm-linux-androideabi-g++' 'CXXFLAGS=-nostdlib -mlong-calls -fstrict-aliasing -fprefetch-loop-arrays -ffast-math -mfpu=neon -mtune=cortex-a8 -ftree-vectorize -mvectorize-with-neon-quad -O2'"
+
+/* Copyright string */
+#define COPYRIGHT_MESSAGE "Copyright © 1996-2011 the VideoLAN team"
+
+/* The copyright years */
+#define COPYRIGHT_YEARS "1996-2011"
+
+/* Disables runtime check for buggy glibc. */
+/* #undef DISABLE_BUGGY_GLIBC_CHECK */
+
+/* Binary specific version */
+/* #undef DISTRO_VERSION */
+
+/* Define if you want the HTTP dameon support */
+/* #undef ENABLE_HTTPD */
+
+/* Define to 1 if translation of program messages to the user's native
+   language is requested. */
+/* #undef ENABLE_NLS */
+
+/* Define to 1 for stream output support. */
+/* #undef ENABLE_SOUT */
+
+/* Define if you want the VideoLAN manager support */
+/* #undef ENABLE_VLM */
+
+/* Define to 1 if you have the <a52dec/a52.h> header file. */
+/* #undef HAVE_A52DEC_A52_H */
+
+/* Define to 1 if you have the `accept4' function. */
+/* #undef HAVE_ACCEPT4 */
+
+/* Define to 1 if you have the <altivec.h> header file. */
+/* #undef HAVE_ALTIVEC_H */
+
+/* Define to 1 if you have the <ApplicationServices/ApplicationServices.h>
+   header file. */
+/* #undef HAVE_APPLICATIONSERVICES_APPLICATIONSERVICES_H */
+
+/* Define to 1 if you have the <arpa/inet.h> header file. */
+#define HAVE_ARPA_INET_H 1
+
+/* Define to 1 if you have the `asprintf' function. */
+#define HAVE_ASPRINTF 1
+
+/* Define to 1 if you have the `atof' function. */
+#define HAVE_ATOF 1
+
+/* Define to 1 if you have the `atoll' function. */
+#define HAVE_ATOLL 1
+
+/* Support for __attribute__((packed)) for structs */
+#define HAVE_ATTRIBUTE_PACKED 1
+
+/* Define if avcodec has to be built with DxVA2 support. */
+/* #undef HAVE_AVCODEC_DXVA2 */
+
+/* Define if avcodec has to be built with VAAPI support. */
+/* #undef HAVE_AVCODEC_VAAPI */
+
+/* Define to 1 if you have the `backtrace' function. */
+/* #undef HAVE_BACKTRACE */
+
+/* Define to 1 if you have the <Carbon/Carbon.h> header file. */
+/* #undef HAVE_CARBON_CARBON_H */
+
+/* Define to 1 if you have the MacOS X function CFLocaleCopyCurrent in the
+   CoreFoundation framework. */
+/* #undef HAVE_CFLOCALECOPYCURRENT */
+
+/* Define to 1 if you have the MacOS X function CFPreferencesCopyAppValue in
+   the CoreFoundation framework. */
+/* #undef HAVE_CFPREFERENCESCOPYAPPVALUE */
+
+/* Define to 1 if you have clock_nanosleep. */
+/* #undef HAVE_CLOCK_NANOSLEEP */
+
+/* Define to 1 if you have the `connect' function. */
+#define HAVE_CONNECT 1
+
+/* Define to 1 if you have the <CoreAudio/CoreAudio.h> header file. */
+/* #undef HAVE_COREAUDIO_COREAUDIO_H */
+
+/* Define to 1 if you have the <d2d1.h> header file. */
+/* #undef HAVE_D2D1_H */
+
+/* Define to 1 if you have the <d3d9.h> header file. */
+/* #undef HAVE_D3D9_H */
+
+/* Define to 1 if you have the `daemon' function. */
+#define HAVE_DAEMON 1
+
+/* Define if you have the D-BUS library */
+/* #undef HAVE_DBUS */
+
+/* Define if the GNU dcgettext() function is already present or preinstalled.
+   */
+/* #undef HAVE_DCGETTEXT */
+
+/* Define to 1 if you have the <ddraw.h> header file. */
+/* #undef HAVE_DDRAW_H */
+
+/* Define to 1 if you have the <DeckLinkAPIDispatch.cpp> header file. */
+/* #undef HAVE_DECKLINKAPIDISPATCH_CPP */
+
+/* Define if <time.h> defines nanosleep. */
+#define HAVE_DECL_NANOSLEEP 1
+
+/* Define to 1 if you have the `dirfd' function. */
+#define HAVE_DIRFD 1
+
+/* Define to 1 if you have the <dlfcn.h> header file. */
+#define HAVE_DLFCN_H 1
+
+/* Define if you have the dlopen API */
+#define HAVE_DL_DLOPEN 1
+
+/* Define if you have Windows' LoadLibrary */
+/* #undef HAVE_DL_WINDOWS */
+
+/* Define to 1 if you have the <dshow.h> header file. */
+/* #undef HAVE_DSHOW_H */
+
+/* Define if you have dvdnav_describe_title_chapters. */
+/* #undef HAVE_DVDNAV_DESCRIBE_TITLE_CHAPTERS */
+
+/* Define if you have dvdnav_get_video_resolution. */
+/* #undef HAVE_DVDNAV_GET_VIDEO_RESOLUTION */
+
+/* Define to 1 if you have the <dxva2api.h> header file. */
+/* #undef HAVE_DXVA2API_H */
+
+/* Define if dynamic plugins are supported */
+#define HAVE_DYNAMIC_PLUGINS 1
+
+/* Define to 1 if you have the <ebml/EbmlVersion.h> header file. */
+/* #undef HAVE_EBML_EBMLVERSION_H */
+
+/* Define to 1 if you have the `eventfd' function. */
+#define HAVE_EVENTFD 1
+
+/* Define to 1 if you have the <execinfo.h> header file. */
+/* #undef HAVE_EXECINFO_H */
+
+/* Define to 1 if you have the <faad.h> header file. */
+/* #undef HAVE_FAAD_H */
+
+/* Define to 1 if you have the `fcntl' function. */
+#define HAVE_FCNTL 1
+
+/* Define to 1 if you have the <fcntl.h> header file. */
+#define HAVE_FCNTL_H 1
+
+/* Define to 1 if you have the `fdatasync' function. */
+#define HAVE_FDATASYNC 1
+
+/* Define to 1 if you have the `fdopendir' function. */
+#define HAVE_FDOPENDIR 1
+
+/* Define to 1 if you have the `flockfile' function. */
+#define HAVE_FLOCKFILE 1
+
+/* Define to 1 if you have the <fontconfig/fontconfig.h> header file. */
+/* #undef HAVE_FONTCONFIG_FONTCONFIG_H */
+
+/* Define to 1 if you have the `fork' function. */
+#define HAVE_FORK 1
+
+/* Define to 1 if you have the `fstatvfs' function. */
+/* #undef HAVE_FSTATVFS */
+
+/* Define to 1 if you have the `fsync' function. */
+#define HAVE_FSYNC 1
+
+/* Define to 1 if you have the `getcwd' function. */
+#define HAVE_GETCWD 1
+
+/* Define to 1 if you have the `getdelim' function. */
+/* #undef HAVE_GETDELIM */
+
+/* Define to 1 if you have the `getenv' function. */
+#define HAVE_GETENV 1
+
+/* Define to 1 if you have the <getopt.h> header file. */
+#define HAVE_GETOPT_H 1
+
+/* Define to 1 if you have the `getpid' function. */
+#define HAVE_GETPID 1
+
+/* Define to 1 if you have the `getpwuid_r' function. */
+/* #undef HAVE_GETPWUID_R */
+
+/* Define if the GNU gettext() function is already present or preinstalled. */
+/* #undef HAVE_GETTEXT */
+
+/* Define to 1 if you have the `gettimeofday' function. */
+#define HAVE_GETTIMEOFDAY 1
+
+/* Define to 1 if you have the <GL/gl.h> header file. */
+/* #undef HAVE_GL_GL_H */
+
+/* Define to 1 if you have the `gmtime_r' function. */
+#define HAVE_GMTIME_R 1
+
+/* Define if you have the iconv() function and it works. */
+#define HAVE_ICONV 1
+
+/* Define to 1 if you have the `if_nameindex' function. */
+/* #undef HAVE_IF_NAMEINDEX */
+
+/* Define to 1 if you have the `if_nametoindex' function. */
+#define HAVE_IF_NAMETOINDEX 1
+
+/* Define to 1 if you have the `inet_aton' function. */
+#define HAVE_INET_ATON 1
+
+/* Define to 1 if you have inet_ntop(). */
+#define HAVE_INET_NTOP 1
+
+/* Define to 1 if you have inet_pton(). */
+#define HAVE_INET_PTON 1
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#define HAVE_INTTYPES_H 1
+
+/* For FreeBSD VCD support */
+/* #undef HAVE_IOC_TOC_HEADER_IN_SYS_CDIO_H */
+
+/* Define to 1 if you have the `isatty' function. */
+#define HAVE_ISATTY 1
+
+/* Define to 1 if you have the <kate/kate.h> header file. */
+/* #undef HAVE_KATE_KATE_H */
+
+/* Define to 1 if you have the <lauxlib.h> header file. */
+/* #undef HAVE_LAUXLIB_H */
+
+/* Define to 1 if you have the <libavcodec/avcodec.h> header file. */
+#define HAVE_LIBAVCODEC_AVCODEC_H 1
+
+/* Define to 1 if you have the <libavcodec/dxva2.h> header file. */
+/* #undef HAVE_LIBAVCODEC_DXVA2_H */
+
+/* Define to 1 if you have the <libavcodec/vaapi.h> header file. */
+/* #undef HAVE_LIBAVCODEC_VAAPI_H */
+
+/* Define to 1 if you have the <libavformat/avformat.h> header file. */
+#define HAVE_LIBAVFORMAT_AVFORMAT_H 1
+
+/* Define to 1 if you have the <libavformat/avio.h> header file. */
+#define HAVE_LIBAVFORMAT_AVIO_H 1
+
+/* Define to 1 if you have the <libavutil/avutil.h> header file. */
+#define HAVE_LIBAVUTIL_AVUTIL_H 1
+
+/* Define this if you have libcddb installed */
+/* #undef HAVE_LIBCDDB */
+
+/* Define to 1 if you have the <libcrystalhd/bc_drv_if.h> header file. */
+/* #undef HAVE_LIBCRYSTALHD_BC_DRV_IF_H */
+
+/* Define to 1 if you have the <libcrystalhd/bc_dts_defs.h> header file. */
+/* #undef HAVE_LIBCRYSTALHD_BC_DTS_DEFS_H */
+
+/* Define to 1 if you have the `mingw32' library (-lmingw32). */
+/* #undef HAVE_LIBMINGW32 */
+
+/* Define to 1 if you have the `ncursesw' library (-lncursesw). */
+/* #undef HAVE_LIBNCURSESW */
+
+/* Define if libproxy is available */
+/* #undef HAVE_LIBPROXY */
+
+/* Define to 1 if you have the <libsmbclient.h> header file. */
+/* #undef HAVE_LIBSMBCLIENT_H */
+
+/* Define to 1 if you have the <libssh2.h> header file. */
+/* #undef HAVE_LIBSSH2_H */
+
+/* Define to 1 if you have the <libswscale/swscale.h> header file. */
+#define HAVE_LIBSWSCALE_SWSCALE_H 1
+
+/* Define to 1 if you have the <libtar.h> header file. */
+/* #undef HAVE_LIBTAR_H */
+
+/* Define if libv4l2 is available */
+/* #undef HAVE_LIBV4L2 */
+
+/* Define to 1 if you have the <linux/dccp.h> header file. */
+#define HAVE_LINUX_DCCP_H 1
+
+/* Define to 1 if you have the <linux/fb.h> header file. */
+/* #undef HAVE_LINUX_FB_H */
+
+/* Define to 1 if you have the <linux/magic.h> header file. */
+#define HAVE_LINUX_MAGIC_H 1
+
+/* Define to 1 if you have the <linux/version.h> header file. */
+#define HAVE_LINUX_VERSION_H 1
+
+/* Define to 1 if you have the <linux/videodev2.h> header file. */
+/* #undef HAVE_LINUX_VIDEODEV2_H */
+
+/* Define to 1 if you have the <liveMedia_version.hh> header file. */
+/* #undef HAVE_LIVEMEDIA_VERSION_HH */
+
+/* Define to 1 if you have the `lldiv' function. */
+#define HAVE_LLDIV 1
+
+/* Define to 1 if you have the <locale.h> header file. */
+#define HAVE_LOCALE_H 1
+
+/* Define to 1 if you have the `localtime_r' function. */
+#define HAVE_LOCALTIME_R 1
+
+/* Define to 1 if you have the lrintf function */
+#define HAVE_LRINTF 1
+
+/* Define to 1 if you have the `lstat' function. */
+#define HAVE_LSTAT 1
+
+/* Define to 1 if you have the <lualib.h> header file. */
+/* #undef HAVE_LUALIB_H */
+
+/* Define to 1 if you have the <lua.h> header file. */
+/* #undef HAVE_LUA_H */
+
+/* Define to 1 if you have the <machine/param.h> header file. */
+/* #undef HAVE_MACHINE_PARAM_H */
+
+/* Define to 1 if you have the <mad.h> header file. */
+/* #undef HAVE_MAD_H */
+
+/* Define to 1 if building for the Maemo platform. */
+/* #undef HAVE_MAEMO */
+
+/* Define to 1 if you have the <matroska/KaxAttachments.h> header file. */
+/* #undef HAVE_MATROSKA_KAXATTACHMENTS_H */
+
+/* Define to 1 if you have the <matroska/KaxVersion.h> header file. */
+/* #undef HAVE_MATROSKA_KAXVERSION_H */
+
+/* Define to 1 if you have the `memalign' function. */
+#define HAVE_MEMALIGN 1
+
+/* Define to 1 if you have the <memory.h> header file. */
+#define HAVE_MEMORY_H 1
+
+/* Define to 1 if you have the `mmap' function. */
+#define HAVE_MMAP 1
+
+/* Define to 1 if MMX intrinsics are available. */
+/* #undef HAVE_MMX_INTRINSICS */
+
+/* Define to 1 if you have the <mpcdec/mpcdec.h> header file. */
+/* #undef HAVE_MPCDEC_MPCDEC_H */
+
+/* Define to 1 if you have the <mpc/mpcdec.h> header file. */
+/* #undef HAVE_MPC_MPCDEC_H */
+
+/* Define if nanosleep is available. */
+#define HAVE_NANOSLEEP 1
+
+/* Define to 1 if you have the <netinet/in.h> header file. */
+#define HAVE_NETINET_IN_H 1
+
+/* Define to 1 if you have the <netinet/udplite.h> header file. */
+/* #undef HAVE_NETINET_UDPLITE_H */
+
+/* Define to 1 if you have the <net/if.h> header file. */
+#define HAVE_NET_IF_H 1
+
+/* Define to 1 if you have the `nrand48' function. */
+#define HAVE_NRAND48 1
+
+/* Define to 1 if you have the `openat' function. */
+#define HAVE_OPENAT 1
+
+/* Define to 1 if you have the <OpenGL/gl.h> header file. */
+/* #undef HAVE_OPENGL_GL_H */
+
+/* Define to 1 if you have the `pipe2' function. */
+/* #undef HAVE_PIPE2 */
+
+/* Define to 1 if you have the <png.h> header file. */
+/* #undef HAVE_PNG_H */
+
+/* Define to 1 if the OS is usabl... err, has poll(). */
+#define HAVE_POLL 1
+
+/* Define to 1 if you have the `posix_fadvise' function. */
+/* #undef HAVE_POSIX_FADVISE */
+
+/* Define to 1 if you have the `posix_madvise' function. */
+/* #undef HAVE_POSIX_MADVISE */
+
+/* Define to 1 if you have the `posix_memalign' function. */
+/* #undef HAVE_POSIX_MEMALIGN */
+
+/* Define to 1 if you have the <postproc/postprocess.h> header file. */
+/* #undef HAVE_POSTPROC_POSTPROCESS_H */
+
+/* Define to 1 if you have the `pread' function. */
+#define HAVE_PREAD 1
+
+/* Define to 1 if using libprojectM 2.x */
+/* #undef HAVE_PROJECTM2 */
+
+/* Define to 1 if you have the <pthread.h> header file. */
+#define HAVE_PTHREAD_H 1
+
+/* Define to 1 if you have the `pthread_mutex_lock' function. */
+#define HAVE_PTHREAD_MUTEX_LOCK 1
+
+/* Define to 1 if you have the <QuickTime/QuickTime.h> header file. */
+/* #undef HAVE_QUICKTIME_QUICKTIME_H */
+
+/* Define to 1 if you have the `rewind' function. */
+#define HAVE_REWIND 1
+
+/* Define to 1 if you have the `sched_getaffinity' function. */
+/* #undef HAVE_SCHED_GETAFFINITY */
+
+/* For NetBSD VCD support */
+/* #undef HAVE_SCSIREQ_IN_SYS_SCSIIO_H */
+
+/* Define to 1 if you have the <scsi/scsi.h> header file. */
+/* #undef HAVE_SCSI_SCSI_H */
+
+/* Define to 1 if you have the <search.h> header file. */
+/* #undef HAVE_SEARCH_H */
+
+/* Define to 1 if you have the `send' function. */
+#define HAVE_SEND 1
+
+/* Define to 1 if you have the `setenv' function. */
+#define HAVE_SETENV 1
+
+/* Define to 1 if you have the `setlocale' function. */
+#define HAVE_SETLOCALE 1
+
+/* Define to 1 if you have the <SLES/OpenSLES.h> header file. */
+#define HAVE_SLES_OPENSLES_H 1
+
+/* Define to 1 if you have the <soundcard.h> header file. */
+/* #undef HAVE_SOUNDCARD_H */
+
+/* Define to 1 if you have the <sqlite3.h> header file. */
+/* #undef HAVE_SQLITE3_H */
+
+/* Define to 1 if SSE2 intrinsics are available. */
+/* #undef HAVE_SSE2_INTRINSICS */
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#define HAVE_STDINT_H 1
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#define HAVE_STDLIB_H 1
+
+/* Define to 1 if you have the `strcasecmp' function. */
+#define HAVE_STRCASECMP 1
+
+/* Define to 1 if you have the `strcasestr' function. */
+#define HAVE_STRCASESTR 1
+
+/* Define to 1 if you have the `strcoll' function and it is properly defined.
+   */
+/* #undef HAVE_STRCOLL */
+
+/* Define to 1 if you have the `strdup' function. */
+#define HAVE_STRDUP 1
+
+/* Define to 1 if you have the `stricmp' function. */
+/* #undef HAVE_STRICMP */
+
+/* Define to 1 if you have the <strings.h> header file. */
+#define HAVE_STRINGS_H 1
+
+/* Define to 1 if you have the <string.h> header file. */
+#define HAVE_STRING_H 1
+
+/* Define to 1 if you have the `strlcpy' function. */
+#define HAVE_STRLCPY 1
+
+/* Define to 1 if you have the `strncasecmp' function. */
+#define HAVE_STRNCASECMP 1
+
+/* Define to 1 if you have the `strndup' function. */
+#define HAVE_STRNDUP 1
+
+/* Define to 1 if you have the `strnicmp' function. */
+/* #undef HAVE_STRNICMP */
+
+/* Define to 1 if you have the `strnlen' function. */
+#define HAVE_STRNLEN 1
+
+/* Define to 1 if you have the `strsep' function. */
+#define HAVE_STRSEP 1
+
+/* Define to 1 if you have the `strtof' function. */
+#define HAVE_STRTOF 1
+
+/* Define to 1 if you have the `strtok_r' function. */
+#define HAVE_STRTOK_R 1
+
+/* Define to 1 if you have the `strtoll' function. */
+#define HAVE_STRTOLL 1
+
+/* Define if <sys/time.h> defines struct timespec. */
+#define HAVE_STRUCT_TIMESPEC 1
+
+/* Define to 1 if you have the `swab' function. */
+/* #undef HAVE_SWAB */
+
+/* Define to 1 if you have the <syslog.h> header file. */
+#define HAVE_SYSLOG_H 1
+
+/* Define to 1 if you have the <sys/dl.h> header file. */
+/* #undef HAVE_SYS_DL_H */
+
+/* Define to 1 if you have the <sys/eventfd.h> header file. */
+/* #undef HAVE_SYS_EVENTFD_H */
+
+/* Define to 1 if you have the <sys/ioctl.h> header file. */
+#define HAVE_SYS_IOCTL_H 1
+
+/* Define to 1 if you have the <sys/mount.h> header file. */
+#define HAVE_SYS_MOUNT_H 1
+
+/* Define to 1 if you have the <sys/shm.h> header file. */
+/* #undef HAVE_SYS_SHM_H */
+
+/* Define to 1 if you have the <sys/soundcard.h> header file. */
+/* #undef HAVE_SYS_SOUNDCARD_H */
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#define HAVE_SYS_STAT_H 1
+
+/* Define to 1 if you have the <sys/time.h> header file. */
+#define HAVE_SYS_TIME_H 1
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#define HAVE_SYS_TYPES_H 1
+
+/* Define to 1 if you have the <sys/videoio.h> header file. */
+/* #undef HAVE_SYS_VIDEOIO_H */
+
+/* Define to 1 if you have the `tdestroy' function. */
+/* #undef HAVE_TDESTROY */
+
+/* Define if libtiger is available. */
+/* #undef HAVE_TIGER */
+
+/* Define to 1 if you have the <tremor/ivorbiscodec.h> header file. */
+/* #undef HAVE_TREMOR_IVORBISCODEC_H */
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#define HAVE_UNISTD_H 1
+
+/* Define to 1 if you have the <unzip.h> header file. */
+/* #undef HAVE_UNZIP_H */
+
+/* Define to 1 if you have the `uselocale' function. */
+/* #undef HAVE_USELOCALE */
+
+/* Define to 1 if you have the <valgrind/valgrind.h> header file. */
+/* #undef HAVE_VALGRIND_VALGRIND_H */
+
+/* Define to 1 if you have the `vasprintf' function. */
+#define HAVE_VASPRINTF 1
+
+/* Define if <stdarg.h> defines va_copy. */
+#define HAVE_VA_COPY 1
+
+/* Define to 1 if you have the `vmsplice' function. */
+/* #undef HAVE_VMSPLICE */
+
+/* Define to 1 if you have the <X11/Xlib.h> header file. */
+/* #undef HAVE_X11_XLIB_H */
+
+/* Define to 1 if you have the <xlocale.h> header file. */
+/* #undef HAVE_XLOCALE_H */
+
+/* Define to 1 if you have the <xosd.h> header file. */
+/* #undef HAVE_XOSD_H */
+
+/* Define to 1 if you have the <zlib.h> header file. */
+#define HAVE_ZLIB_H 1
+
+/* Define if <stdarg.h> defines __va_copy. */
+#define HAVE___VA_COPY 1
+
+/* Define as const if the declaration of iconv() needs const. */
+/* #undef ICONV_CONST */
+
+/* Dynamic object extension */
+#define LIBEXT ".so"
+
+/* Define to the sub-directory in which libtool stores uninstalled libraries.
+   */
+#define LT_OBJDIR ".libs/"
+
+/* Define if you want to use the VLC media library */
+/* #undef MEDIA_LIBRARY */
+
+/* Define to 1 if debug code should NOT be compiled */
+#define NDEBUG 1
+
+/* Define to 1 if your C compiler doesn't accept -c and -o together. */
+/* #undef NO_MINUS_C_MINUS_O */
+
+/* Define if <sys/param.h> defines ntohl. */
+/* #undef NTOHL_IN_SYS_PARAM_H */
+
+/* Define if you want to optimize memory usage over performance */
+/* #undef OPTIMIZE_MEMORY */
+
+/* Name of package */
+#define PACKAGE "vlc"
+
+/* Define to the address where bug reports for this package should be sent. */
+#define PACKAGE_BUGREPORT ""
+
+/* Define to the full name of this package. */
+#define PACKAGE_NAME "vlc"
+
+/* Define to the full name and version of this package. */
+#define PACKAGE_STRING "vlc 1.2.0-git"
+
+/* Define to the one symbol short name of this package. */
+#define PACKAGE_TARNAME "vlc"
+
+/* Define to the home page for this package. */
+#define PACKAGE_URL ""
+
+/* Define to the version of this package. */
+#define PACKAGE_VERSION "1.2.0-git"
+
+/* version minor number */
+#define PACKAGE_VERSION_EXTRA "-git"
+
+/* version major number */
+#define PACKAGE_VERSION_MAJOR "1"
+
+/* version minor number */
+#define PACKAGE_VERSION_MINOR "2"
+
+/* version minor number */
+#define PACKAGE_VERSION_REVISION "0"
+
+/* Define if you want to use SQLite module */
+/* #undef SQLITE_MODULE */
+
+/* Define to 1 if you have the ANSI C header files. */
+#define STDC_HEADERS 1
+
+/* Define if <strings.h> defines strncasecmp. */
+#define STRNCASECMP_IN_STRINGS_H 1
+
+/* Define if you want to use the VLC update mechanism */
+/* #undef UPDATE_CHECK */
+
+/* Enable extensions on AIX 3, Interix.  */
+#ifndef _ALL_SOURCE
+# define _ALL_SOURCE 1
+#endif
+/* Enable GNU extensions on systems that have them.  */
+#ifndef _GNU_SOURCE
+# define _GNU_SOURCE 1
+#endif
+/* Enable threading extensions on Solaris.  */
+#ifndef _POSIX_PTHREAD_SEMANTICS
+# define _POSIX_PTHREAD_SEMANTICS 1
+#endif
+/* Enable extensions on HP NonStop.  */
+#ifndef _TANDEM_SOURCE
+# define _TANDEM_SOURCE 1
+#endif
+/* Enable general extensions on Solaris.  */
+#ifndef __EXTENSIONS__
+# define __EXTENSIONS__ 1
+#endif
+
+
+/* Version number of package */
+#define VERSION "1.2.0-git"
+
+/* Simple version string */
+#define VERSION_MESSAGE "1.2.0-git Twoflower"
+
+/* compiler */
+#define VLC_COMPILER "gcc version 4.4.3 (GCC) "
+
+/* user who ran configure */
+#define VLC_COMPILE_BY "luka"
+
+/* host which ran configure */
+#define VLC_COMPILE_HOST "luka-laptop"
+
+/* Define WORDS_BIGENDIAN to 1 if your processor stores words with the most
+   significant byte first (like Motorola and SPARC, unlike Intel). */
+#if defined AC_APPLE_UNIVERSAL_BUILD
+# if defined __BIG_ENDIAN__
+#  define WORDS_BIGENDIAN 1
+# endif
+#else
+# ifndef WORDS_BIGENDIAN
+/* #  undef WORDS_BIGENDIAN */
+# endif
+#endif
+
+/* Define to 1 if the X Window System is missing or not being used. */
+/* #undef X_DISPLAY_MISSING */
+
+/* Define if the zvbi module is built */
+/* #undef ZVBI_COMPILED */
+
+/* Define to 64 for large files support. */
+#define _FILE_OFFSET_BITS 64
+
+/* Define to 2 to get glibc warnings. */
+#define _FORTIFY_SOURCE 2
+
+/* Define to 1 if on MINIX. */
+/* #undef _MINIX */
+
+/* Define to 2 if the system does not provide POSIX.1 features except with
+   this defined. */
+/* #undef _POSIX_1_SOURCE */
+
+/* Define to 1 if you need to in order for `stat' and other things to work. */
+/* #undef _POSIX_SOURCE */
+
+/* Define to expose reentrant functions. */
+#define _REENTRANT /**/
+
+/* Same as _REENTANT for some other OSes. */
+#define _THREAD_SAFE /**/
+
+/* Define to '0x0501' for IE 5.01 (and shell) APIs. */
+/* #undef _WIN32_IE */
+
+/* Define to '0x0501' for Windows XP APIs. */
+/* #undef _WIN32_WINNT */
+
+/* Define within the LibVLC source code tree. */
+#define __LIBVLC__ /**/
+
+/* Define to empty if `const' does not conform to ANSI C. */
+/* #undef const */
+
+/* Alias fdatasync() to fsync() if missing. */
+/* #undef fdatasync */
+
+/* Define to `__inline__' or `__inline' if that's what the C compiler
+   calls it, or to nothing if 'inline' is not supported under any name.  */
+#ifndef __cplusplus
+/* #undef inline */
+#endif
+
+/* Define to the equivalent of the C99 'restrict' keyword, or to
+   nothing if this is not supported.  Do not define if restrict is
+   supported directly.  */
+#define restrict __restrict
+/* Work around a bug in Sun C++: it does not support _Restrict or
+   __restrict__, even though the corresponding Sun C compiler ends up with
+   "#define restrict _Restrict" or "#define restrict __restrict__" in the
+   previous line.  Perhaps some future version of Sun C++ will work with
+   restrict; if so, hopefully it defines __RESTRICT like Sun C does.  */
+#if defined __SUNPRO_CC && !defined __RESTRICT
+# define _Restrict
+# define __restrict__
+#endif
+
+/* Define to `sockaddr' if <sys/socket.h> does not define. */
+/* #undef sockaddr_storage */
+
+/* Define to `int' if <sys/socket.h> does not define. */
+/* #undef socklen_t */
+
+/* Define to `sa_family' if <sys/socket.h> does not define. */
+/* #undef ss_family */
+
+/* Define to `int' if <stddef.h> does not define. */
+/* #undef ssize_t */
+
+#include <vlc_fixups.h>
diff -Nurp vlc-a/include/vlc/libvlc.h vlc-b/include/vlc/libvlc.h
--- vlc-a/include/vlc/libvlc.h	2011-07-18 20:34:11.518213274 +0800
+++ vlc-b/include/vlc/libvlc.h	2011-07-10 01:53:48.924261749 +0800
@@ -138,6 +138,39 @@ LIBVLC_API libvlc_instance_t *
 libvlc_new( int argc , const char *const *argv );
 
 /**
+ * \return a static entry point for a module, suitable for passing to
+ * libvlc_new_with_builtins. This is to be used when you want to statically
+ * link to a module.
+ *
+ * Note, statically linking to a module will results in nearly zero speed gain
+ * and increased memory usage. Use with caution.
+ */
+
+#define vlc_plugin(module) & vlc_plugin_entry(module)
+
+#define vlc_plugin_entry(module) vlc_entry__ ## module
+#define vlc_declare_plugin(module) extern void *vlc_plugin_entry(module);
+
+/**
+ * Create and initialize a libvlc instance.
+ *
+ * \param argc the number of arguments
+ * \param argv command-line-type arguments
+ * \param builtins a NULL terminated array of \see vlc_plugin.
+ * \return the libvlc instance or NULL in case of error
+ * @begincode
+ * {
+ *     vlc_declare_plugin(mp4);
+ *     vlc_declare_plugin(dummy);
+ *     const void **builtins = { vlc_plugin(mp4), vlc_plugin(dummy), NULL };
+ *     libvlc_instance_t *vlc = libvlc_new_with_builtins(argc, argv, builtins);
+ * }
+ * @endcode
+ */
+LIBVLC_API libvlc_instance_t *
+libvlc_new_with_builtins( int argc , const char *const *argv, const void **builtins);
+
+/**
  * Decrement the reference count of a libvlc instance, and destroy it
  * if it reaches zero.
  *
diff -Nurp vlc-a/include/vlc/libvlc_version.h vlc-b/include/vlc/libvlc_version.h
--- vlc-a/include/vlc/libvlc_version.h	1970-01-01 08:00:00.000000000 +0800
+++ vlc-b/include/vlc/libvlc_version.h	2011-07-10 01:53:48.926261759 +0800
@@ -0,0 +1,55 @@
+/*****************************************************************************
+ * libvlc_version.h
+ *****************************************************************************
+ * Copyright (C) 2010 Rémi Denis-Courmont
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+/**
+ * \file
+ * This file defines version macros for LibVLC.
+ * Those macros are primilarly intended for conditional (pre)compilation.
+ * To get the run-time LibVLC version, use libvlc_get_version() instead
+ * (the run-time version may be more recent than build-time one, thanks to
+ * backward binary compatibility).
+ *
+ * \version This header file is available in LibVLC 1.1.4 and higher.
+ */
+
+#ifndef LIBVLC_VERSION_H
+# define LIBVLC_VERSION_H 1
+
+/** LibVLC major version number */
+# define LIBVLC_VERSION_MAJOR    (1)
+
+/** LibVLC minor version number */
+# define LIBVLC_VERSION_MINOR    (2)
+
+/** LibVLC revision */
+# define LIBVLC_VERSION_REVISION (0)
+
+# define LIBVLC_VERSION_EXTRA    (0)
+
+/** Makes a single integer from a LibVLC version numbers */
+# define LIBVLC_VERSION(maj,min,rev,extra) \
+         ((maj << 24) | (min << 16) | (rev << 8) | (extra))
+
+/** LibVLC full version as a single integer (for comparison) */
+# define LIBVLC_VERSION_INT \
+         LIBVLC_VERSION(LIBVLC_VERSION_MAJOR, LIBVLC_VERSION_MINOR, \
+                        LIBVLC_VERSION_EXTRA, LIBVLC_VERSION_EXTRA)
+
+#endif
diff -Nurp vlc-a/include/vlc_about.h vlc-b/include/vlc_about.h
--- vlc-a/include/vlc_about.h	1970-01-01 08:00:00.000000000 +0800
+++ vlc-b/include/vlc_about.h	2011-07-10 01:53:48.927261764 +0800
@@ -0,0 +1,775 @@
+/* Automatically generated file - DO NOT EDIT */
+static const char psz_license[] =
+"                    GNU GENERAL PUBLIC LICENSE\n"
+"                       Version 2, June 1991\n"
+"\n"
+" Copyright (C) 1989, 1991 Free Software Foundation, Inc.\n"
+" 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA\n"
+" Everyone is permitted to copy and distribute verbatim copies\n"
+" of this license document, but changing it is not allowed.\n"
+"\n"
+"                            Preamble\n"
+"\n"
+"  The licenses for most software are designed to take away your\n"
+"freedom to share and change it.  By contrast, the GNU General Public\n"
+"License is intended to guarantee your freedom to share and change free\n"
+"software--to make sure the software is free for all its users.  This\n"
+"General Public License applies to most of the Free Software\n"
+"Foundation's software and to any other program whose authors commit to\n"
+"using it.  (Some other Free Software Foundation software is covered by\n"
+"the GNU Library General Public License instead.)  You can apply it to\n"
+"your programs, too.\n"
+"\n"
+"  When we speak of free software, we are referring to freedom, not\n"
+"price.  Our General Public Licenses are designed to make sure that you\n"
+"have the freedom to distribute copies of free software (and charge for\n"
+"this service if you wish), that you receive source code or can get it\n"
+"if you want it, that you can change the software or use pieces of it\n"
+"in new free programs; and that you know you can do these things.\n"
+"\n"
+"  To protect your rights, we need to make restrictions that forbid\n"
+"anyone to deny you these rights or to ask you to surrender the rights.\n"
+"These restrictions translate to certain responsibilities for you if you\n"
+"distribute copies of the software, or if you modify it.\n"
+"\n"
+"  For example, if you distribute copies of such a program, whether\n"
+"gratis or for a fee, you must give the recipients all the rights that\n"
+"you have.  You must make sure that they, too, receive or can get the\n"
+"source code.  And you must show them these terms so they know their\n"
+"rights.\n"
+"\n"
+"  We protect your rights with two steps: (1) copyright the software, and\n"
+"(2) offer you this license which gives you legal permission to copy,\n"
+"distribute and/or modify the software.\n"
+"\n"
+"  Also, for each author's protection and ours, we want to make certain\n"
+"that everyone understands that there is no warranty for this free\n"
+"software.  If the software is modified by someone else and passed on, we\n"
+"want its recipients to know that what they have is not the original, so\n"
+"that any problems introduced by others will not reflect on the original\n"
+"authors' reputations.\n"
+"\n"
+"  Finally, any free program is threatened constantly by software\n"
+"patents.  We wish to avoid the danger that redistributors of a free\n"
+"program will individually obtain patent licenses, in effect making the\n"
+"program proprietary.  To prevent this, we have made it clear that any\n"
+"patent must be licensed for everyone's free use or not licensed at all.\n"
+"\n"
+"  The precise terms and conditions for copying, distribution and\n"
+"modification follow.\n"
+"\n"
+"                    GNU GENERAL PUBLIC LICENSE\n"
+"   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION\n"
+"\n"
+"  0. This License applies to any program or other work which contains\n"
+"a notice placed by the copyright holder saying it may be distributed\n"
+"under the terms of this General Public License.  The \"Program\", below,\n"
+"refers to any such program or work, and a \"work based on the Program\"\n"
+"means either the Program or any derivative work under copyright law:\n"
+"that is to say, a work containing the Program or a portion of it,\n"
+"either verbatim or with modifications and/or translated into another\n"
+"language.  (Hereinafter, translation is included without limitation in\n"
+"the term \"modification\".)  Each licensee is addressed as \"you\".\n"
+"\n"
+"Activities other than copying, distribution and modification are not\n"
+"covered by this License; they are outside its scope.  The act of\n"
+"running the Program is not restricted, and the output from the Program\n"
+"is covered only if its contents constitute a work based on the\n"
+"Program (independent of having been made by running the Program).\n"
+"Whether that is true depends on what the Program does.\n"
+"\n"
+"  1. You may copy and distribute verbatim copies of the Program's\n"
+"source code as you receive it, in any medium, provided that you\n"
+"conspicuously and appropriately publish on each copy an appropriate\n"
+"copyright notice and disclaimer of warranty; keep intact all the\n"
+"notices that refer to this License and to the absence of any warranty;\n"
+"and give any other recipients of the Program a copy of this License\n"
+"along with the Program.\n"
+"\n"
+"You may charge a fee for the physical act of transferring a copy, and\n"
+"you may at your option offer warranty protection in exchange for a fee.\n"
+"\n"
+"  2. You may modify your copy or copies of the Program or any portion\n"
+"of it, thus forming a work based on the Program, and copy and\n"
+"distribute such modifications or work under the terms of Section 1\n"
+"above, provided that you also meet all of these conditions:\n"
+"\n"
+"    a) You must cause the modified files to carry prominent notices\n"
+"    stating that you changed the files and the date of any change.\n"
+"\n"
+"    b) You must cause any work that you distribute or publish, that in\n"
+"    whole or in part contains or is derived from the Program or any\n"
+"    part thereof, to be licensed as a whole at no charge to all third\n"
+"    parties under the terms of this License.\n"
+"\n"
+"    c) If the modified program normally reads commands interactively\n"
+"    when run, you must cause it, when started running for such\n"
+"    interactive use in the most ordinary way, to print or display an\n"
+"    announcement including an appropriate copyright notice and a\n"
+"    notice that there is no warranty (or else, saying that you provide\n"
+"    a warranty) and that users may redistribute the program under\n"
+"    these conditions, and telling the user how to view a copy of this\n"
+"    License.  (Exception: if the Program itself is interactive but\n"
+"    does not normally print such an announcement, your work based on\n"
+"    the Program is not required to print an announcement.)\n"
+"\n"
+"These requirements apply to the modified work as a whole.  If\n"
+"identifiable sections of that work are not derived from the Program,\n"
+"and can be reasonably considered independent and separate works in\n"
+"themselves, then this License, and its terms, do not apply to those\n"
+"sections when you distribute them as separate works.  But when you\n"
+"distribute the same sections as part of a whole which is a work based\n"
+"on the Program, the distribution of the whole must be on the terms of\n"
+"this License, whose permissions for other licensees extend to the\n"
+"entire whole, and thus to each and every part regardless of who wrote it.\n"
+"\n"
+"Thus, it is not the intent of this section to claim rights or contest\n"
+"your rights to work written entirely by you; rather, the intent is to\n"
+"exercise the right to control the distribution of derivative or\n"
+"collective works based on the Program.\n"
+"\n"
+"In addition, mere aggregation of another work not based on the Program\n"
+"with the Program (or with a work based on the Program) on a volume of\n"
+"a storage or distribution medium does not bring the other work under\n"
+"the scope of this License.\n"
+"\n"
+"  3. You may copy and distribute the Program (or a work based on it,\n"
+"under Section 2) in object code or executable form under the terms of\n"
+"Sections 1 and 2 above provided that you also do one of the following:\n"
+"\n"
+"    a) Accompany it with the complete corresponding machine-readable\n"
+"    source code, which must be distributed under the terms of Sections\n"
+"    1 and 2 above on a medium customarily used for software interchange; or,\n"
+"\n"
+"    b) Accompany it with a written offer, valid for at least three\n"
+"    years, to give any third party, for a charge no more than your\n"
+"    cost of physically performing source distribution, a complete\n"
+"    machine-readable copy of the corresponding source code, to be\n"
+"    distributed under the terms of Sections 1 and 2 above on a medium\n"
+"    customarily used for software interchange; or,\n"
+"\n"
+"    c) Accompany it with the information you received as to the offer\n"
+"    to distribute corresponding source code.  (This alternative is\n"
+"    allowed only for noncommercial distribution and only if you\n"
+"    received the program in object code or executable form with such\n"
+"    an offer, in accord with Subsection b above.)\n"
+"\n"
+"The source code for a work means the preferred form of the work for\n"
+"making modifications to it.  For an executable work, complete source\n"
+"code means all the source code for all modules it contains, plus any\n"
+"associated interface definition files, plus the scripts used to\n"
+"control compilation and installation of the executable.  However, as a\n"
+"special exception, the source code distributed need not include\n"
+"anything that is normally distributed (in either source or binary\n"
+"form) with the major components (compiler, kernel, and so on) of the\n"
+"operating system on which the executable runs, unless that component\n"
+"itself accompanies the executable.\n"
+"\n"
+"If distribution of executable or object code is made by offering\n"
+"access to copy from a designated place, then offering equivalent\n"
+"access to copy the source code from the same place counts as\n"
+"distribution of the source code, even though third parties are not\n"
+"compelled to copy the source along with the object code.\n"
+"\n"
+"  4. You may not copy, modify, sublicense, or distribute the Program\n"
+"except as expressly provided under this License.  Any attempt\n"
+"otherwise to copy, modify, sublicense or distribute the Program is\n"
+"void, and will automatically terminate your rights under this License.\n"
+"However, parties who have received copies, or rights, from you under\n"
+"this License will not have their licenses terminated so long as such\n"
+"parties remain in full compliance.\n"
+"\n"
+"  5. You are not required to accept this License, since you have not\n"
+"signed it.  However, nothing else grants you permission to modify or\n"
+"distribute the Program or its derivative works.  These actions are\n"
+"prohibited by law if you do not accept this License.  Therefore, by\n"
+"modifying or distributing the Program (or any work based on the\n"
+"Program), you indicate your acceptance of this License to do so, and\n"
+"all its terms and conditions for copying, distributing or modifying\n"
+"the Program or works based on it.\n"
+"\n"
+"  6. Each time you redistribute the Program (or any work based on the\n"
+"Program), the recipient automatically receives a license from the\n"
+"original licensor to copy, distribute or modify the Program subject to\n"
+"these terms and conditions.  You may not impose any further\n"
+"restrictions on the recipients' exercise of the rights granted herein.\n"
+"You are not responsible for enforcing compliance by third parties to\n"
+"this License.\n"
+"\n"
+"  7. If, as a consequence of a court judgment or allegation of patent\n"
+"infringement or for any other reason (not limited to patent issues),\n"
+"conditions are imposed on you (whether by court order, agreement or\n"
+"otherwise) that contradict the conditions of this License, they do not\n"
+"excuse you from the conditions of this License.  If you cannot\n"
+"distribute so as to satisfy simultaneously your obligations under this\n"
+"License and any other pertinent obligations, then as a consequence you\n"
+"may not distribute the Program at all.  For example, if a patent\n"
+"license would not permit royalty-free redistribution of the Program by\n"
+"all those who receive copies directly or indirectly through you, then\n"
+"the only way you could satisfy both it and this License would be to\n"
+"refrain entirely from distribution of the Program.\n"
+"\n"
+"If any portion of this section is held invalid or unenforceable under\n"
+"any particular circumstance, the balance of the section is intended to\n"
+"apply and the section as a whole is intended to apply in other\n"
+"circumstances.\n"
+"\n"
+"It is not the purpose of this section to induce you to infringe any\n"
+"patents or other property right claims or to contest validity of any\n"
+"such claims; this section has the sole purpose of protecting the\n"
+"integrity of the free software distribution system, which is\n"
+"implemented by public license practices.  Many people have made\n"
+"generous contributions to the wide range of software distributed\n"
+"through that system in reliance on consistent application of that\n"
+"system; it is up to the author/donor to decide if he or she is willing\n"
+"to distribute software through any other system and a licensee cannot\n"
+"impose that choice.\n"
+"\n"
+"This section is intended to make thoroughly clear what is believed to\n"
+"be a consequence of the rest of this License.\n"
+"\n"
+"  8. If the distribution and/or use of the Program is restricted in\n"
+"certain countries either by patents or by copyrighted interfaces, the\n"
+"original copyright holder who places the Program under this License\n"
+"may add an explicit geographical distribution limitation excluding\n"
+"those countries, so that distribution is permitted only in or among\n"
+"countries not thus excluded.  In such case, this License incorporates\n"
+"the limitation as if written in the body of this License.\n"
+"\n"
+"  9. The Free Software Foundation may publish revised and/or new versions\n"
+"of the General Public License from time to time.  Such new versions will\n"
+"be similar in spirit to the present version, but may differ in detail to\n"
+"address new problems or concerns.\n"
+"\n"
+"Each version is given a distinguishing version number.  If the Program\n"
+"specifies a version number of this License which applies to it and \"any\n"
+"later version\", you have the option of following the terms and conditions\n"
+"either of that version or of any later version published by the Free\n"
+"Software Foundation.  If the Program does not specify a version number of\n"
+"this License, you may choose any version ever published by the Free Software\n"
+"Foundation.\n"
+"\n"
+"  10. If you wish to incorporate parts of the Program into other free\n"
+"programs whose distribution conditions are different, write to the author\n"
+"to ask for permission.  For software which is copyrighted by the Free\n"
+"Software Foundation, write to the Free Software Foundation; we sometimes\n"
+"make exceptions for this.  Our decision will be guided by the two goals\n"
+"of preserving the free status of all derivatives of our free software and\n"
+"of promoting the sharing and reuse of software generally.\n"
+"\n"
+"                            NO WARRANTY\n"
+"\n"
+"  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY\n"
+"FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN\n"
+"OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES\n"
+"PROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED\n"
+"OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n"
+"MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS\n"
+"TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE\n"
+"PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,\n"
+"REPAIR OR CORRECTION.\n"
+"\n"
+"  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\n"
+"WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR\n"
+"REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,\n"
+"INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING\n"
+"OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED\n"
+"TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY\n"
+"YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER\n"
+"PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE\n"
+"POSSIBILITY OF SUCH DAMAGES.\n"
+"\n"
+"                     END OF TERMS AND CONDITIONS\n"
+"\n"
+"            How to Apply These Terms to Your New Programs\n"
+"\n"
+"  If you develop a new program, and you want it to be of the greatest\n"
+"possible use to the public, the best way to achieve this is to make it\n"
+"free software which everyone can redistribute and change under these terms.\n"
+"\n"
+"  To do so, attach the following notices to the program.  It is safest\n"
+"to attach them to the start of each source file to most effectively\n"
+"convey the exclusion of warranty; and each file should have at least\n"
+"the \"copyright\" line and a pointer to where the full notice is found.\n"
+"\n"
+"    <one line to give the program's name and a brief idea of what it does.>\n"
+"    Copyright (C) <year>  <name of author>\n"
+"\n"
+"    This program is free software; you can redistribute it and/or modify\n"
+"    it under the terms of the GNU General Public License as published by\n"
+"    the Free Software Foundation; either version 2 of the License, or\n"
+"    (at your option) any later version.\n"
+"\n"
+"    This program is distributed in the hope that it will be useful,\n"
+"    but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
+"    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"
+"    GNU General Public License for more details.\n"
+"\n"
+"    You should have received a copy of the GNU General Public License\n"
+"    along with this program; if not, write to the Free Software\n"
+"    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA\n"
+"\n"
+"\n"
+"Also add information on how to contact you by electronic and paper mail.\n"
+"\n"
+"If the program is interactive, make it output a short notice like this\n"
+"when it starts in an interactive mode:\n"
+"\n"
+"    Gnomovision version 69, Copyright (C) year name of author\n"
+"    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.\n"
+"    This is free software, and you are welcome to redistribute it\n"
+"    under certain conditions; type `show c' for details.\n"
+"\n"
+"The hypothetical commands `show w' and `show c' should show the appropriate\n"
+"parts of the General Public License.  Of course, the commands you use may\n"
+"be called something other than `show w' and `show c'; they could even be\n"
+"mouse-clicks or menu items--whatever suits your program.\n"
+"\n"
+"You should also get your employer (if you work as a programmer) or your\n"
+"school, if any, to sign a \"copyright disclaimer\" for the program, if\n"
+"necessary.  Here is a sample; alter the names:\n"
+"\n"
+"  Yoyodyne, Inc., hereby disclaims all copyright interest in the program\n"
+"  `Gnomovision' (which makes passes at compilers) written by James Hacker.\n"
+"\n"
+"  <signature of Ty Coon>, 1 April 1989\n"
+"  Ty Coon, President of Vice\n"
+"\n"
+"This General Public License does not permit incorporating your program into\n"
+"proprietary programs.  If your program is a subroutine library, you may\n"
+"consider it more useful to permit linking proprietary applications with the\n"
+"library.  If this is what you want to do, use the GNU Library General\n"
+"Public License instead of this License.\n"
+;
+static const char psz_thanks[] =
+"The VideoLAN team would like to thank the following donators:\n"
+"\n"
+"Julian Cain, who made a $1000 donation\n"
+"The French website MacBidouille gave €500 to help us buy a PowerMac G5\n"
+"The French magazine à vos MAC gave €500 to help us buy a PowerMac G5\n"
+"Laurent Dupuy, who made a €540 donation\n"
+"The French company Cybervia (Actech) gave €2000 to pay for webserver hosting\n"
+"Dennis Perov - Hardware donation\n"
+"\n"
+"...the following active members of our user's community:\n"
+"\n"
+"Alan Wright\n"
+"David J LaBarre \"DJ\"\n"
+"Eric Adler\n"
+"Julien Bouquillon\n"
+"\n"
+"...and code auditors and testers:\n"
+"\n"
+"David Thiel\n"
+"Philippe A. aka \"Lotesdelère\"\n"
+"Sebastien Chaumat\n"
+"\n"
+"Some VLC plugins use external libraries and makes extensive use of the\n"
+"following persons' or companies' code:\n"
+"\n"
+"FFmpeg - Copyright (c) 2000-2010 the FFmpeg developers\n"
+"liba52 - Aaron Holtzman & Michel Lespinasse, et al.\n"
+"FAAD2 - \"Code from FAAD2 is copyright (c) Nero AG, www.nero.com\"\n"
+"FAAC - Menno Bakker, Krzysztof Nikiel & The individual contributors\n"
+"libmpeg2 - Aaron Holtzman & Michel Lespinasse, et al.\n"
+"ogg, theora, vorbis - Monty & the Xiph.org Foundation\n"
+"flac - Josh Coalson et al.\n"
+"Sparkle — Andy Matuschak et al.\n"
+;
+static const char psz_authors[] =
+"In alphabetical order, the VideoLAN team would like to acknowledge\n"
+"the following contributors:\n"
+"\n"
+"Artwork\n"
+"-------\n"
+"Damien Erambert\n"
+"Daniel Dreibrodt, aka aLtgLasS\n"
+"David Weber\n"
+"Davor Orel\n"
+"Dominic Spitaler\n"
+"Eurodata Computer Club\n"
+"Geoffrey Roussel\n"
+"Joeri van Dooren\n"
+"kty0ne\n"
+"Max Rudberg\n"
+"Richard Øiestad\n"
+"Simon Damkjær Andersen\n"
+"Tom Bigelajzen\n"
+"Vincent van den Heuvel\n"
+"\n"
+"Documentation\n"
+"-------------\n"
+"Bill Eldridge\n"
+"\n"
+"Localization\n"
+"------------\n"
+"Ajith Manjula - Sinhala\n"
+"Alexander Didebulidze - Georgian\n"
+"Alexey Lugin - Ukrainian\n"
+"Alexey Salmin - Russian\n"
+"Amanpreet Singh Alam - Punjabi\n"
+"André de Barros Martins Ribeiro - Brazilian portuguese\n"
+"Andrey Brilevskiy - Russian\n"
+"Andrey Wolk - Russian\n"
+"Anh Phan - Vietnamese\n"
+"Animesh Swar - Nepalese\n"
+"Ara Bextiyar - Sorani (Kurdish)\n"
+"Ari Constâncio - Portuguese\n"
+"Arkadiusz Lipiec - Polish\n"
+"Audrey Prevost - French\n"
+"Bayarsaikhan Enkhtaivan Баярсайхан Энхтайван - Mongolian\n"
+"Bruno Queirós - Portuguese\n"
+"Bruno Vella - Italian\n"
+"Carlo Calabrò - Italian\n"
+"Cristian Secară - Romanian\n"
+"Daniel Nylander - Swedish\n"
+"David González - Spanish\n"
+"Dean Lee - Chinese\n"
+"DirektX - Hungarian\n"
+"Dominko Aždajić - Croatian\n"
+"Dylan Aïssi - French\n"
+"Eduard Babayan - Armenian\n"
+"Eirik U. Birkeland - Norwegian Nynorsk\n"
+"Éric Lassauge  -- French\n"
+"Farzaneh Sarafraz - Persian\n"
+"Fouzia Bourai - Arabic\n"
+"Frank Chao - Chinese Traditional\n"
+"Fumio Nakayama - Japanese\n"
+"Gabor Kelemen - Hungarian\n"
+"Gaëtan Rousseaux - Walloon\n"
+"Goce Manevski - Macedonian\n"
+"Gorana Milicevic - Serbian\n"
+"Haakon Meland Eriksen - Norwegian\n"
+"Han HoJoong - Korean\n"
+"H.Shalitha Vikum - Sinhala\n"
+"Ivo Ivanov - Bulgarian\n"
+"Jamil Ahmed - Bengali\n"
+"Javier Varela - Spanish\n"
+"Jean-Pierre Kuypers - French\n"
+"Joel Arvidsson - Swedish\n"
+"Jon Stødle - Norwegian Nynorsk\n"
+"Jonas Larsen - Danish\n"
+"Jouni Kähkönen - Finnish\n"
+"Kai Hermann - German\n"
+"Kang Jeong-Hee - Korean\n"
+"Kaya Zeren - Turkish\n"
+"Kypchak Kypchak - Kazakh\n"
+"Laurent Jonqueres - Occitan\n"
+"Lorena Gomes - Catalan\n"
+"Luqman Hakim - Indonesian\n"
+"Mahrazi Mohd Kamal - Malay\n"
+"Manolis Stefanis - Modern Greek\n"
+"Marián Hikaník - Slovak\n"
+"Marko Uskokovic - Serbian\n"
+"Matej Urbančič - Slovenian\n"
+"Mathias C. Berens, welcome-soft - German\n"
+"Mattias Põldaru - Estonian\n"
+"Md. Rezwan Shahid - Bengali\n"
+"Meelad Zakaria - Persian\n"
+"Michał Trzebiatowski - Polish\n"
+"Mindaugas Baranauskas - Lithuanian\n"
+"Miroslav Oujeský - Czech\n"
+"Morten Brix Pedersen - Danish\n"
+"Myckel Habets - Dutch\n"
+"Namhyung Kim - Korean\n"
+"Oleksandr Natalenko - Ukranian\n"
+"Omer Ensari - Kurmanji (Kurdish)\n"
+"Otto Kekäläinen - Finnish\n"
+"Pittayakom Saingtong - Thai\n"
+"Predrag Ljubenović - Serbian\n"
+"Roustam Ghizdatov - Russian\n"
+"Salar Khalilzadeh\" - Persian\n"
+"Сергей Дарьичев - Belarusian\n"
+"Sidney Doria - Brazilian Portuguese\n"
+"Sreejith P - Malayalam\n"
+"Tadashi Jokagi - Japanese\n"
+"Thomas De Rocker - Dutch\n"
+"Thomas Graf - gettext support, German\n"
+"Tomáš Chvátal - Czech\n"
+"Tòni Galhard - Occitan\n"
+"Valek Filippov - Russian\n"
+"Vicente Jimenez Aguilar - Spanish\n"
+"Vincenzo Reale - Italian\n"
+"Vladimir Yermolayev  - Russian\n"
+"Wei Mingzhi - Simplied Chinese\n"
+"Xènia Albà Cantero - Catalan\n"
+"Xuacu Saturio - Asturian\n"
+"Yuksel Yildirim - Turkish\n"
+"Zhang Tong - Chinese\n"
+"\n"
+"Programming\n"
+"-----------\n"
+"Adam Sampson\n"
+"Adrien Grand\n"
+"Adrien Maglo\n"
+"Alexander Gall\n"
+"Alex Antropoff\n"
+"Alexis Ballier\n"
+"Alexis de Lattre\n"
+"Alexis Guillard\n"
+"Alex Izvorski\n"
+"Amir Gouini\n"
+"Andrea Guzzo\n"
+"Andre Pang\n"
+"Andres Krapf\n"
+"André Weber\n"
+"Andrew Flintham\n"
+"Andrew Zaikin\n"
+"Andy Lindsay\n"
+"Anthony Loiseau\n"
+"Antoine Cellerier\n"
+"Antoine Lejeune\n"
+"Arai/Fujisawa Tooru\n"
+"Arkadiusz Miskiewicz\n"
+"Arnaud de Bossoreille de Ribou\n"
+"Arnaud Gomes-do-Vale\n"
+"Arnaud Schauly\n"
+"Arwed v. Merkatz\n"
+"Aurélien Nephtali\n"
+"Barak Ori\n"
+"Barry Wardell\n"
+"Basil Achermann\n"
+"Benjamin Mironer\n"
+"Benjamin Pracht\n"
+"Benoit Steiner\n"
+"Bernie Purcell\n"
+"Bill\n"
+"Bill C. Riemers\n"
+"Bob Maguire\n"
+"Boris Dorès\n"
+"Branko Kokanovic\n"
+"Brian C. Wiles\n"
+"Brian Johnson\n"
+"Brian Raymond\n"
+"Brian Robb\n"
+"Brieuc Jeunhomme\n"
+"Carsten Gottbehüt\n"
+"Carsten Haitzler\n"
+"Cédric Cocquebert\n"
+"Charles Hordis\n"
+"Chris Clepper\n"
+"Christian Henz\n"
+"Christof Baumgaertner\n"
+"Christophe Burgalat\n"
+"Christophe Massiot\n"
+"Christophe Mutricy\n"
+"Christopher Johnson\n"
+"Cian Duffy\n"
+"Clément Stenac\n"
+"Colin Delacroix\n"
+"Colin Simmonds\n"
+"Cyril Deguet\n"
+"Cyril Mathé\n"
+"Damian Ivereigh\n"
+"Damien Fouilleul\n"
+"Daniel Fischer\n"
+"Daniel Stränger\n"
+"Danko Dolch\n"
+"Danny Wood\n"
+"David Flynn\n"
+"David Kennedy\n"
+"Dennis Lou\n"
+"Dennis van Amerongen\n"
+"Derk-Jan Hartman\n"
+"Dermot McGahon\n"
+"Diego Petteno\n"
+"Dominique Leuenberger\n"
+"Douglas West\n"
+"Dugal Harris\n"
+"Dylan Yudaken\n"
+"Emmanuel Blindauer\n"
+"Emmanuel Puig\n"
+"Enrico Gueli\n"
+"Enrique Osuna\n"
+"Eren Türkay\n"
+"Eric Dudiak\n"
+"Eric Petit\n"
+"Espen Skoglund\n"
+"Ethan C. Baldridge\n"
+"Eugenio Jarosiewicz\n"
+"Felix Paul Kühne\n"
+"Filippo Carone\n"
+"Florian G. Pflug\n"
+"François Cartegnie\n"
+"François Seingier\n"
+"Frans van Veen\n"
+"Frédéric Ruget\n"
+"Gaël Hendryckx\n"
+"Geoffroy Couprie\n"
+"Georgi Chorbadzhiyski\n"
+"Gerald Hansink\n"
+"Gildas Bazin\n"
+"Gisle Vanem\n"
+"Glen Gray\n"
+"Goetz Waschk\n"
+"Greg Farrell\n"
+"Gregory Hazel\n"
+"Hang Su\n"
+"Hannes Domani\n"
+"Hans Lambermont\n"
+"Hans-Peter Jansen\n"
+"Harris Dugal\n"
+"Harry Sintonen\n"
+"Heiko Panther\n"
+"Henri Fallon\n"
+"Igor Helman\n"
+"Ilkka Ollakka\n"
+"Isaac Osunkunle\n"
+"Jan David Mol\n"
+"Jan Gerber\n"
+"Jan Van Boghout\n"
+"Jarmo Torvinen\n"
+"Jasper Alias\n"
+"Jean-Alexis Montignies\n"
+"Jean-Baptiste Kempf\n"
+"Jean-Baptiste Le Stang\n"
+"Jean-François Massol\n"
+"Jean-Marc Dressler\n"
+"Jean-Paul Saman\n"
+"Jean-Philippe André\n"
+"Jean-Philippe Grimaldi\n"
+"Jeffrey Baker\n"
+"Jeroen Massar\n"
+"Jérôme Guilbaud\n"
+"Johan Bilien\n"
+"Johannes Buchner\n"
+"Johen Michael Zorko\n"
+"Johnathan Rosser\n"
+"John Dalgliesh\n"
+"John Paul Lorenti\n"
+"Jon Lech Johansen\n"
+"Jörg\n"
+"Joseph S. Atkinson\n"
+"Joseph Tulou\n"
+"Juha Jeronen\n"
+"Julien Blache\n"
+"Julien Plissonneau Duquène\n"
+"Julien Robert\n"
+"Kai Lauterbach\n"
+"Kenneth Ostby\n"
+"Kenneth Self\n"
+"Kevin H. Patterson\n"
+"Koehler, Vitally\n"
+"Konstanty Bialkowski\n"
+"K. Staring\n"
+"Lahiru Lakmal Priyadarshana\n"
+"Laurent Aimar\n"
+"Laurent Mutricy\n"
+"Leo Spalteholz\n"
+"Loïc Minier\n"
+"Loox Thefuture\n"
+"Luca Barbato\n"
+"Ludovic Fauvet\n"
+"Lukas Durfina\n"
+"Malte Tancred\n"
+"Marc Ariberti\n"
+"Marc Nolette\n"
+"Marco Munderloh\n"
+"Marian Ďurkovič\n"
+"Mark Gritter\n"
+"Markus Kern\n"
+"Markus Kuespert\n"
+"Martin Hamrle\n"
+"Martin Kahr\n"
+"Mateus Krepsky Ludwich\n"
+"Mathias Kretschmer\n"
+"Mats Rojestal\n"
+"Matthias P. Nowak\n"
+"Matthieu Lochegnies\n"
+"Michael Hanselmann\n"
+"Michael Mondragon\n"
+"Michael Ploujnikov\n"
+"Michel Kaempf\n"
+"Michel Lanners\n"
+"Mickael Hoerdt\n"
+"Miguel Angel Cabrera\n"
+"Mike Schrag\n"
+"Mikko Hirvonen\n"
+"Mirsal Ennaime\n"
+"Moritz Bunkus\n"
+"Nilmoni Deb\n"
+"Olivier Aubert\n"
+"Olivier Houchard\n"
+"Olivier Pomel\n"
+"Olivier Teulière\n"
+"Ondrej Kuda aka Albert\n"
+"Øyvind Kolbu\n"
+"Pascal Levesque\n"
+"Patrick Horn\n"
+"Patrick McLean\n"
+"Paul Corke\n"
+"Pauline Castets\n"
+"Paul Mackerras\n"
+"Pavlov Konstantin\n"
+"Peter Surda\n"
+"Petr Vacek\n"
+"Philippe Van Hecke\n"
+"Pierre Baillet\n"
+"Pierre d'Herbemont\n"
+"Pierre-Luc Beaudoin\n"
+"Pierre Marc Dumuid\n"
+"Pierre Ynard\n"
+"Przemyslaw Fiala\n"
+"Rafaël Carré\n"
+"Régis Duchesne\n"
+"Remco Poortinga\n"
+"Rémi Denis-Courmont\n"
+"Rémi Duraffort\n"
+"Renaud Dartus\n"
+"Rene Gollent\n"
+"Richard Hosking\n"
+"Richard Shepherd\n"
+"Rob Casey\n"
+"Robson Braga Araujo\n"
+"Rocky Bernstein\n"
+"Roine Gustafsson\n"
+"Roman Bednarek\n"
+"Rudolf Cornelissen\n"
+"Samuel Hocevar\n"
+"Sašo Kiselkov\n"
+"Scott Caudle\n"
+"Sebastian Jenny\n"
+"Sebastien Zwickert (aka dilaroga)\n"
+"Shane Harper\n"
+"Sigmund Augdal Helberg\n"
+"Simon Latapie\n"
+"Søren Bøg\n"
+"Srikanth Raju\n"
+"Stefán Freyr Stefánsson\n"
+"Stephan Assmus\n"
+"Stéphane Borel\n"
+"Steve Brown\n"
+"Steve Lhomme\n"
+"Steven M. Schultz\n"
+"Steven Sheehy\n"
+"Tanguy Krotoff\n"
+"Tapio Hiltunen\n"
+"Thomas L. Wood\n"
+"Thomas Mühlgrabner\n"
+"Thomas Parmelan\n"
+"Tim 'O Callagha\n"
+"Tim Schuerewegen\n"
+"Tong Ka Man\n"
+"Tony Castley\n"
+"Torsten Spindler\n"
+"Udo Richter\n"
+"Vincent Dimar\n"
+"Vincent Penne\n"
+"Vincent Penquerc'h\n"
+"Vincent Seguin\n"
+"Vitalijus Slavinskas\n"
+"Vitaly V. Bursov\n"
+"Vladimir Chernyshov\n"
+"Wade Majors\n"
+"Wallace Wadge\n"
+"Wang Bo\n"
+"Watanabe Go\n"
+"William Hawkins\n"
+"Xavier Maillard\n"
+"Xavier Marchesini\n"
+"Yannick Bréhon\n"
+"Ye zhang\n"
+"Yuehua Zhao\n"
+"Yuval Tze\n"
+"Yves Duret\n"
+;
diff -Nurp vlc-a/include/vlc_threads.h vlc-b/include/vlc_threads.h
--- vlc-a/include/vlc_threads.h	2011-07-18 20:34:11.543213384 +0800
+++ vlc-b/include/vlc_threads.h	2011-07-10 01:53:48.943261854 +0800
@@ -110,7 +110,19 @@ typedef pthread_mutex_t vlc_mutex_t;
 #define VLC_STATIC_MUTEX PTHREAD_MUTEX_INITIALIZER
 typedef pthread_cond_t  vlc_cond_t;
 #define VLC_STATIC_COND  PTHREAD_COND_INITIALIZER
+#ifndef ANDROID
 typedef pthread_rwlock_t vlc_rwlock_t;
+#else
+typedef struct
+{
+    vlc_mutex_t   mutex;
+    vlc_cond_t    read_wait;
+    vlc_cond_t    write_wait;
+    unsigned long readers;
+    unsigned long writers;
+    unsigned long writer;
+} vlc_rwlock_t;
+#endif
 typedef pthread_key_t   vlc_threadvar_t;
 typedef struct vlc_timer *vlc_timer_t;
 
diff -Nurp vlc-a/modules/access/Android.mk vlc-b/modules/access/Android.mk
--- vlc-a/modules/access/Android.mk	1970-01-01 08:00:00.000000000 +0800
+++ vlc-b/modules/access/Android.mk	2011-07-18 17:25:56.887992200 +0800
@@ -0,0 +1,111 @@
+
+LOCAL_PATH := $(call my-dir)
+
+include $(CLEAR_VARS)
+
+LOCAL_ARM_MODE := arm
+ifeq ($(BUILD_WITH_NEON),1)
+LOCAL_ARM_NEON := true
+endif
+
+LOCAL_MODULE := access_demux_avformat_plugin
+
+LOCAL_CFLAGS += \
+    -std=c99 \
+    -DHAVE_CONFIG_H \
+    -DMODULE_STRING=\"access_demux_avformat\" \
+    -DMODULE_NAME=access_demux_avformat
+
+LOCAL_C_INCLUDES += \
+    $(VLCROOT) \
+    $(VLCROOT)/include \
+    $(VLCROOT)/src \
+    $(EXTROOT)/ffmpeg
+
+LOCAL_SRC_FILES := \
+    avformat.c
+
+include $(BUILD_STATIC_LIBRARY)
+
+include $(CLEAR_VARS)
+
+LOCAL_ARM_MODE := arm
+ifeq ($(BUILD_WITH_NEON),1)
+LOCAL_ARM_NEON := true
+endif
+
+LOCAL_MODULE := access_avio_plugin
+
+LOCAL_CFLAGS += \
+    -std=c99 \
+    -DHAVE_CONFIG_H \
+    -DMODULE_STRING=\"access_avio\" \
+    -DMODULE_NAME=access_avio
+
+LOCAL_C_INCLUDES += \
+    $(VLCROOT) \
+    $(VLCROOT)/include \
+    $(VLCROOT)/src \
+    $(EXTROOT)/ffmpeg
+
+LOCAL_SRC_FILES := \
+    avio.c
+
+include $(BUILD_STATIC_LIBRARY)
+
+include $(CLEAR_VARS)
+
+LOCAL_ARM_MODE := arm
+ifeq ($(BUILD_WITH_NEON),1)
+LOCAL_ARM_NEON := true
+endif
+
+LOCAL_MODULE := filesystem_plugin
+
+LOCAL_CFLAGS += \
+    -std=c99 \
+    -DHAVE_CONFIG_H \
+    -DMODULE_STRING=\"filesystem\" \
+    -DMODULE_NAME=filesystem
+
+LOCAL_C_INCLUDES += \
+    $(VLCROOT) \
+    $(VLCROOT)/include \
+    $(VLCROOT)/src
+
+LOCAL_SRC_FILES := \
+    directory.c \
+    file.c \
+    fs.c
+
+include $(BUILD_STATIC_LIBRARY)
+
+include $(CLEAR_VARS)
+
+LOCAL_ARM_MODE := arm
+ifeq ($(BUILD_WITH_NEON),1)
+LOCAL_ARM_NEON := true
+endif
+
+LOCAL_MODULE := access_http_plugin
+
+LOCAL_CFLAGS += \
+    -std=c99 \
+    -DHAVE_CONFIG_H \
+    -DMODULE_STRING=\"access_http\" \
+    -DMODULE_NAME=access_http
+
+LOCAL_C_INCLUDES += \
+    $(VLCROOT) \
+    $(VLCROOT)/include \
+    $(VLCROOT)/src
+
+LOCAL_SRC_FILES := \
+    http.c
+
+include $(BUILD_STATIC_LIBRARY)
+
+include $(CLEAR_VARS)
+
+include $(call all-makefiles-under,$(LOCAL_PATH))
+
diff -Nurp vlc-a/modules/access/avformat.c vlc-b/modules/access/avformat.c
--- vlc-a/modules/access/avformat.c	1970-01-01 08:00:00.000000000 +0800
+++ vlc-b/modules/access/avformat.c	2011-07-18 17:26:21.790724766 +0800
@@ -0,0 +1,832 @@
+/*****************************************************************************
+ * demux.c: demuxer using ffmpeg (libavformat).
+ *****************************************************************************
+ * Copyright (C) 2004-2009 the VideoLAN team
+ * $Id: e20d2495f023000e90b10fef2ee3ee2b35755901 $
+ *
+ * Authors: Laurent Aimar <fenrir@via.ecp.fr>
+ *          Gildas Bazin <gbazin@videolan.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+/*****************************************************************************
+ * Preamble
+ *****************************************************************************/
+
+#ifdef HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include <vlc_common.h>
+#include <vlc_demux.h>
+#include <vlc_stream.h>
+#include <vlc_meta.h>
+#include <vlc_input.h>
+#include <vlc_charset.h>
+#include <vlc_avcodec.h>
+#include <vlc_plugin.h>
+
+#include <libavformat/avformat.h>
+
+#include "../codec/avcodec/avcodec.h"
+#include "../codec/avcodec/chroma.h"
+#include "../demux/avformat/avformat.h"
+#include "../demux/xiph.h"
+#include "../demux/vobsub.h"
+
+//#define AVFORMAT_DEBUG 1
+
+/* Version checking */
+#if defined(HAVE_FFMPEG_AVFORMAT_H) || defined(HAVE_LIBAVFORMAT_AVFORMAT_H)
+
+#if (LIBAVCODEC_VERSION_INT >= ((51<<16)+(50<<8)+0) )
+#   define HAVE_FFMPEG_CODEC_ATTACHMENT 1
+#endif
+
+vlc_module_begin ()
+#endif /* MERGE_FFMPEG */
+    add_shortcut( "ffmpeg", "avformat" )
+    set_category( CAT_INPUT )
+    set_subcategory( SUBCAT_INPUT_ACCESS )
+    set_description( N_("FFmpeg access demuxer" ) )
+    set_shortname( N_("Avformat") )
+    set_capability( "access_demux", 0 )
+    set_callbacks( OpenDemux, CloseDemux )
+#ifndef MERGE_FFMPEG
+vlc_module_end ()
+#endif
+
+/*****************************************************************************
+ * demux_sys_t: demux descriptor
+ *****************************************************************************/
+struct demux_sys_t
+{
+    AVInputFormat  *fmt;
+    AVFormatContext *ic;
+
+    int             i_tk;
+    es_out_id_t     **tk;
+
+    int64_t     i_pcr;
+    int64_t     i_pcr_inc;
+    int         i_pcr_tk;
+
+    unsigned    i_ssa_order;
+
+    int                i_attachments;
+    input_attachment_t **attachments;
+
+    /* Only one title with seekpoints possible atm. */
+    input_title_t *p_title;
+};
+
+/*****************************************************************************
+ * Local prototypes
+ *****************************************************************************/
+static int Demux  ( demux_t *p_demux );
+static int Control( demux_t *p_demux, int i_query, va_list args );
+
+static block_t *BuildSsaFrame( const AVPacket *p_pkt, unsigned i_order );
+static void UpdateSeekPoint( demux_t *p_demux, int64_t i_time );
+
+/*****************************************************************************
+ * Open
+ *****************************************************************************/
+int OpenDemux( vlc_object_t *p_this )
+{
+    demux_t       *p_demux = (demux_t*)p_this;
+    demux_sys_t   *p_sys;
+    AVFormatContext *ic;
+    AVInputFormat *fmt;
+    unsigned int  i;
+    int64_t       i_start_time = -1;
+    bool          b_can_seek;
+    char         *psz_url;
+
+    if( p_demux->psz_file )
+        psz_url = strdup( p_demux->psz_file );
+    else
+    {
+        if ( !strcmp( p_demux->psz_access, "avformat"))
+            psz_url = strdup ( p_demux->psz_location );
+        else
+            if (asprintf( &psz_url, "%s://%s", p_demux->psz_access, p_demux->psz_location ) < 0 )
+                return VLC_ENOMEM;
+    }
+
+    if (psz_url == NULL)
+        return VLC_ENOMEM;
+
+    msg_Dbg( p_demux, "trying url: %s", psz_url);
+
+    vlc_avcodec_lock();
+    av_register_all(); /* Can be called several times */
+    vlc_avcodec_unlock();
+
+    ic = avformat_alloc_context();
+    if ( !ic )
+    {
+        free( psz_url );
+        return VLC_ENOMEM;
+    }
+
+    int err = av_open_input_file( &ic, psz_url, NULL, 0, NULL );
+    if ( err < 0 )
+    {
+        msg_Dbg ( p_demux, "av_open_input_file failed to open %s", psz_url );
+        free( ic );
+        free( psz_url );
+        return VLC_EGENERIC;
+    }
+
+    fmt = ic->iformat;
+
+    /* Don't try to handle MPEG unless forced */
+    if( !p_demux->b_force &&
+        ( !strcmp( fmt->name, "mpeg" ) ||
+          !strcmp( fmt->name, "vcd" ) ||
+          !strcmp( fmt->name, "vob" ) ||
+          !strcmp( fmt->name, "mpegts" ) ||
+          /* libavformat's redirector won't work */
+          !strcmp( fmt->name, "redir" ) ||
+          !strcmp( fmt->name, "sdp" ) ) )
+    {
+        avformat_free_context( ic );
+        free( psz_url );
+        return VLC_EGENERIC;
+    }
+
+    /* Don't trigger false alarms on bin files */
+    if( !p_demux->b_force && !strcmp( fmt->name, "psxstr" ) )
+    {
+        int i_len;
+
+        if( !p_demux->psz_file )
+        {
+            avformat_free_context( ic );
+            free( psz_url );
+            return VLC_EGENERIC;
+        }
+
+        i_len = strlen( p_demux->psz_file );
+        if( i_len < 4 )
+        {
+            avformat_free_context( ic );
+            free( psz_url );
+            return VLC_EGENERIC;
+        }
+
+        if( strcasecmp( &p_demux->psz_file[i_len - 4], ".str" ) &&
+            strcasecmp( &p_demux->psz_file[i_len - 4], ".xai" ) &&
+            strcasecmp( &p_demux->psz_file[i_len - 3], ".xa" ) )
+        {
+            avformat_free_context( ic );
+            free( psz_url );
+            return VLC_EGENERIC;
+        }
+    }
+
+    msg_Dbg( p_demux, "detected format: %s", fmt->name );
+
+    free( psz_url );
+    psz_url = NULL;
+
+    /* Fill p_demux fields */
+    p_demux->pf_demux = Demux;
+    p_demux->pf_control = Control;
+    p_demux->p_sys = p_sys = malloc( sizeof( demux_sys_t ) );
+    p_sys->ic = ic;
+    p_sys->fmt = fmt;
+    p_sys->i_tk = 0;
+    p_sys->tk = NULL;
+    p_sys->i_pcr_tk = -1;
+    p_sys->i_pcr = -1;
+    p_sys->i_ssa_order = 0;
+    TAB_INIT( p_sys->i_attachments, p_sys->attachments);
+    p_sys->p_title = NULL;
+
+    vlc_avcodec_lock(); /* avformat calls avcodec behind our back!!! */
+    if( av_find_stream_info( p_sys->ic ) < 0 )
+    {
+        msg_Warn( p_demux, "av_find_stream_info failed" );
+    }
+    vlc_avcodec_unlock();
+
+    for( i = 0; i < p_sys->ic->nb_streams; i++ )
+    {
+        AVStream *s = p_sys->ic->streams[i];
+        AVCodecContext *cc = s->codec;
+
+        es_out_id_t  *es;
+        es_format_t  fmt;
+        vlc_fourcc_t fcc;
+        const char *psz_type = "unknown";
+
+        if( !GetVlcFourcc( cc->codec_id, NULL, &fcc, NULL ) )
+            fcc = VLC_FOURCC( 'u', 'n', 'd', 'f' );
+
+        switch( cc->codec_type )
+        {
+        case AVMEDIA_TYPE_AUDIO:
+            es_format_Init( &fmt, AUDIO_ES, fcc );
+            fmt.i_bitrate = cc->bit_rate;
+            fmt.audio.i_channels = cc->channels;
+            fmt.audio.i_rate = cc->sample_rate;
+            fmt.audio.i_bitspersample = cc->bits_per_coded_sample;
+            fmt.audio.i_blockalign = cc->block_align;
+            psz_type = "audio";
+            break;
+
+        case AVMEDIA_TYPE_VIDEO:
+            es_format_Init( &fmt, VIDEO_ES, fcc );
+
+            /* Special case for raw video data */
+            if( cc->codec_id == CODEC_ID_RAWVIDEO )
+            {
+                msg_Dbg( p_demux, "raw video, pixel format: %i", cc->pix_fmt );
+                if( GetVlcChroma( &fmt.video, cc->pix_fmt ) != VLC_SUCCESS)
+                {
+                    msg_Err( p_demux, "was unable to find a FourCC match for raw video" );
+                }
+                else
+                    fmt.i_codec = fmt.video.i_chroma;
+            }
+            /* We need this for the h264 packetizer */
+            else if( cc->codec_id == CODEC_ID_H264 && ( !strcmp( p_sys->fmt->name, "flv" ) ||
+                !strcmp( p_sys->fmt->name, "matroska" ) || !strcmp( p_sys->fmt->name, "mp4" ) ) )
+                fmt.i_original_fourcc = VLC_FOURCC( 'a', 'v', 'c', '1' );
+
+            fmt.video.i_width = cc->width;
+            fmt.video.i_height = cc->height;
+            if( cc->palctrl )
+            {
+                fmt.video.p_palette = malloc( sizeof(video_palette_t) );
+                *fmt.video.p_palette = *(video_palette_t *)cc->palctrl;
+            }
+            psz_type = "video";
+            fmt.video.i_frame_rate = cc->time_base.den;
+            fmt.video.i_frame_rate_base = cc->time_base.num * __MAX( cc->ticks_per_frame, 1 );
+            break;
+
+        case AVMEDIA_TYPE_SUBTITLE:
+            es_format_Init( &fmt, SPU_ES, fcc );
+            if( strncmp( p_sys->ic->iformat->name, "matroska", 8 ) == 0 &&
+                cc->codec_id == CODEC_ID_DVD_SUBTITLE &&
+                cc->extradata != NULL &&
+                cc->extradata_size > 0 )
+            {
+                char *psz_start;
+                char *psz_buf = malloc( cc->extradata_size + 1);
+                if( psz_buf != NULL )
+                {
+                    memcpy( psz_buf, cc->extradata , cc->extradata_size );
+                    psz_buf[cc->extradata_size] = '\0';
+
+                    psz_start = strstr( psz_buf, "size:" );
+                    if( psz_start &&
+                        vobsub_size_parse( psz_start,
+                                           &fmt.subs.spu.i_original_frame_width,
+                                           &fmt.subs.spu.i_original_frame_height ) == VLC_SUCCESS )
+                    {
+                        msg_Dbg( p_demux, "original frame size: %dx%d",
+                                 fmt.subs.spu.i_original_frame_width,
+                                 fmt.subs.spu.i_original_frame_height );
+                    }
+                    else
+                    {
+                        msg_Warn( p_demux, "reading original frame size failed" );
+                    }
+
+                    psz_start = strstr( psz_buf, "palette:" );
+                    if( psz_start &&
+                        vobsub_palette_parse( psz_start, &fmt.subs.spu.palette[1] ) == VLC_SUCCESS )
+                    {
+                        fmt.subs.spu.palette[0] =  0xBeef;
+                        msg_Dbg( p_demux, "vobsub palette read" );
+                    }
+                    else
+                    {
+                        msg_Warn( p_demux, "reading original palette failed" );
+                    }
+                    free( psz_buf );
+                }
+            }
+
+            psz_type = "subtitle";
+            break;
+
+        default:
+            es_format_Init( &fmt, UNKNOWN_ES, 0 );
+#ifdef HAVE_FFMPEG_CODEC_ATTACHMENT
+            if( cc->codec_type == AVMEDIA_TYPE_ATTACHMENT )
+            {
+                input_attachment_t *p_attachment;
+
+                psz_type = "attachment";
+                if( cc->codec_id == CODEC_ID_TTF )
+                {
+                    AVMetadataTag *filename = av_metadata_get( s->metadata, "filename", NULL, 0 );
+                    if( filename && filename->value )
+                    {
+                        p_attachment = vlc_input_attachment_New(
+                                filename->value, "application/x-truetype-font",
+                                NULL, cc->extradata, (int)cc->extradata_size );
+                        TAB_APPEND( p_sys->i_attachments, p_sys->attachments,
+                                p_attachment );
+                    }
+                }
+                else msg_Warn( p_demux, "unsupported attachment type (%u) in ffmpeg demux", cc->codec_id );
+            }
+            break;
+#endif
+
+            if( cc->codec_type == AVMEDIA_TYPE_DATA )
+                psz_type = "data";
+
+            msg_Warn( p_demux, "unsupported track type in ffmpeg demux" );
+            break;
+        }
+
+        AVMetadataTag *language = av_metadata_get( s->metadata, "language", NULL, 0 );
+        if ( language && language->value )
+            fmt.psz_language = strdup( language->value );
+
+        if( s->disposition & AV_DISPOSITION_DEFAULT )
+            fmt.i_priority = 1000;
+
+#ifdef HAVE_FFMPEG_CODEC_ATTACHMENT
+        if( cc->codec_type != AVMEDIA_TYPE_ATTACHMENT )
+#endif
+        {
+            const bool    b_ogg = !strcmp( p_sys->fmt->name, "ogg" );
+            const uint8_t *p_extra = cc->extradata;
+            unsigned      i_extra  = cc->extradata_size;
+
+            if( cc->codec_id == CODEC_ID_THEORA && b_ogg )
+            {
+                unsigned pi_size[3];
+                const void *pp_data[3];
+                unsigned i_count;
+                for( i_count = 0; i_count < 3; i_count++ )
+                {
+                    if( i_extra < 2 )
+                        break;
+                    pi_size[i_count] = GetWBE( p_extra );
+                    pp_data[i_count] = &p_extra[2];
+                    if( i_extra < pi_size[i_count] + 2 )
+                        break;
+
+                    p_extra += 2 + pi_size[i_count];
+                    i_extra -= 2 + pi_size[i_count];
+                }
+                if( i_count > 0 && xiph_PackHeaders( &fmt.i_extra, &fmt.p_extra,
+                                                     pi_size, pp_data, i_count ) )
+                {
+                    fmt.i_extra = 0;
+                    fmt.p_extra = NULL;
+                }
+            }
+            else if( cc->codec_id == CODEC_ID_SPEEX && b_ogg )
+            {
+                const uint8_t p_dummy_comment[] = {
+                    0, 0, 0, 0,
+                    0, 0, 0, 0,
+                };
+                unsigned pi_size[2];
+                const void *pp_data[2];
+
+                pi_size[0] = i_extra;
+                pp_data[0] = p_extra;
+
+                pi_size[1] = sizeof(p_dummy_comment);
+                pp_data[1] = p_dummy_comment;
+
+                if( pi_size[0] > 0 && xiph_PackHeaders( &fmt.i_extra, &fmt.p_extra,
+                                                        pi_size, pp_data, 2 ) )
+                {
+                    fmt.i_extra = 0;
+                    fmt.p_extra = NULL;
+                }
+            }
+            else if( cc->extradata_size > 0 )
+            {
+                fmt.p_extra = malloc( i_extra );
+                if( fmt.p_extra )
+                {
+                    fmt.i_extra = i_extra;
+                    memcpy( fmt.p_extra, p_extra, i_extra );
+                }
+            }
+            es = es_out_Add( p_demux->out, &fmt );
+            if( s->disposition & AV_DISPOSITION_DEFAULT )
+                es_out_Control( p_demux->out, ES_OUT_SET_ES_DEFAULT, es );
+            es_format_Clean( &fmt );
+
+            msg_Dbg( p_demux, "adding es: %s codec = %4.4s",
+                     psz_type, (char*)&fcc );
+            TAB_APPEND( p_sys->i_tk, p_sys->tk, es );
+        }
+    }
+    if( p_sys->ic->start_time != (int64_t)AV_NOPTS_VALUE )
+        i_start_time = p_sys->ic->start_time * 1000000 / AV_TIME_BASE;
+
+    msg_Dbg( p_demux, "AVFormat supported stream" );
+    msg_Dbg( p_demux, "    - format = %s (%s)",
+             p_sys->fmt->name, p_sys->fmt->long_name );
+    msg_Dbg( p_demux, "    - start time = %"PRId64, i_start_time );
+    msg_Dbg( p_demux, "    - duration = %"PRId64,
+             ( p_sys->ic->duration != (int64_t)AV_NOPTS_VALUE ) ?
+             p_sys->ic->duration * 1000000 / AV_TIME_BASE : -1 );
+
+    if( p_sys->ic->nb_chapters > 0 )
+        p_sys->p_title = vlc_input_title_New();
+    for( i = 0; i < p_sys->ic->nb_chapters; i++ )
+    {
+        seekpoint_t *s = vlc_seekpoint_New();
+
+        AVMetadataTag *title = av_metadata_get( p_sys->ic->metadata, "title", NULL, 0);
+        if( title && title->value )
+        {
+            s->psz_name = strdup( title->value );
+            EnsureUTF8( s->psz_name );
+            msg_Dbg( p_demux, "    - chapter %d: %s", i, s->psz_name );
+        }
+        s->i_time_offset = p_sys->ic->chapters[i]->start * 1000000 *
+            p_sys->ic->chapters[i]->time_base.num /
+            p_sys->ic->chapters[i]->time_base.den -
+            (i_start_time != -1 ? i_start_time : 0 );
+        TAB_APPEND( p_sys->p_title->i_seekpoint, p_sys->p_title->seekpoint, s );
+    }
+
+    return VLC_SUCCESS;
+}
+
+/*****************************************************************************
+ * Close
+ *****************************************************************************/
+void CloseDemux( vlc_object_t *p_this )
+{
+    demux_t     *p_demux = (demux_t*)p_this;
+    demux_sys_t *p_sys = p_demux->p_sys;
+
+    FREENULL( p_sys->tk );
+
+    if( p_sys->ic ) av_close_input_file( p_sys->ic );
+
+    for( int i = 0; i < p_sys->i_attachments; i++ )
+        free( p_sys->attachments[i] );
+    TAB_CLEAN( p_sys->i_attachments, p_sys->attachments);
+
+    if( p_sys->p_title )
+        vlc_input_title_Delete( p_sys->p_title );
+
+    free( p_sys );
+}
+
+/*****************************************************************************
+ * Demux:
+ *****************************************************************************/
+static int Demux( demux_t *p_demux )
+{
+    demux_sys_t *p_sys = p_demux->p_sys;
+    AVPacket    pkt;
+    block_t     *p_frame;
+    int64_t     i_start_time;
+
+    /* Read a frame */
+    if( av_read_frame( p_sys->ic, &pkt ) )
+    {
+        return 0;
+    }
+    if( pkt.stream_index < 0 || pkt.stream_index >= p_sys->i_tk )
+    {
+        av_free_packet( &pkt );
+        return 1;
+    }
+    const AVStream *p_stream = p_sys->ic->streams[pkt.stream_index];
+    if( p_stream->time_base.den <= 0 )
+    {
+        msg_Warn( p_demux, "Invalid time base for the stream %d", pkt.stream_index );
+        av_free_packet( &pkt );
+        return 1;
+    }
+    if( p_stream->codec->codec_id == CODEC_ID_SSA )
+    {
+        p_frame = BuildSsaFrame( &pkt, p_sys->i_ssa_order++ );
+        if( !p_frame )
+        {
+            av_free_packet( &pkt );
+            return 1;
+        }
+    }
+    else
+    {
+        if( ( p_frame = block_New( p_demux, pkt.size ) ) == NULL )
+        {
+            av_free_packet( &pkt );
+            return 0;
+        }
+        memcpy( p_frame->p_buffer, pkt.data, pkt.size );
+    }
+
+    if( pkt.flags & AV_PKT_FLAG_KEY )
+        p_frame->i_flags |= BLOCK_FLAG_TYPE_I;
+
+    i_start_time = ( p_sys->ic->start_time != (int64_t)AV_NOPTS_VALUE ) ?
+        ( p_sys->ic->start_time * 1000000 / AV_TIME_BASE )  : 0;
+
+    p_frame->i_dts = ( pkt.dts == (int64_t)AV_NOPTS_VALUE ) ?
+        VLC_TS_INVALID : (pkt.dts) * 1000000 *
+        p_stream->time_base.num /
+        p_stream->time_base.den - i_start_time + VLC_TS_0;
+    p_frame->i_pts = ( pkt.pts == (int64_t)AV_NOPTS_VALUE ) ?
+        VLC_TS_INVALID : (pkt.pts) * 1000000 *
+        p_stream->time_base.num /
+        p_stream->time_base.den - i_start_time + VLC_TS_0;
+    if( pkt.duration > 0 && p_frame->i_length <= 0 )
+        p_frame->i_length = pkt.duration * 1000000 *
+            p_stream->time_base.num /
+            p_stream->time_base.den;
+
+    if( pkt.dts != AV_NOPTS_VALUE && pkt.dts == pkt.pts &&
+        p_stream->codec->codec_type == AVMEDIA_TYPE_VIDEO )
+    {
+        /* Add here notoriously bugged file formats/samples regarding PTS */
+        if( !strcmp( p_sys->fmt->name, "flv" ) )
+            p_frame->i_pts = VLC_TS_INVALID;
+    }
+#ifdef AVFORMAT_DEBUG
+    msg_Dbg( p_demux, "tk[%d] dts=%"PRId64" pts=%"PRId64,
+             pkt.stream_index, p_frame->i_dts, p_frame->i_pts );
+#endif
+
+    if( p_frame->i_dts > VLC_TS_INVALID  &&
+        ( pkt.stream_index == p_sys->i_pcr_tk || p_sys->i_pcr_tk < 0 ) )
+    {
+        p_sys->i_pcr_tk = pkt.stream_index;
+        p_sys->i_pcr = p_frame->i_dts;
+
+        es_out_Control( p_demux->out, ES_OUT_SET_PCR, (int64_t)p_sys->i_pcr );
+    }
+
+    es_out_Send( p_demux->out, p_sys->tk[pkt.stream_index], p_frame );
+
+    UpdateSeekPoint( p_demux, p_sys->i_pcr);
+    av_free_packet( &pkt );
+    return 1;
+}
+
+static void UpdateSeekPoint( demux_t *p_demux, int64_t i_time )
+{
+    demux_sys_t *p_sys = p_demux->p_sys;
+    int i;
+
+    if( !p_sys->p_title )
+        return;
+
+    for( i = 0; i < p_sys->p_title->i_seekpoint; i++ )
+    {
+        if( i_time < p_sys->p_title->seekpoint[i]->i_time_offset )
+            break;
+    }
+    i--;
+
+    if( i != p_demux->info.i_seekpoint && i >= 0 )
+    {
+        p_demux->info.i_seekpoint = i;
+        p_demux->info.i_update |= INPUT_UPDATE_SEEKPOINT;
+    }
+}
+
+static block_t *BuildSsaFrame( const AVPacket *p_pkt, unsigned i_order )
+{
+    if( p_pkt->size <= 0 )
+        return NULL;
+
+    char buffer[256];
+    const size_t i_buffer_size = __MIN( (int)sizeof(buffer) - 1, p_pkt->size );
+    memcpy( buffer, p_pkt->data, i_buffer_size );
+    buffer[i_buffer_size] = '\0';
+
+    /* */
+    int i_layer;
+    int h0, m0, s0, c0;
+    int h1, m1, s1, c1;
+    int i_position = 0;
+    if( sscanf( buffer, "Dialogue: %d,%d:%d:%d.%d,%d:%d:%d.%d,%n", &i_layer,
+                &h0, &m0, &s0, &c0, &h1, &m1, &s1, &c1, &i_position ) < 9 )
+        return NULL;
+    if( i_position <= 0 || (unsigned)i_position >= i_buffer_size )
+        return NULL;
+
+    char *p;
+    if( asprintf( &p, "%u,%d,%.*s", i_order, i_layer, p_pkt->size - i_position, p_pkt->data + i_position ) < 0 )
+        return NULL;
+
+    block_t *p_frame = block_heap_Alloc( p, p, strlen(p) + 1 );
+    if( p_frame )
+        p_frame->i_length = CLOCK_FREQ * ((h1-h0) * 3600 +
+                                          (m1-m0) * 60 +
+                                          (s1-s0) * 1) +
+                            CLOCK_FREQ * (c1-c0) / 100;
+    return p_frame;
+}
+
+/*****************************************************************************
+ * Control:
+ *****************************************************************************/
+static int Control( demux_t *p_demux, int i_query, va_list args )
+{
+    demux_sys_t *p_sys = p_demux->p_sys;
+    double f, *pf;
+    int64_t i64, *pi64;
+
+    switch( i_query )
+    {
+        case DEMUX_GET_POSITION:
+            pf = (double*) va_arg( args, double* ); *pf = 0.0;
+            i64 = stream_Size( p_demux->s );
+            if( i64 > 0 )
+            {
+                double current = stream_Tell( p_demux->s );
+                *pf = current / (double)i64;
+            }
+
+            if( (p_sys->ic->duration != (int64_t)AV_NOPTS_VALUE) && (p_sys->i_pcr > 0) )
+            {
+                *pf = (double)p_sys->i_pcr / (double)p_sys->ic->duration;
+            }
+
+            return VLC_SUCCESS;
+
+        case DEMUX_SET_POSITION:
+            f = (double) va_arg( args, double );
+            if( p_sys->i_pcr > 0 )
+            {
+                i64 = p_sys->ic->duration * f;
+                if( p_sys->ic->start_time != (int64_t)AV_NOPTS_VALUE )
+                    i64 += p_sys->ic->start_time;
+
+                msg_Warn( p_demux, "DEMUX_SET_POSITION: %"PRId64, i64 );
+
+                /* If we have a duration, we prefer to seek by time
+                   but if we don't, or if the seek fails, try BYTE seeking */
+                if( p_sys->ic->duration == (int64_t)AV_NOPTS_VALUE ||
+                    (av_seek_frame( p_sys->ic, -1, i64, 0 ) < 0) )
+                {
+                    int64_t i_size = stream_Size( p_demux->s );
+                    i64 = (i_size * f);
+
+                    msg_Warn( p_demux, "DEMUX_SET_BYTE_POSITION: %"PRId64, i64 );
+                    if( av_seek_frame( p_sys->ic, -1, i64, AVSEEK_FLAG_BYTE ) < 0 )
+                        return VLC_EGENERIC;
+                }
+                else
+                {
+                    UpdateSeekPoint( p_demux, i64 );
+                }
+                p_sys->i_pcr = -1; /* Invalidate time display */
+            }
+            return VLC_SUCCESS;
+
+        case DEMUX_GET_LENGTH:
+            pi64 = (int64_t*)va_arg( args, int64_t * );
+            if( p_sys->ic->duration != (int64_t)AV_NOPTS_VALUE )
+                *pi64 = p_sys->ic->duration * 1000000 / AV_TIME_BASE;
+            else
+                *pi64 = 0;
+            return VLC_SUCCESS;
+
+        case DEMUX_GET_TIME:
+            pi64 = (int64_t*)va_arg( args, int64_t * );
+            *pi64 = p_sys->i_pcr;
+            return VLC_SUCCESS;
+
+        case DEMUX_SET_TIME:
+            i64 = (int64_t)va_arg( args, int64_t );
+            i64 = i64 *AV_TIME_BASE / 1000000;
+            if( p_sys->ic->start_time != (int64_t)AV_NOPTS_VALUE )
+                i64 += p_sys->ic->start_time;
+
+            msg_Warn( p_demux, "DEMUX_SET_TIME: %"PRId64, i64 );
+
+            if( av_seek_frame( p_sys->ic, -1, i64, 0 ) < 0 )
+            {
+                return VLC_EGENERIC;
+            }
+            p_sys->i_pcr = -1; /* Invalidate time display */
+            UpdateSeekPoint( p_demux, i64 );
+            return VLC_SUCCESS;
+
+        case DEMUX_HAS_UNSUPPORTED_META:
+        {
+            bool *pb_bool = (bool*)va_arg( args, bool* );
+            *pb_bool = true;
+            return VLC_SUCCESS;
+        }
+
+
+        case DEMUX_GET_META:
+        {
+            vlc_meta_t *p_meta = (vlc_meta_t*)va_arg( args, vlc_meta_t* );
+
+            AVMetadataTag *title = av_metadata_get( p_sys->ic->metadata, "language", NULL, 0 );
+            AVMetadataTag *artist = av_metadata_get( p_sys->ic->metadata, "artist", NULL, 0 );
+            AVMetadataTag *copyright = av_metadata_get( p_sys->ic->metadata, "copyright", NULL, 0 );
+            AVMetadataTag *comment = av_metadata_get( p_sys->ic->metadata, "comment", NULL, 0 );
+            AVMetadataTag *genre = av_metadata_get( p_sys->ic->metadata, "genre", NULL, 0 );
+
+            if( title && title->value )
+                vlc_meta_SetTitle( p_meta, title->value );
+            if( artist && artist->value )
+                vlc_meta_SetArtist( p_meta, artist->value );
+            if( copyright && copyright->value )
+                vlc_meta_SetCopyright( p_meta, copyright->value );
+            if( comment && comment->value )
+                vlc_meta_SetDescription( p_meta, comment->value );
+            if( genre && genre->value )
+                vlc_meta_SetGenre( p_meta, genre->value );
+            return VLC_SUCCESS;
+        }
+
+        case DEMUX_GET_ATTACHMENTS:
+        {
+            input_attachment_t ***ppp_attach =
+                (input_attachment_t***)va_arg( args, input_attachment_t*** );
+            int *pi_int = (int*)va_arg( args, int * );
+            int i;
+
+            if( p_sys->i_attachments <= 0 )
+                return VLC_EGENERIC;
+
+            *pi_int = p_sys->i_attachments;;
+            *ppp_attach = malloc( sizeof(input_attachment_t**) * p_sys->i_attachments );
+            for( i = 0; i < p_sys->i_attachments; i++ )
+                (*ppp_attach)[i] = vlc_input_attachment_Duplicate( p_sys->attachments[i] );
+            return VLC_SUCCESS;
+        }
+
+        case DEMUX_GET_TITLE_INFO:
+        {
+            input_title_t ***ppp_title = (input_title_t***)va_arg( args, input_title_t*** );
+            int *pi_int    = (int*)va_arg( args, int* );
+            int *pi_title_offset = (int*)va_arg( args, int* );
+            int *pi_seekpoint_offset = (int*)va_arg( args, int* );
+
+            if( !p_sys->p_title )
+                return VLC_EGENERIC;
+
+            *pi_int = 1;
+            *ppp_title = malloc( sizeof( input_title_t**) );
+            (*ppp_title)[0] = vlc_input_title_Duplicate( p_sys->p_title );
+            *pi_title_offset = 0;
+            *pi_seekpoint_offset = 0;
+            return VLC_SUCCESS;
+        }
+        case DEMUX_SET_TITLE:
+        {
+            const int i_title = (int)va_arg( args, int );
+            if( !p_sys->p_title || i_title != 0 )
+                return VLC_EGENERIC;
+            return VLC_SUCCESS;
+        }
+        case DEMUX_SET_SEEKPOINT:
+        {
+            const int i_seekpoint = (int)va_arg( args, int );
+            if( !p_sys->p_title )
+                return VLC_EGENERIC;
+
+            i64 = p_sys->p_title->seekpoint[i_seekpoint]->i_time_offset *AV_TIME_BASE / 1000000;
+            if( p_sys->ic->start_time != (int64_t)AV_NOPTS_VALUE )
+                i64 += p_sys->ic->start_time;
+
+            msg_Warn( p_demux, "DEMUX_SET_TIME: %"PRId64, i64 );
+
+            if( av_seek_frame( p_sys->ic, -1, i64, 0 ) < 0 )
+            {
+                return VLC_EGENERIC;
+            }
+            p_sys->i_pcr = -1; /* Invalidate time display */
+            UpdateSeekPoint( p_demux, i64 );
+            return VLC_SUCCESS;
+        }
+
+
+        default:
+            return VLC_EGENERIC;
+    }
+}
+
diff -Nurp vlc-a/modules/access/mms/Android.mk vlc-b/modules/access/mms/Android.mk
--- vlc-a/modules/access/mms/Android.mk	1970-01-01 08:00:00.000000000 +0800
+++ vlc-b/modules/access/mms/Android.mk	2011-07-10 01:53:48.979262055 +0800
@@ -0,0 +1,32 @@
+
+LOCAL_PATH := $(call my-dir)
+
+include $(CLEAR_VARS)
+
+LOCAL_ARM_MODE := arm
+ifeq ($(BUILD_WITH_NEON),1)
+LOCAL_ARM_NEON := true
+endif
+
+LOCAL_MODULE := access_mms_plugin
+
+LOCAL_CFLAGS += \
+    -std=c99 \
+    -DHAVE_CONFIG_H \
+    -DMODULE_STRING=\"access_mms\" \
+    -DMODULE_NAME=access_mms
+
+LOCAL_C_INCLUDES += \
+    $(VLCROOT) \
+    $(VLCROOT)/include \
+    $(VLCROOT)/src
+
+LOCAL_SRC_FILES := \
+    asf.c \
+    buffer.c \
+    mms.c \
+    mmsh.c \
+    mmstu.c
+
+include $(BUILD_STATIC_LIBRARY)
+
diff -Nurp vlc-a/modules/access/rtsp/Android.mk vlc-b/modules/access/rtsp/Android.mk
--- vlc-a/modules/access/rtsp/Android.mk	1970-01-01 08:00:00.000000000 +0800
+++ vlc-b/modules/access/rtsp/Android.mk	2011-07-10 01:53:48.984262082 +0800
@@ -0,0 +1,33 @@
+
+LOCAL_PATH := $(call my-dir)
+
+include $(CLEAR_VARS)
+
+LOCAL_ARM_MODE := arm
+ifeq ($(BUILD_WITH_NEON),1)
+LOCAL_ARM_NEON := true
+endif
+
+LOCAL_MODULE := realrtsp_plugin
+
+LOCAL_CFLAGS += \
+    -std=c99 \
+    -DHAVE_CONFIG_H \
+    -DMODULE_STRING=\"realrtsp\" \
+    -DMODULE_NAME=realrtsp
+
+LOCAL_C_INCLUDES += \
+    $(VLCROOT) \
+    $(VLCROOT)/include \
+    $(VLCROOT)/src
+
+LOCAL_SRC_FILES := \
+    access.c \
+    real.c \
+    real_asmrp.c \
+    real_rmff.c \
+    real_sdpplin.c \
+    rtsp.c
+
+include $(BUILD_STATIC_LIBRARY)
+
diff -Nurp vlc-a/modules/Android.mk vlc-b/modules/Android.mk
--- vlc-a/modules/Android.mk	1970-01-01 08:00:00.000000000 +0800
+++ vlc-b/modules/Android.mk	2011-07-10 01:53:48.963261965 +0800
@@ -0,0 +1,3 @@
+LOCAL_PATH := $(call my-dir)
+include $(CLEAR_VARS)
+include $(call all-makefiles-under,$(LOCAL_PATH))
diff -Nurp vlc-a/modules/arm_neon/Android.mk vlc-b/modules/arm_neon/Android.mk
--- vlc-a/modules/arm_neon/Android.mk	1970-01-01 08:00:00.000000000 +0800
+++ vlc-b/modules/arm_neon/Android.mk	2011-07-10 01:53:48.996262150 +0800
@@ -0,0 +1,68 @@
+
+LOCAL_PATH := $(call my-dir)
+
+ifeq ($(BUILD_WITH_NEON),1)
+
+include $(CLEAR_VARS)
+
+LOCAL_ARM_MODE := arm
+LOCAL_ARM_NEON := true
+
+LOCAL_MODULE := audio_format_neon_plugin
+
+LOCAL_CFLAGS += \
+    -std=c99 \
+    -DHAVE_CONFIG_H \
+    -fasm \
+    -DMODULE_STRING=\"audio_format_neon\" \
+    -DMODULE_NAME=audio_format_neon
+
+LOCAL_C_INCLUDES += \
+    $(VLCROOT) \
+    $(VLCROOT)/include \
+    $(VLCROOT)/src
+
+LOCAL_SRC_FILES := \
+    audio_format.c \
+    s32_s16.S
+
+include $(BUILD_STATIC_LIBRARY)
+
+endif
+
+include $(CLEAR_VARS)
+
+LOCAL_ARM_MODE := arm
+ifeq ($(BUILD_WITH_NEON),1)
+LOCAL_ARM_NEON := true
+endif
+
+LOCAL_MODULE := yuv2rgb_plugin
+
+LOCAL_CFLAGS += \
+    -std=c99 \
+    -DHAVE_CONFIG_H \
+    -fasm \
+    -DMODULE_STRING=\"yuv2rgb\" \
+    -DMODULE_NAME=yuv2rgb
+
+LOCAL_C_INCLUDES += \
+    $(EXTROOR)/pixman/pixman \
+    $(VLCROOT) \
+    $(VLCROOT)/include \
+    $(VLCROOT)/src
+
+LOCAL_SRC_FILES := \
+    yuv2rgb.c \
+    yuv2rgb16tab.c \
+    yuv420rgb565.S \
+    yuv422rgb565.S \
+    yuv444rgb565.S
+
+ifeq ($(BUILD_WITH_NEON),1)
+LOCAL_CFLAGS += -DHAVE_NEON=1
+LOCAL_SRC_FILES += yuv2rgb.444565.S yuv2rgb.422565.S yuv2rgb.420565.c
+endif
+
+include $(BUILD_STATIC_LIBRARY)
+
diff -Nurp vlc-a/modules/arm_neon/yuv2rgb16tab.c vlc-b/modules/arm_neon/yuv2rgb16tab.c
--- vlc-a/modules/arm_neon/yuv2rgb16tab.c	1970-01-01 08:00:00.000000000 +0800
+++ vlc-b/modules/arm_neon/yuv2rgb16tab.c	2011-07-10 01:53:48.997262156 +0800
@@ -0,0 +1,802 @@
+/* YUV-> RGB conversion code.
+ *
+ * Copyright (C) 2008-9 Robin Watts (robin@wss.co.uk) for Pinknoise
+ * Productions Ltd.
+ *
+ * Licensed under the GNU GPL. If you need it under another license, contact
+ * me and ask.
+ *
+ *  This program is free software ; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation ; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY ; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program ; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+
+/* For BREW or Symbian you might need to make this static const rather than
+ * just const, and introduce a function to get the address. */
+
+#include "yuv2rgb.h"
+
+const uint32_t yuv2rgb565_table[256*3] =
+{
+	/* y_table */
+        0x7FFFFFEDU,
+        0x7FFFFFEFU,
+        0x7FFFFFF0U,
+        0x7FFFFFF1U,
+        0x7FFFFFF2U,
+        0x7FFFFFF3U,
+        0x7FFFFFF4U,
+        0x7FFFFFF6U,
+        0x7FFFFFF7U,
+        0x7FFFFFF8U,
+        0x7FFFFFF9U,
+        0x7FFFFFFAU,
+        0x7FFFFFFBU,
+        0x7FFFFFFDU,
+        0x7FFFFFFEU,
+        0x7FFFFFFFU,
+        0x80000000U,
+        0x80400801U,
+        0x80A01002U,
+        0x80E01803U,
+        0x81202805U,
+        0x81803006U,
+        0x81C03807U,
+        0x82004008U,
+        0x82604809U,
+        0x82A0500AU,
+        0x82E0600CU,
+        0x8340680DU,
+        0x8380700EU,
+        0x83C0780FU,
+        0x84208010U,
+        0x84608811U,
+        0x84A09813U,
+        0x8500A014U,
+        0x8540A815U,
+        0x8580B016U,
+        0x85E0B817U,
+        0x8620C018U,
+        0x8660D01AU,
+        0x86C0D81BU,
+        0x8700E01CU,
+        0x8740E81DU,
+        0x87A0F01EU,
+        0x87E0F81FU,
+        0x88210821U,
+        0x88811022U,
+        0x88C11823U,
+        0x89012024U,
+        0x89412825U,
+        0x89A13026U,
+        0x89E14028U,
+        0x8A214829U,
+        0x8A81502AU,
+        0x8AC1582BU,
+        0x8B01602CU,
+        0x8B61682DU,
+        0x8BA1782FU,
+        0x8BE18030U,
+        0x8C418831U,
+        0x8C819032U,
+        0x8CC19833U,
+        0x8D21A034U,
+        0x8D61B036U,
+        0x8DA1B837U,
+        0x8E01C038U,
+        0x8E41C839U,
+        0x8E81D03AU,
+        0x8EE1D83BU,
+        0x8F21E83DU,
+        0x8F61F03EU,
+        0x8FC1F83FU,
+        0x90020040U,
+        0x90420841U,
+        0x90A21042U,
+        0x90E22044U,
+        0x91222845U,
+        0x91823046U,
+        0x91C23847U,
+        0x92024048U,
+        0x92624849U,
+        0x92A2504AU,
+        0x92E2604CU,
+        0x9342684DU,
+        0x9382704EU,
+        0x93C2784FU,
+        0x94228050U,
+        0x94628851U,
+        0x94A29853U,
+        0x9502A054U,
+        0x9542A855U,
+        0x9582B056U,
+        0x95E2B857U,
+        0x9622C058U,
+        0x9662D05AU,
+        0x96C2D85BU,
+        0x9702E05CU,
+        0x9742E85DU,
+        0x97A2F05EU,
+        0x97E2F85FU,
+        0x98230861U,
+        0x98831062U,
+        0x98C31863U,
+        0x99032064U,
+        0x99632865U,
+        0x99A33066U,
+        0x99E34068U,
+        0x9A434869U,
+        0x9A83506AU,
+        0x9AC3586BU,
+        0x9B23606CU,
+        0x9B63686DU,
+        0x9BA3786FU,
+        0x9BE38070U,
+        0x9C438871U,
+        0x9C839072U,
+        0x9CC39873U,
+        0x9D23A074U,
+        0x9D63B076U,
+        0x9DA3B877U,
+        0x9E03C078U,
+        0x9E43C879U,
+        0x9E83D07AU,
+        0x9EE3D87BU,
+        0x9F23E87DU,
+        0x9F63F07EU,
+        0x9FC3F87FU,
+        0xA0040080U,
+        0xA0440881U,
+        0xA0A41082U,
+        0xA0E42084U,
+        0xA1242885U,
+        0xA1843086U,
+        0xA1C43887U,
+        0xA2044088U,
+        0xA2644889U,
+        0xA2A4588BU,
+        0xA2E4608CU,
+        0xA344688DU,
+        0xA384708EU,
+        0xA3C4788FU,
+        0xA4248090U,
+        0xA4649092U,
+        0xA4A49893U,
+        0xA504A094U,
+        0xA544A895U,
+        0xA584B096U,
+        0xA5E4B897U,
+        0xA624C098U,
+        0xA664D09AU,
+        0xA6C4D89BU,
+        0xA704E09CU,
+        0xA744E89DU,
+        0xA7A4F09EU,
+        0xA7E4F89FU,
+        0xA82508A1U,
+        0xA88510A2U,
+        0xA8C518A3U,
+        0xA90520A4U,
+        0xA96528A5U,
+        0xA9A530A6U,
+        0xA9E540A8U,
+        0xAA4548A9U,
+        0xAA8550AAU,
+        0xAAC558ABU,
+        0xAB2560ACU,
+        0xAB6568ADU,
+        0xABA578AFU,
+        0xAC0580B0U,
+        0xAC4588B1U,
+        0xAC8590B2U,
+        0xACE598B3U,
+        0xAD25A0B4U,
+        0xAD65B0B6U,
+        0xADA5B8B7U,
+        0xAE05C0B8U,
+        0xAE45C8B9U,
+        0xAE85D0BAU,
+        0xAEE5D8BBU,
+        0xAF25E8BDU,
+        0xAF65F0BEU,
+        0xAFC5F8BFU,
+        0xB00600C0U,
+        0xB04608C1U,
+        0xB0A610C2U,
+        0xB0E620C4U,
+        0xB12628C5U,
+        0xB18630C6U,
+        0xB1C638C7U,
+        0xB20640C8U,
+        0xB26648C9U,
+        0xB2A658CBU,
+        0xB2E660CCU,
+        0xB34668CDU,
+        0xB38670CEU,
+        0xB3C678CFU,
+        0xB42680D0U,
+        0xB46690D2U,
+        0xB4A698D3U,
+        0xB506A0D4U,
+        0xB546A8D5U,
+        0xB586B0D6U,
+        0xB5E6B8D7U,
+        0xB626C8D9U,
+        0xB666D0DAU,
+        0xB6C6D8DBU,
+        0xB706E0DCU,
+        0xB746E8DDU,
+        0xB7A6F0DEU,
+        0xB7E6F8DFU,
+        0xB82708E1U,
+        0xB88710E2U,
+        0xB8C718E3U,
+        0xB90720E4U,
+        0xB96728E5U,
+        0xB9A730E6U,
+        0xB9E740E8U,
+        0xBA4748E9U,
+        0xBA8750EAU,
+        0xBAC758EBU,
+        0xBB2760ECU,
+        0xBB6768EDU,
+        0xBBA778EFU,
+        0xBC0780F0U,
+        0xBC4788F1U,
+        0xBC8790F2U,
+        0xBCE798F3U,
+        0xBD27A0F4U,
+        0xBD67B0F6U,
+        0xBDC7B8F7U,
+        0xBE07C0F8U,
+        0xBE47C8F9U,
+        0xBEA7D0FAU,
+        0xBEE7D8FBU,
+        0xBF27E8FDU,
+        0xBF87F0FEU,
+        0xBFC7F8FFU,
+        0xC0080100U,
+        0xC0480901U,
+        0xC0A81102U,
+        0xC0E82104U,
+        0xC0E82104U,
+        0xC0E82104U,
+        0xC0E82104U,
+        0xC0E82104U,
+        0xC0E82104U,
+        0xC0E82104U,
+        0xC0E82104U,
+        0xC0E82104U,
+        0xC0E82104U,
+        0xC0E82104U,
+        0xC0E82104U,
+        0xC0E82104U,
+        0xC0E82104U,
+        0xC0E82104U,
+        0xC0E82104U,
+        0xC0E82104U,
+	/* u_table */
+        0x0C400103U,
+        0x0C200105U,
+        0x0C200107U,
+        0x0C000109U,
+        0x0BE0010BU,
+        0x0BC0010DU,
+        0x0BA0010FU,
+        0x0BA00111U,
+        0x0B800113U,
+        0x0B600115U,
+        0x0B400117U,
+        0x0B400119U,
+        0x0B20011BU,
+        0x0B00011DU,
+        0x0AE0011FU,
+        0x0AE00121U,
+        0x0AC00123U,
+        0x0AA00125U,
+        0x0A800127U,
+        0x0A600129U,
+        0x0A60012BU,
+        0x0A40012DU,
+        0x0A20012FU,
+        0x0A000131U,
+        0x0A000132U,
+        0x09E00134U,
+        0x09C00136U,
+        0x09A00138U,
+        0x09A0013AU,
+        0x0980013CU,
+        0x0960013EU,
+        0x09400140U,
+        0x09400142U,
+        0x09200144U,
+        0x09000146U,
+        0x08E00148U,
+        0x08C0014AU,
+        0x08C0014CU,
+        0x08A0014EU,
+        0x08800150U,
+        0x08600152U,
+        0x08600154U,
+        0x08400156U,
+        0x08200158U,
+        0x0800015AU,
+        0x0800015CU,
+        0x07E0015EU,
+        0x07C00160U,
+        0x07A00162U,
+        0x07A00164U,
+        0x07800166U,
+        0x07600168U,
+        0x0740016AU,
+        0x0720016CU,
+        0x0720016EU,
+        0x07000170U,
+        0x06E00172U,
+        0x06C00174U,
+        0x06C00176U,
+        0x06A00178U,
+        0x0680017AU,
+        0x0660017CU,
+        0x0660017EU,
+        0x06400180U,
+        0x06200182U,
+        0x06000184U,
+        0x05E00185U,
+        0x05E00187U,
+        0x05C00189U,
+        0x05A0018BU,
+        0x0580018DU,
+        0x0580018FU,
+        0x05600191U,
+        0x05400193U,
+        0x05200195U,
+        0x05200197U,
+        0x05000199U,
+        0x04E0019BU,
+        0x04C0019DU,
+        0x04C0019FU,
+        0x04A001A1U,
+        0x048001A3U,
+        0x046001A5U,
+        0x044001A7U,
+        0x044001A9U,
+        0x042001ABU,
+        0x040001ADU,
+        0x03E001AFU,
+        0x03E001B1U,
+        0x03C001B3U,
+        0x03A001B5U,
+        0x038001B7U,
+        0x038001B9U,
+        0x036001BBU,
+        0x034001BDU,
+        0x032001BFU,
+        0x032001C1U,
+        0x030001C3U,
+        0x02E001C5U,
+        0x02C001C7U,
+        0x02A001C9U,
+        0x02A001CBU,
+        0x028001CDU,
+        0x026001CFU,
+        0x024001D1U,
+        0x024001D3U,
+        0x022001D5U,
+        0x020001D7U,
+        0x01E001D8U,
+        0x01E001DAU,
+        0x01C001DCU,
+        0x01A001DEU,
+        0x018001E0U,
+        0x016001E2U,
+        0x016001E4U,
+        0x014001E6U,
+        0x012001E8U,
+        0x010001EAU,
+        0x010001ECU,
+        0x00E001EEU,
+        0x00C001F0U,
+        0x00A001F2U,
+        0x00A001F4U,
+        0x008001F6U,
+        0x006001F8U,
+        0x004001FAU,
+        0x004001FCU,
+        0x002001FEU,
+        0x00000200U,
+        0xFFE00202U,
+        0xFFC00204U,
+        0xFFC00206U,
+        0xFFA00208U,
+        0xFF80020AU,
+        0xFF60020CU,
+        0xFF60020EU,
+        0xFF400210U,
+        0xFF200212U,
+        0xFF000214U,
+        0xFF000216U,
+        0xFEE00218U,
+        0xFEC0021AU,
+        0xFEA0021CU,
+        0xFEA0021EU,
+        0xFE800220U,
+        0xFE600222U,
+        0xFE400224U,
+        0xFE200226U,
+        0xFE200228U,
+        0xFE000229U,
+        0xFDE0022BU,
+        0xFDC0022DU,
+        0xFDC0022FU,
+        0xFDA00231U,
+        0xFD800233U,
+        0xFD600235U,
+        0xFD600237U,
+        0xFD400239U,
+        0xFD20023BU,
+        0xFD00023DU,
+        0xFCE0023FU,
+        0xFCE00241U,
+        0xFCC00243U,
+        0xFCA00245U,
+        0xFC800247U,
+        0xFC800249U,
+        0xFC60024BU,
+        0xFC40024DU,
+        0xFC20024FU,
+        0xFC200251U,
+        0xFC000253U,
+        0xFBE00255U,
+        0xFBC00257U,
+        0xFBC00259U,
+        0xFBA0025BU,
+        0xFB80025DU,
+        0xFB60025FU,
+        0xFB400261U,
+        0xFB400263U,
+        0xFB200265U,
+        0xFB000267U,
+        0xFAE00269U,
+        0xFAE0026BU,
+        0xFAC0026DU,
+        0xFAA0026FU,
+        0xFA800271U,
+        0xFA800273U,
+        0xFA600275U,
+        0xFA400277U,
+        0xFA200279U,
+        0xFA20027BU,
+        0xFA00027CU,
+        0xF9E0027EU,
+        0xF9C00280U,
+        0xF9A00282U,
+        0xF9A00284U,
+        0xF9800286U,
+        0xF9600288U,
+        0xF940028AU,
+        0xF940028CU,
+        0xF920028EU,
+        0xF9000290U,
+        0xF8E00292U,
+        0xF8E00294U,
+        0xF8C00296U,
+        0xF8A00298U,
+        0xF880029AU,
+        0xF860029CU,
+        0xF860029EU,
+        0xF84002A0U,
+        0xF82002A2U,
+        0xF80002A4U,
+        0xF80002A6U,
+        0xF7E002A8U,
+        0xF7C002AAU,
+        0xF7A002ACU,
+        0xF7A002AEU,
+        0xF78002B0U,
+        0xF76002B2U,
+        0xF74002B4U,
+        0xF74002B6U,
+        0xF72002B8U,
+        0xF70002BAU,
+        0xF6E002BCU,
+        0xF6C002BEU,
+        0xF6C002C0U,
+        0xF6A002C2U,
+        0xF68002C4U,
+        0xF66002C6U,
+        0xF66002C8U,
+        0xF64002CAU,
+        0xF62002CCU,
+        0xF60002CEU,
+        0xF60002CFU,
+        0xF5E002D1U,
+        0xF5C002D3U,
+        0xF5A002D5U,
+        0xF5A002D7U,
+        0xF58002D9U,
+        0xF56002DBU,
+        0xF54002DDU,
+        0xF52002DFU,
+        0xF52002E1U,
+        0xF50002E3U,
+        0xF4E002E5U,
+        0xF4C002E7U,
+        0xF4C002E9U,
+        0xF4A002EBU,
+        0xF48002EDU,
+        0xF46002EFU,
+        0xF46002F1U,
+        0xF44002F3U,
+        0xF42002F5U,
+        0xF40002F7U,
+        0xF3E002F9U,
+        0xF3E002FBU,
+	/* v_table */
+        0x1A09A000U,
+        0x19E9A800U,
+        0x19A9B800U,
+        0x1969C800U,
+        0x1949D000U,
+        0x1909E000U,
+        0x18C9E800U,
+        0x18A9F800U,
+        0x186A0000U,
+        0x182A1000U,
+        0x180A2000U,
+        0x17CA2800U,
+        0x17AA3800U,
+        0x176A4000U,
+        0x172A5000U,
+        0x170A6000U,
+        0x16CA6800U,
+        0x168A7800U,
+        0x166A8000U,
+        0x162A9000U,
+        0x160AA000U,
+        0x15CAA800U,
+        0x158AB800U,
+        0x156AC000U,
+        0x152AD000U,
+        0x14EAE000U,
+        0x14CAE800U,
+        0x148AF800U,
+        0x146B0000U,
+        0x142B1000U,
+        0x13EB2000U,
+        0x13CB2800U,
+        0x138B3800U,
+        0x134B4000U,
+        0x132B5000U,
+        0x12EB6000U,
+        0x12CB6800U,
+        0x128B7800U,
+        0x124B8000U,
+        0x122B9000U,
+        0x11EBA000U,
+        0x11ABA800U,
+        0x118BB800U,
+        0x114BC000U,
+        0x112BD000U,
+        0x10EBE000U,
+        0x10ABE800U,
+        0x108BF800U,
+        0x104C0000U,
+        0x100C1000U,
+        0x0FEC2000U,
+        0x0FAC2800U,
+        0x0F8C3800U,
+        0x0F4C4000U,
+        0x0F0C5000U,
+        0x0EEC5800U,
+        0x0EAC6800U,
+        0x0E6C7800U,
+        0x0E4C8000U,
+        0x0E0C9000U,
+        0x0DEC9800U,
+        0x0DACA800U,
+        0x0D6CB800U,
+        0x0D4CC000U,
+        0x0D0CD000U,
+        0x0CCCD800U,
+        0x0CACE800U,
+        0x0C6CF800U,
+        0x0C4D0000U,
+        0x0C0D1000U,
+        0x0BCD1800U,
+        0x0BAD2800U,
+        0x0B6D3800U,
+        0x0B2D4000U,
+        0x0B0D5000U,
+        0x0ACD5800U,
+        0x0AAD6800U,
+        0x0A6D7800U,
+        0x0A2D8000U,
+        0x0A0D9000U,
+        0x09CD9800U,
+        0x098DA800U,
+        0x096DB800U,
+        0x092DC000U,
+        0x090DD000U,
+        0x08CDD800U,
+        0x088DE800U,
+        0x086DF800U,
+        0x082E0000U,
+        0x07EE1000U,
+        0x07CE1800U,
+        0x078E2800U,
+        0x076E3800U,
+        0x072E4000U,
+        0x06EE5000U,
+        0x06CE5800U,
+        0x068E6800U,
+        0x064E7800U,
+        0x062E8000U,
+        0x05EE9000U,
+        0x05CE9800U,
+        0x058EA800U,
+        0x054EB800U,
+        0x052EC000U,
+        0x04EED000U,
+        0x04AED800U,
+        0x048EE800U,
+        0x044EF000U,
+        0x042F0000U,
+        0x03EF1000U,
+        0x03AF1800U,
+        0x038F2800U,
+        0x034F3000U,
+        0x030F4000U,
+        0x02EF5000U,
+        0x02AF5800U,
+        0x028F6800U,
+        0x024F7000U,
+        0x020F8000U,
+        0x01EF9000U,
+        0x01AF9800U,
+        0x016FA800U,
+        0x014FB000U,
+        0x010FC000U,
+        0x00EFD000U,
+        0x00AFD800U,
+        0x006FE800U,
+        0x004FF000U,
+        0x00100000U,
+        0xFFD01000U,
+        0xFFB01800U,
+        0xFF702800U,
+        0xFF303000U,
+        0xFF104000U,
+        0xFED05000U,
+        0xFEB05800U,
+        0xFE706800U,
+        0xFE307000U,
+        0xFE108000U,
+        0xFDD09000U,
+        0xFD909800U,
+        0xFD70A800U,
+        0xFD30B000U,
+        0xFD10C000U,
+        0xFCD0D000U,
+        0xFC90D800U,
+        0xFC70E800U,
+        0xFC30F000U,
+        0xFBF10000U,
+        0xFBD11000U,
+        0xFB911800U,
+        0xFB712800U,
+        0xFB313000U,
+        0xFAF14000U,
+        0xFAD14800U,
+        0xFA915800U,
+        0xFA516800U,
+        0xFA317000U,
+        0xF9F18000U,
+        0xF9D18800U,
+        0xF9919800U,
+        0xF951A800U,
+        0xF931B000U,
+        0xF8F1C000U,
+        0xF8B1C800U,
+        0xF891D800U,
+        0xF851E800U,
+        0xF831F000U,
+        0xF7F20000U,
+        0xF7B20800U,
+        0xF7921800U,
+        0xF7522800U,
+        0xF7123000U,
+        0xF6F24000U,
+        0xF6B24800U,
+        0xF6925800U,
+        0xF6526800U,
+        0xF6127000U,
+        0xF5F28000U,
+        0xF5B28800U,
+        0xF5729800U,
+        0xF552A800U,
+        0xF512B000U,
+        0xF4F2C000U,
+        0xF4B2C800U,
+        0xF472D800U,
+        0xF452E800U,
+        0xF412F000U,
+        0xF3D30000U,
+        0xF3B30800U,
+        0xF3731800U,
+        0xF3532800U,
+        0xF3133000U,
+        0xF2D34000U,
+        0xF2B34800U,
+        0xF2735800U,
+        0xF2336800U,
+        0xF2137000U,
+        0xF1D38000U,
+        0xF1B38800U,
+        0xF1739800U,
+        0xF133A800U,
+        0xF113B000U,
+        0xF0D3C000U,
+        0xF093C800U,
+        0xF073D800U,
+        0xF033E000U,
+        0xF013F000U,
+        0xEFD40000U,
+        0xEF940800U,
+        0xEF741800U,
+        0xEF342000U,
+        0xEEF43000U,
+        0xEED44000U,
+        0xEE944800U,
+        0xEE745800U,
+        0xEE346000U,
+        0xEDF47000U,
+        0xEDD48000U,
+        0xED948800U,
+        0xED549800U,
+        0xED34A000U,
+        0xECF4B000U,
+        0xECD4C000U,
+        0xEC94C800U,
+        0xEC54D800U,
+        0xEC34E000U,
+        0xEBF4F000U,
+        0xEBB50000U,
+        0xEB950800U,
+        0xEB551800U,
+        0xEB352000U,
+        0xEAF53000U,
+        0xEAB54000U,
+        0xEA954800U,
+        0xEA555800U,
+        0xEA156000U,
+        0xE9F57000U,
+        0xE9B58000U,
+        0xE9958800U,
+        0xE9559800U,
+        0xE915A000U,
+        0xE8F5B000U,
+        0xE8B5C000U,
+        0xE875C800U,
+        0xE855D800U,
+        0xE815E000U,
+        0xE7F5F000U,
+        0xE7B60000U,
+        0xE7760800U,
+        0xE7561800U,
+        0xE7162000U,
+        0xE6D63000U,
+        0xE6B64000U,
+        0xE6764800U,
+        0xE6365800U
+};
diff -Nurp vlc-a/modules/arm_neon/yuv2rgb.420565.c vlc-b/modules/arm_neon/yuv2rgb.420565.c
--- vlc-a/modules/arm_neon/yuv2rgb.420565.c	1970-01-01 08:00:00.000000000 +0800
+++ vlc-b/modules/arm_neon/yuv2rgb.420565.c	2011-07-10 01:53:48.996262150 +0800
@@ -0,0 +1,201 @@
+// Copyright (c) 2010 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+// contributor Siarhei Siamashka <siarhei.siamashka@gmail.com>
+
+#include <stdint.h>
+
+void __attribute((noinline)) yv12_to_rgb565_neon(uint16_t *dst, const uint8_t *y, const uint8_t *u, const uint8_t *v, int n, int oddflag)
+{
+    static __attribute__((aligned(16))) uint16_t acc_r[8] = {
+        22840, 22840, 22840, 22840, 22840, 22840, 22840, 22840,
+    };
+    static __attribute__((aligned(16))) uint16_t acc_g[8] = {
+        17312, 17312, 17312, 17312, 17312, 17312, 17312, 17312,
+    };
+    static __attribute__((aligned(16))) uint16_t acc_b[8] = {
+        28832, 28832, 28832, 28832, 28832, 28832, 28832, 28832,
+    };
+    /*
+     * Registers:
+     * q0, q1 : d0, d1, d2, d3  - are used for initial loading of YUV data
+     * q2     : d4, d5          - are used for storing converted RGB data
+     * q3     : d6, d7          - are used for temporary storage
+     *
+     * q4-q7 - reserved
+     *
+     * q8, q9 : d16, d17, d18, d19  - are used for expanded Y data
+     * q10    : d20, d21
+     * q11    : d22, d23
+     * q12    : d24, d25
+     * q13    : d26, d27
+     * q13, q14, q15            - various constants (#16, #149, #204, #50, #104, #154)
+     */
+    asm volatile (
+".fpu neon\n"
+".macro convert_macroblock size\n"
+/* load up to 16 source pixels */
+	".if \\size == 16\n"
+	    "pld [%[y], #64]\n"
+	    "pld [%[u], #64]\n"
+	    "pld [%[v], #64]\n"
+	    "vld1.8 {d1}, [%[y]]!\n"
+	    "vld1.8 {d3}, [%[y]]!\n"
+	    "vld1.8 {d0}, [%[u]]!\n"
+	    "vld1.8 {d2}, [%[v]]!\n"
+	".elseif \\size == 8\n"
+	    "vld1.8 {d1}, [%[y]]!\n"
+	    "vld1.8 {d0[0]}, [%[u]]!\n"
+	    "vld1.8 {d0[1]}, [%[u]]!\n"
+	    "vld1.8 {d0[2]}, [%[u]]!\n"
+	    "vld1.8 {d0[3]}, [%[u]]!\n"
+	    "vld1.8 {d2[0]}, [%[v]]!\n"
+	    "vld1.8 {d2[1]}, [%[v]]!\n"
+	    "vld1.8 {d2[2]}, [%[v]]!\n"
+	    "vld1.8 {d2[3]}, [%[v]]!\n"
+	".elseif \\size == 4\n"
+	    "vld1.8 {d1[0]}, [%[y]]!\n"
+	    "vld1.8 {d1[1]}, [%[y]]!\n"
+	    "vld1.8 {d1[2]}, [%[y]]!\n"
+	    "vld1.8 {d1[3]}, [%[y]]!\n"
+	    "vld1.8 {d0[0]}, [%[u]]!\n"
+	    "vld1.8 {d0[1]}, [%[u]]!\n"
+	    "vld1.8 {d2[0]}, [%[v]]!\n"
+	    "vld1.8 {d2[1]}, [%[v]]!\n"
+	".elseif \\size == 2\n"
+	    "vld1.8 {d1[0]}, [%[y]]!\n"
+	    "vld1.8 {d1[1]}, [%[y]]!\n"
+	    "vld1.8 {d0[0]}, [%[u]]!\n"
+	    "vld1.8 {d2[0]}, [%[v]]!\n"
+	".elseif \\size == 1\n"
+	    "vld1.8 {d1[0]}, [%[y]]!\n"
+	    "vld1.8 {d0[0]}, [%[u]]!\n"
+	    "vld1.8 {d2[0]}, [%[v]]!\n"
+	".else\n"
+	    ".error \"unsupported macroblock size\"\n"
+	".endif\n"
+
+        /* d1 - Y data (first 8 bytes) */
+        /* d3 - Y data (next 8 bytes) */
+        /* d0 - U data, d2 - V data */
+
+	/* split even and odd Y color components */
+	"vuzp.8      d1, d3\n"                       /* d1 - evenY, d3 - oddY */
+	/* clip upper and lower boundaries */
+	"vqadd.u8    q0, q0, q4\n"
+	"vqadd.u8    q1, q1, q4\n"
+	"vqsub.u8    q0, q0, q5\n"
+	"vqsub.u8    q1, q1, q5\n"
+
+	"vshr.u8     d4, d2, #1\n"                   /* d4 = V >> 1 */
+
+	"vmull.u8    q8, d1, d27\n"                  /* q8 = evenY * 149 */
+	"vmull.u8    q9, d3, d27\n"                  /* q9 = oddY * 149 */
+
+	"vld1.16     {d20, d21}, [%[acc_r], :128]\n" /* q10 - initialize accumulator for red */
+	"vsubw.u8    q10, q10, d4\n"                 /* red acc -= (V >> 1) */
+	"vmlsl.u8    q10, d2, d28\n"                 /* red acc -= V * 204 */
+	"vld1.16     {d22, d23}, [%[acc_g], :128]\n" /* q11 - initialize accumulator for green */
+	"vmlsl.u8    q11, d2, d30\n"                 /* green acc -= V * 104 */
+	"vmlsl.u8    q11, d0, d29\n"                 /* green acc -= U * 50 */
+	"vld1.16     {d24, d25}, [%[acc_b], :128]\n" /* q12 - initialize accumulator for blue */
+	"vmlsl.u8    q12, d0, d30\n"                 /* blue acc -= U * 104 */
+	"vmlsl.u8    q12, d0, d31\n"                 /* blue acc -= U * 154 */
+
+	"vhsub.s16   q3, q8, q10\n"                  /* calculate even red components */
+	"vhsub.s16   q10, q9, q10\n"                 /* calculate odd red components */
+	"vqshrun.s16 d0, q3, #6\n"                   /* right shift, narrow and saturate even red components */
+	"vqshrun.s16 d3, q10, #6\n"                  /* right shift, narrow and saturate odd red components */
+
+	"vhadd.s16   q3, q8, q11\n"                  /* calculate even green components */
+	"vhadd.s16   q11, q9, q11\n"                 /* calculate odd green components */
+	"vqshrun.s16 d1, q3, #6\n"                   /* right shift, narrow and saturate even green components */
+	"vqshrun.s16 d4, q11, #6\n"                  /* right shift, narrow and saturate odd green components */
+
+	"vhsub.s16   q3, q8, q12\n"                  /* calculate even blue components */
+	"vhsub.s16   q12, q9, q12\n"                 /* calculate odd blue components */
+	"vqshrun.s16 d2, q3, #6\n"                   /* right shift, narrow and saturate even blue components */
+	"vqshrun.s16 d5, q12, #6\n"                  /* right shift, narrow and saturate odd blue components */
+
+	"vzip.8      d0, d3\n"                       /* join even and odd red components */
+	"vzip.8      d1, d4\n"                       /* join even and odd green components */
+	"vzip.8      d2, d5\n"                       /* join even and odd blue components */
+
+	"vshll.u8    q3, d0, #8\n\t"
+	"vshll.u8    q8, d1, #8\n\t"
+	"vshll.u8    q9, d2, #8\n\t"
+	"vsri.u16    q3, q8, #5\t\n"
+	"vsri.u16    q3, q9, #11\t\n"
+	/* store pixel data to memory */
+	".if \\size == 16\n"
+	"    vst1.16 {d6, d7}, [%[dst]]!\n"
+	"    vshll.u8    q3, d3, #8\n\t"
+	"    vshll.u8    q8, d4, #8\n\t"
+	"    vshll.u8    q9, d5, #8\n\t"
+	"    vsri.u16    q3, q8, #5\t\n"
+	"    vsri.u16    q3, q9, #11\t\n"
+	"    vst1.16 {d6, d7}, [%[dst]]!\n"
+	".elseif \\size == 8\n"
+	"    vst1.16 {d6, d7}, [%[dst]]!\n"
+	".elseif \\size == 4\n"
+	"    vst1.16 {d6}, [%[dst]]!\n"
+	".elseif \\size == 2\n"
+	"    vst1.16 {d6[0]}, [%[dst]]!\n"
+	"    vst1.16 {d6[1]}, [%[dst]]!\n"
+	".elseif \\size == 1\n"
+	"    vst1.16 {d6[0]}, [%[dst]]!\n"
+	".endif\n"
+	".endm\n"
+
+	"vmov.u8     d8, #15\n" /* add this to U/V to saturate upper boundary */
+	"vmov.u8     d9, #20\n" /* add this to Y to saturate upper boundary */
+	"vmov.u8     d10, #31\n" /* sub this from U/V to saturate lower boundary */
+	"vmov.u8     d11, #36\n" /* sub this from Y to saturate lower boundary */
+
+	"vmov.u8     d26, #16\n"
+	"vmov.u8     d27, #149\n"
+	"vmov.u8     d28, #204\n"
+	"vmov.u8     d29, #50\n"
+	"vmov.u8     d30, #104\n"
+	"vmov.u8     d31, #154\n"
+
+	"cmp         %[oddflag], #0\n"
+	"beq         1f\n"
+	"convert_macroblock 1\n"
+	"sub         %[n], %[n], #1\n"
+    "1:\n"
+	"subs        %[n], %[n], #16\n"
+	"blt         2f\n"
+    "1:\n"
+	"convert_macroblock 16\n"
+	"subs        %[n], %[n], #16\n"
+	"bge         1b\n"
+    "2:\n"
+	"tst         %[n], #8\n"
+	"beq         3f\n"
+	"convert_macroblock 8\n"
+    "3:\n"
+	"tst         %[n], #4\n"
+	"beq         4f\n"
+	"convert_macroblock 4\n"
+    "4:\n"
+	"tst         %[n], #2\n"
+	"beq         5f\n"
+	"convert_macroblock 2\n"
+    "5:\n"
+	"tst         %[n], #1\n"
+	"beq         6f\n"
+	"convert_macroblock 1\n"
+    "6:\n"
+	".purgem convert_macroblock\n"
+	: [y] "+&r" (y), [u] "+&r" (u), [v] "+&r" (v), [dst] "+&r" (dst), [n] "+&r" (n)
+	: [acc_r] "r" (&acc_r[0]), [acc_g] "r" (&acc_g[0]), [acc_b] "r" (&acc_b[0]),
+	  [oddflag] "r" (oddflag)
+	: "cc", "memory",
+	  "d0",  "d1",  "d2",  "d3",  "d4",  "d5",  "d6",  "d7",
+	  "d8",  "d9",  "d10", "d11", /* "d12", "d13", "d14", "d15", */
+	  "d16", "d17", "d18", "d19", "d20", "d21", "d22", "d23",
+	  "d24", "d25", "d26", "d27", "d28", "d29", "d30", "d31"
+    );
+}
diff -Nurp vlc-a/modules/arm_neon/yuv2rgb.422565.S vlc-b/modules/arm_neon/yuv2rgb.422565.S
--- vlc-a/modules/arm_neon/yuv2rgb.422565.S	1970-01-01 08:00:00.000000000 +0800
+++ vlc-b/modules/arm_neon/yuv2rgb.422565.S	2011-07-10 01:53:48.997262156 +0800
@@ -0,0 +1,395 @@
+/*------------------------------------------------------------------------
+* jdcolor-armv7.s
+*
+*  Copyright (c) 2010, Code Aurora Forum. All rights reserved.
+*
+*  Redistribution and use in source and binary forms, with or without
+*  modification, are permitted provided that the following conditions are
+*  met:
+*      * Redistributions of source code must retain the above copyright
+*        notice, this list of conditions and the following disclaimer.
+*      * Redistributions in binary form must reproduce the above
+*        copyright notice, this list of conditions and the following
+*        disclaimer in the documentation and/or other materials provided
+*        with the distribution.
+*      * Neither the name of Code Aurora Forum, Inc. nor the names of its
+*        contributors may be used to endorse or promote products derived
+*        from this software without specific prior written permission.
+*
+*  THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+*  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+*  ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+*  BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+*  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+*  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+*  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+*  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+*  OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+*  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*--------------------------------------------------------------------------
+
+*--------------------------------------------------------------------------
+*                         FUNCTION LIST
+*--------------------------------------------------------------------------
+*
+* - yvup2rgb565_venum
+* - yyvup2rgb565_venum
+*
+*--------------------------------------------------------------------------
+*/
+
+    .section yvu_plain_to_rgb565, "x"  @ AREA
+    .text                              @ |.text|, CODE, READONLY
+    .align 2
+    .code  32                          @ CODE32
+
+/*-----------------------------------------------------------------------------
+ *   ARM Registers
+ * ---------------------------------------------------------------------------- */
+p_y       .req r0
+p_cr      .req r1
+p_cb      .req r2
+p_rgb     .req r3
+p_bgr     .req r3
+length    .req r12
+
+    .global yyvup2rgb565_venum
+
+@ coefficients in color conversion matrix multiplication
+.equ COEFF_Y,          256             @ contribution of Y
+.equ COEFF_V_RED,      359             @ contribution of V for red
+.equ COEFF_U_GREEN,    -88             @ contribution of U for green
+.equ COEFF_V_GREEN,   -183             @ contribution of V for green
+.equ COEFF_U_BLUE,     454             @ contribution of U for blue
+
+@ Clamping constants 0x0 and 0xFF
+.equ COEFF_0,          0
+.equ COEFF_255,        255
+
+@ Bias coefficients for red, green and blue
+.equ COEFF_BIAS_R,   -45824            @ Red   bias =     -359*128 + 128
+.equ COEFF_BIAS_G,    34816            @ Green bias = (88+183)*128 + 128
+.equ COEFF_BIAS_B,   -57984            @ Blue  bias =     -454*128 + 128
+
+
+/*--------------------------------------------------------------------------
+* FUNCTION     : yyvup2rgb565_venum
+*--------------------------------------------------------------------------
+* DESCRIPTION  : Perform YYVU planar to RGB565 conversion.
+*--------------------------------------------------------------------------
+* C PROTOTYPE  : void yyvup2rgb565_venum(uint8_t  *p_y,
+*                                 uint8_t  *p_cr,
+*                                 uint8_t  *p_cb,
+*                                 uint8_t  *p_rgb565,
+*                                 uint32_t  length)
+*--------------------------------------------------------------------------
+* REG INPUT    : R0: uint8_t  *p_y
+*                      pointer to the input Y Line
+*                R1: uint8_t  *p_cr
+*                      pointer to the input Cr Line
+*                R2: uint8_t  *p_cb
+*                      pointer to the input Cb Line
+*                R3: uint8_t  *p_rgb565
+*                      pointer to the output RGB Line
+*                R12: uint32_t  length
+*                      width of Line
+*--------------------------------------------------------------------------
+* STACK ARG    : None
+*--------------------------------------------------------------------------
+* REG OUTPUT   : None
+*--------------------------------------------------------------------------
+* MEM INPUT    : p_y      - a line of Y pixels
+*                p_cr     - a line of Cr pixels
+*                p_cb     - a line of Cb pixels
+*                length   - the width of the input line
+*--------------------------------------------------------------------------
+* MEM OUTPUT   : p_rgb565 - the converted rgb pixels
+*--------------------------------------------------------------------------
+* REG AFFECTED : ARM:  R0-R4, R12
+*                NEON: Q0-Q15
+*--------------------------------------------------------------------------
+* STACK USAGE  : none
+*--------------------------------------------------------------------------
+* CYCLES       : none
+*
+*--------------------------------------------------------------------------
+* NOTES        :
+*--------------------------------------------------------------------------
+*/
+.type yyvup2rgb565_venum, %function
+yyvup2rgb565_venum:
+    /*-------------------------------------------------------------------------
+     *  Store stack registers
+     * ------------------------------------------------------------------------ */
+    STMFD SP!, {LR}
+
+    PLD [R0, R3]                       @ preload luma line
+
+    ADR   R12, constants
+
+    VLD1.S16  {D6, D7}, [R12]!         @ D6, D7: 359 |  -88 | -183 | 454 | 256 | 0 | 255 | 0
+    VLD1.S32  {D30, D31}, [R12]        @ Q15   :  -45824    |    34816   |  -57984 |     X
+
+    /*-------------------------------------------------------------------------
+     *  Load the 5th parameter via stack
+     *  R0 ~ R3 are used to pass the first 4 parameters, the 5th and above
+     *  parameters are passed via stack
+     * ------------------------------------------------------------------------ */
+    LDR R12, [SP, #4]                  @ LR is the only one that has been pushed
+                                       @ into stack, increment SP by 4 to
+                                       @ get the parameter.
+                                       @ LDMIB SP, {R12} is an equivalent
+                                       @ instruction in this case, where only
+                                       @ one register was pushed into stack.
+
+    /*-------------------------------------------------------------------------
+     *  Load clamping parameters to duplicate vector elements
+     * ------------------------------------------------------------------------ */
+    VDUP.S16  Q4,  D7[1]               @ Q4:  0  |  0  |  0  |  0  |  0  |  0  |  0  |  0
+    VDUP.S16  Q5,  D7[2]               @ Q5: 255 | 255 | 255 | 255 | 255 | 255 | 255 | 255
+
+    /*-------------------------------------------------------------------------
+     *  Read bias
+     * ------------------------------------------------------------------------ */
+    VDUP.S32  Q0,   D30[0]             @ Q0:  -45824 | -45824 | -45824 | -45824
+    VDUP.S32  Q1,   D30[1]             @ Q1:   34816 |  34816 |  34816 |  34816
+    VDUP.S32  Q2,   D31[0]             @ Q2:  -70688 | -70688 | -70688 | -70688
+
+
+    /*-------------------------------------------------------------------------
+     *  The main loop
+     * ------------------------------------------------------------------------ */
+loop_yyvup2rgb565:
+
+    /*-------------------------------------------------------------------------
+     *  Load input from Y, V and U
+     *  D12, D13: Y0 Y2 Y4 Y6 Y8 Y10 Y12 Y14, Y1 Y3 Y5 Y7 Y9 Y11 Y13 Y15
+     *  D14     : V0 V1 V2 V3 V4 V5  V6  V7
+     *  D15     : U0 U1 U2 U3 U4 U5  U6  U7
+     * ------------------------------------------------------------------------ */
+    VLD2.U8  {D12,D13}, [p_y]!         @ Load 16 Luma elements (uint8) to D12, D13
+    VLD1.U8  {D14},     [p_cr]!        @ Load 8 Cr elements (uint8) to D14
+    VLD1.U8  {D15},     [p_cb]!        @ Load 8 Cb elements (uint8) to D15
+
+    /*-------------------------------------------------------------------------
+     *  Expand uint8 value to uint16
+     *  D24, D25: Y0 Y2 Y4 Y6 Y8 Y10 Y12 Y14
+     *  D26, D27: Y1 Y3 Y5 Y7 Y9 Y11 Y13 Y15
+     *  D28, D29: V0 V1 V2 V3 V4 V5  V6  V7
+     *  D30, D31: U0 U1 U2 U3 U4 U5  U6  U7
+     * ------------------------------------------------------------------------ */
+    VMOVL.U8 Q12, D12
+    VMOVL.U8 Q13, D13
+    VMOVL.U8 Q14, D14
+    VMOVL.U8 Q15, D15
+
+    /*-------------------------------------------------------------------------
+     *  Multiply contribution from chrominance, results are in 32-bit
+     * ------------------------------------------------------------------------ */
+    VMULL.S16  Q6, D28, D6[0]          @ Q6:  359*(V0,V1,V2,V3)     Red
+    VMULL.S16  Q7, D30, D6[1]          @ Q7:  -88*(U0,U1,U2,U3)     Green
+    VMLAL.S16  Q7, D28, D6[2]          @ q7:  -88*(U0,U1,U2,U3) - 183*(V0,V1,V2,V3)
+    VMULL.S16  Q8, D30, D6[3]          @ q8:  454*(U0,U1,U2,U3)     Blue
+
+    /*-------------------------------------------------------------------------
+     *  Add bias
+     * ------------------------------------------------------------------------ */
+    VADD.S32  Q6, Q0                   @ Q6 add Red   bias -45824
+    VADD.S32  Q7, Q1                   @ Q7 add Green bias  34816
+    VADD.S32  Q8, Q2                   @ Q8 add Blue  bias -57984
+
+    /*-------------------------------------------------------------------------
+     *  Calculate Red, Green, Blue
+     * ------------------------------------------------------------------------ */
+    VMOV.S32   Q9, Q6
+    VMLAL.S16  Q6, D24, D7[0]          @ Q6: R0, R2, R4, R6 in 32-bit Q8 format
+    VMLAL.S16  Q9, D26, D7[0]          @ Q9: R1, R3, R5, R7 in 32-bit Q8 format
+
+    VMOV.S32   Q10, Q7
+    VMLAL.S16  Q7,  D24, D7[0]         @ Q7:  G0, G2, G4, G6 in 32-bit Q8 format
+    VMLAL.S16  Q10, D26, D7[0]         @ Q10: G1, G3, G5, G7 in 32-bit Q8 format
+
+    VMOV.S32   Q11, Q8
+    VMLAL.S16  Q8,  D24, D7[0]         @ Q8:  B0, B2, B4, B6 in 32-bit Q8 format
+    VMLAL.S16  Q11, D26, D7[0]         @ Q11: B1, B3, B5, B7 in 32-bit Q8 format
+
+    /*-------------------------------------------------------------------------
+     *  Right shift eight bits with rounding
+     * ------------------------------------------------------------------------ */
+    VSHRN.S32   D12, Q6,  #8           @ D12: R0 R2 R4 R6 in 16-bit Q0 format
+    VSHRN.S32   D13, Q9,  #8           @ D13: R1 R3 R5 R7 in 16-bit Q0 format
+    VZIP.16     D12, D13               @ Q6 : R0 R1 R2 R3 R4 R5 R6 R7
+
+    VSHRN.S32   D18, Q7,  #8           @ D18: G0 G2 G4 G6 in 16-bit Q0 format
+    VSHRN.S32   D19, Q10, #8           @ D19: G1 G3 G5 G7 in 16-bit Q0 format
+    VZIP.16     D18, D19               @ Q9 : G0 G1 G2 G3 G4 G5 G6 G7
+
+    VSHRN.S32   D20, Q8,  #8           @ D20: B0 B2 B4 B6 in 16-bit Q0 format
+    VSHRN.S32   D21, Q11, #8           @ D21: B1 B3 B5 B7 in 16-bit Q0 format
+    VZIP.16     D20, D21               @ Q10: B0 B1 B2 B3 B4 B5 B6 B7
+
+    /*-------------------------------------------------------------------------
+     *  Clamp the value to be within [0~255]
+     * ------------------------------------------------------------------------ */
+    VMAX.S16  Q6, Q6, Q4               @ if Q6 <   0, Q6 =   0
+    VMIN.S16  Q6, Q6, Q5               @ if Q6 > 255, Q6 = 255
+    VQMOVUN.S16  D23, Q6               @ store Red to D23, narrow the value from int16 to int8
+
+    VMAX.S16  Q9, Q9, Q4               @ if Q9 <   0, Q9 =   0
+    VMIN.S16  Q9, Q9, Q5               @ if Q9 > 255, Q9 = 255
+    VQMOVUN.S16  D22, Q9               @ store Green to D22, narrow the value from int16 to int8
+
+    VMAX.S16  Q10, Q10, Q4             @ if Q10 <   0, Q10 =   0
+    VMIN.S16  Q10, Q10, Q5             @ if Q10 > 255, Q10 = 255
+    VQMOVUN.S16   D21, Q10             @ store Blue to D21, narrow the value from int16 to int8
+
+    /*-------------------------------------------------------------------------
+     *  D22:  3 bits of Green + 5 bits of Blue
+     *  D23:  5 bits of Red   + 3 bits of Green
+     * ------------------------------------------------------------------------ */
+    VSRI.8   D23, D22, #5              @ right shift G by 5 and insert to R
+    VSHL.U8  D22, D22, #3              @ left shift G by 3
+    VSRI.8   D22, D21, #3              @ right shift B by 3 and insert to G
+
+    SUBS length, length, #8            @ check if the length is less than 8
+
+    BMI  trailing_yyvup2rgb565         @ jump to trailing processing if remaining length is less than 8
+
+    VST2.U8  {D22,D23}, [p_rgb]!       @ vector store Red, Green, Blue to destination
+                                       @ Blue at LSB
+
+    BEQ  end_yyvup2rgb565              @ done if exactly 8 pixel processed in the loop
+
+
+    /*-------------------------------------------------------------------------
+     *  Done with the first 8 elements, continue on the next 8 elements
+     * ------------------------------------------------------------------------ */
+
+    /*-------------------------------------------------------------------------
+     *  Multiply contribution from chrominance, results are in 32-bit
+     * ------------------------------------------------------------------------ */
+    VMULL.S16  Q6, D29, D6[0]          @ Q6: 359*(V4,V5,V6,V7)       Red
+    VMULL.S16  Q7, D31, D6[1]          @ Q7: -88*(U4,U5,U6,U7)      Green
+    VMLAL.S16  Q7, D29, D6[2]          @ Q7: -88*(U4,U5,U6,U7) - 183*(V4,V5,V6,V7)
+    VMULL.S16  Q8, D31, D6[3]          @ Q8: 454*(U4,U5,U6,U7)       Blue
+
+    /*-------------------------------------------------------------------------
+     *  Add bias
+     * ------------------------------------------------------------------------ */
+    VADD.S32  Q6, Q0                   @ Q6 add Red   bias -45824
+    VADD.S32  Q7, Q1                   @ Q7 add Green bias  34816
+    VADD.S32  Q8, Q2                   @ Q8 add Blue  bias -57984
+
+    /*-------------------------------------------------------------------------
+     *  Calculate Red, Green, Blue
+     * ------------------------------------------------------------------------ */
+    VMOV.S32   Q9, Q6
+    VMLAL.S16  Q6, D25, D7[0]          @ Q6: R8 R10 R12 R14 in 32-bit Q8 format
+    VMLAL.S16  Q9, D27, D7[0]          @ Q9: R9 R11 R13 R15 in 32-bit Q8 format
+
+    VMOV.S32   Q10, Q7
+    VMLAL.S16  Q7,  D25, D7[0]         @ Q7: G0, G2, G4, G6 in 32-bit Q8 format
+    VMLAL.S16  Q10, D27, D7[0]         @ Q10 : G1, G3, G5, G7 in 32-bit Q8 format
+
+    VMOV.S32   Q11, Q8
+    VMLAL.S16  Q8,  D25, D7[0]         @ Q8: B0, B2, B4, B6 in 32-bit Q8 format
+    VMLAL.S16  Q11, D27, D7[0]         @ Q11 : B1, B3, B5, B7 in 32-bit Q8 format
+
+    /*-------------------------------------------------------------------------
+     *  Right shift eight bits with rounding
+     * ------------------------------------------------------------------------ */
+    VSHRN.S32   D12, Q6,  #8           @ D12: R8 R10 R12 R14 in 16-bit Q0 format
+    VSHRN.S32   D13, Q9,  #8           @ D13: R9 R11 R13 R15 in 16-bit Q0 format
+    VZIP.16     D12, D13               @ Q6: R8 R9 R10 R11 R12 R13 R14 R15
+
+    VSHRN.S32   D18, Q7,  #8           @ D18: G8 G10 G12 G14 in 16-bit Q0 format
+    VSHRN.S32   D19, Q10, #8           @ D19: G9 G11 G13 G15 in 16-bit Q0 format
+    VZIP.16     D18, D19               @ Q9:  G8 G9 G10 G11 G12 G13 G14 G15
+
+    VSHRN.S32   D20, Q8,  #8           @ D20: B8 B10 B12 B14 in 16-bit Q0 format
+    VSHRN.S32   D21, Q11, #8           @ D21: B9 B11 B13 B15 in 16-bit Q0 format
+    VZIP.16     D20, D21               @ Q10: B8 B9 B10 B11 B12 B13 B14 B15
+
+    /*-------------------------------------------------------------------------
+     *  Clamp the value to be within [0~255]
+     * ------------------------------------------------------------------------ */
+    VMAX.S16  Q6, Q6, Q4               @ if Q6 <   0, Q6 =   0
+    VMIN.S16  Q6, Q6, Q5               @ if Q6 > 255, Q6 = 255
+    VQMOVUN.S16  D23, Q6               @ store Red to D23, narrow the value from int16 to int8
+
+    VMAX.S16  Q9, Q9, Q4               @ if Q9 <   0, Q9 =   0
+    VMIN.S16  Q9, Q9, Q5               @ if Q9 > 255, Q9 = 255
+    VQMOVUN.S16  D22, Q9               @ store Green to D22, narrow the value from int16 to int8
+
+    VMAX.S16  Q10, Q10, Q4             @ if Q10 <   0, Q10 =   0
+    VMIN.S16  Q10, Q10, Q5             @ if Q10 > 255, Q10 = 255
+    VQMOVUN.S16   D21, Q10             @ store Blue to D21, narrow the value from int16 to int8
+
+    /*-------------------------------------------------------------------------
+     *  D22:  3 bits of Green + 5 bits of Blue
+     *  D23:  5 bits of Red   + 3 bits of Green
+     * ------------------------------------------------------------------------ */
+    VSRI.8   D23, D22, #5              @ right shift G by 5 and insert to R
+    VSHL.U8  D22, D22, #3              @ left shift G by 3
+    VSRI.8   D22, D21, #3              @ right shift B by 3 and insert to G
+
+    SUBS length, length, #8            @ check if the length is less than 8
+
+    BMI  trailing_yyvup2rgb565         @ jump to trailing processing if remaining length is less than 8
+
+    VST2.U8  {D22,D23}, [p_rgb]!       @ vector store Red, Green, Blue to destination
+                                       @ Blue at LSB
+
+    BHI loop_yyvup2rgb565              @ loop if more than 8 pixels left
+
+    BEQ  end_yyvup2rgb565              @ done if exactly 8 pixel processed in the loop
+
+
+trailing_yyvup2rgb565:
+    /*-------------------------------------------------------------------------
+     *  There are from 1 ~ 7 pixels left in the trailing part.
+     *  First adding 7 to the length so the length would be from 0 ~ 6.
+     *  eg: 1 pixel left in the trailing part, so 1-8+7 = 0.
+     *  Then save 1 pixel unconditionally since at least 1 pixels left in the
+     *  trailing part.
+     * ------------------------------------------------------------------------ */
+    ADDS length, length, #7            @ there are 7 or less in the trailing part
+
+    VST2.U8 {D22[0],D23[0]}, [p_rgb]!  @ at least 1 pixel left in the trailing part
+    BEQ end_yyvup2rgb565               @ done if 0 pixel left
+
+    SUBS length, length, #1            @ update length counter
+    VST2.U8 {D22[1],D23[1]}, [p_rgb]!  @ store one more pixel
+    BEQ end_yyvup2rgb565               @ done if 0 pixel left
+
+    SUBS length, length, #1            @ update length counter
+    VST2.U8 {D22[2],D23[2]}, [p_rgb]!  @ store one more pixel
+    BEQ end_yyvup2rgb565               @ done if 0 pixel left
+
+    SUBS length, length, #1            @ update length counter
+    VST2.U8 {D22[3],D23[3]}, [p_rgb]!  @ store one more pixel
+    BEQ end_yyvup2rgb565               @ done if 0 pixel left
+
+    SUBS length, length, #1            @ update length counter
+    VST2.U8 {D22[4],D23[4]}, [p_rgb]!  @ store one more pixel
+    BEQ end_yyvup2rgb565               @ done if 0 pixel left
+
+    SUBS length, length, #1            @ update length counter
+    VST2.U8 {D22[5],D23[5]}, [p_rgb]!  @ store one more pixel
+    BEQ end_yyvup2rgb565               @ done if 0 pixel left
+
+    SUBS length, length, #1            @ update length counter
+    VST2.U8 {D22[6],D23[6]}, [p_rgb]!  @ store one more pixel
+
+end_yyvup2rgb565:
+    LDMFD SP!, {PC}
+
+                                       @ end of yyvup2rgb565
+
+constants:
+    .hword (COEFF_V_RED),  (COEFF_U_GREEN), (COEFF_V_GREEN), (COEFF_U_BLUE) @   359  | -88   |  -183  | 454
+    .hword (COEFF_Y),      (COEFF_0),       (COEFF_255)    , (COEFF_0)      @   256  |   0   |   255  |  0
+    .word  (COEFF_BIAS_R), (COEFF_BIAS_G),  (COEFF_BIAS_B)                  @ -45824 | 34816 | -57984 |  X
+
+.end
diff -Nurp vlc-a/modules/arm_neon/yuv2rgb.444565.S vlc-b/modules/arm_neon/yuv2rgb.444565.S
--- vlc-a/modules/arm_neon/yuv2rgb.444565.S	1970-01-01 08:00:00.000000000 +0800
+++ vlc-b/modules/arm_neon/yuv2rgb.444565.S	2011-07-10 01:53:48.997262156 +0800
@@ -0,0 +1,328 @@
+/*------------------------------------------------------------------------
+* jdcolor-armv7.s
+*
+*  Copyright (c) 2010, Code Aurora Forum. All rights reserved.
+*
+*  Redistribution and use in source and binary forms, with or without
+*  modification, are permitted provided that the following conditions are
+*  met:
+*      * Redistributions of source code must retain the above copyright
+*        notice, this list of conditions and the following disclaimer.
+*      * Redistributions in binary form must reproduce the above
+*        copyright notice, this list of conditions and the following
+*        disclaimer in the documentation and/or other materials provided
+*        with the distribution.
+*      * Neither the name of Code Aurora Forum, Inc. nor the names of its
+*        contributors may be used to endorse or promote products derived
+*        from this software without specific prior written permission.
+*
+*  THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+*  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+*  ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+*  BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+*  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+*  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+*  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+*  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+*  OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+*  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*--------------------------------------------------------------------------
+
+*--------------------------------------------------------------------------
+*                         FUNCTION LIST
+*--------------------------------------------------------------------------
+*
+* - yvup2rgb565_venum
+* - yyvup2rgb565_venum
+*
+*--------------------------------------------------------------------------
+*/
+
+    .section yvu_plain_to_rgb565, "x"  @ AREA
+    .text                              @ |.text|, CODE, READONLY
+    .align 2
+    .code  32                          @ CODE32
+
+/*-----------------------------------------------------------------------------
+ *   ARM Registers
+ * ---------------------------------------------------------------------------- */
+p_y       .req r0
+p_cr      .req r1
+p_cb      .req r2
+p_rgb     .req r3
+p_bgr     .req r3
+length    .req r12
+
+    .global yvup2rgb565_venum
+
+@ coefficients in color conversion matrix multiplication
+.equ COEFF_Y,          256             @ contribution of Y
+.equ COEFF_V_RED,      359             @ contribution of V for red
+.equ COEFF_U_GREEN,    -88             @ contribution of U for green
+.equ COEFF_V_GREEN,   -183             @ contribution of V for green
+.equ COEFF_U_BLUE,     454             @ contribution of U for blue
+
+@ Clamping constants 0x0 and 0xFF
+.equ COEFF_0,          0
+.equ COEFF_255,        255
+
+@ Bias coefficients for red, green and blue
+.equ COEFF_BIAS_R,   -45824            @ Red   bias =     -359*128 + 128
+.equ COEFF_BIAS_G,    34816            @ Green bias = (88+183)*128 + 128
+.equ COEFF_BIAS_B,   -57984            @ Blue  bias =     -454*128 + 128
+
+
+/*--------------------------------------------------------------------------
+* FUNCTION     : yvup2rgb565_venum
+*--------------------------------------------------------------------------
+* DESCRIPTION  : Perform YVU planar to RGB565 conversion.
+*--------------------------------------------------------------------------
+* C PROTOTYPE  : void yvup2rgb565_venum(uint8_t  *p_y,
+*                                 uint8_t  *p_cr,
+*                                 uint8_t  *p_cb,
+*                                 uint8_t  *p_rgb565,
+*                                 uint32_t  length)
+*--------------------------------------------------------------------------
+* REG INPUT    : R0: uint8_t  *p_y
+*                      pointer to the input Y Line
+*                R1: uint8_t  *p_cr
+*                      pointer to the input Cr Line
+*                R2: uint8_t  *p_cb
+*                      pointer to the input Cb Line
+*                R3: uint8_t  *p_rgb565
+*                      pointer to the output RGB Line
+*                R12: uint32_t  length
+*                      width of Line
+*--------------------------------------------------------------------------
+* STACK ARG    : None
+*--------------------------------------------------------------------------
+* REG OUTPUT   : None
+*--------------------------------------------------------------------------
+* MEM INPUT    : p_y      - a line of Y pixels
+*                p_cr     - a line of Cr pixels
+*                p_cb     - a line of Cb pixels
+*                length   - the width of the input line
+*--------------------------------------------------------------------------
+* MEM OUTPUT   : p_rgb565 - the converted rgb pixels
+*--------------------------------------------------------------------------
+* REG AFFECTED : ARM:  R0-R4, R12
+*                NEON: Q0-Q15
+*--------------------------------------------------------------------------
+* STACK USAGE  : none
+*--------------------------------------------------------------------------
+* CYCLES       : none
+*
+*--------------------------------------------------------------------------
+* NOTES        :
+*--------------------------------------------------------------------------
+*/
+.type yvup2rgb565_venum, %function
+yvup2rgb565_venum:
+    /*-------------------------------------------------------------------------
+     *  Store stack registers
+     * ------------------------------------------------------------------------ */
+    STMFD SP!, {LR}
+
+    PLD [R0, R3]                       @ preload luma line
+
+    ADR   R12, constants
+
+    VLD1.S16  {D6, D7}, [R12]!         @ D6, D7: 359 |  -88 | -183 | 454 | 256 | 0 | 255 | 0
+    VLD1.S32  {D30, D31}, [R12]        @ Q15   :  -45824    |    34816   |  -57984 |     X
+
+    /*-------------------------------------------------------------------------
+     *  Load the 5th parameter via stack
+     *  R0 ~ R3 are used to pass the first 4 parameters, the 5th and above
+     *  parameters are passed via stack
+     * ------------------------------------------------------------------------ */
+    LDR R12, [SP, #4]                  @ LR is the only one that has been pushed
+                                       @ into stack, increment SP by 4 to
+                                       @ get the parameter.
+                                       @ LDMIB SP, {R12} is an equivalent
+                                       @ instruction in this case, where only
+                                       @ one register was pushed into stack.
+
+    /*-------------------------------------------------------------------------
+     *  Load clamping parameters to duplicate vector elements
+     * ------------------------------------------------------------------------ */
+    VDUP.S16  Q4,  D7[1]               @ Q4:  0  |  0  |  0  |  0  |  0  |  0  |  0  |  0
+    VDUP.S16  Q5,  D7[2]               @ Q5: 255 | 255 | 255 | 255 | 255 | 255 | 255 | 255
+
+    /*-------------------------------------------------------------------------
+     *  Read bias
+     * ------------------------------------------------------------------------ */
+    VDUP.S32  Q0,   D30[0]             @ Q0:  -45824 | -45824 | -45824 | -45824
+    VDUP.S32  Q1,   D30[1]             @ Q1:   34816 |  34816 |  34816 |  34816
+    VDUP.S32  Q2,   D31[0]             @ Q2:  -70688 | -70688 | -70688 | -70688
+
+
+    /*-------------------------------------------------------------------------
+     *  The main loop
+     * ------------------------------------------------------------------------ */
+loop_yvup2rgb565:
+
+    /*-------------------------------------------------------------------------
+     *  Load input from Y, V and U
+     *  D12  : Y0  Y1  Y2  Y3  Y4  Y5  Y6  Y7
+     *  D14  : V0  V1  V2  V3  V4  V5  V6  V7
+     *  D15  : U0  U1  U2  U3  U4  U5  U6  U7
+     * ------------------------------------------------------------------------ */
+    VLD1.U8  {D12},  [p_y]!            @ Load 8 Y  elements (uint8) to D12
+    VLD1.U8  {D14},  [p_cr]!           @ Load 8 Cr elements (uint8) to D14
+    VLD1.U8  {D15},  [p_cb]!           @ Load 8 Cb elements (uint8) to D15
+
+    /*-------------------------------------------------------------------------
+     *  Expand uint8 value to uint16
+     *  D18, D19: Y0 Y1 Y2 Y3 Y4 Y5 Y6 Y7
+     *  D20, D21: V0 V1 V2 V3 V4 V5 V6 V7
+     *  D22, D23: U0 U1 U2 U3 U4 U5 U6 U7
+     * ------------------------------------------------------------------------ */
+    VMOVL.U8 Q9,  D12
+    VMOVL.U8 Q10, D14
+    VMOVL.U8 Q11, D15
+
+    /*-------------------------------------------------------------------------
+     *  Multiply contribution from chrominance, results are in 32-bit
+     * ------------------------------------------------------------------------ */
+    VMULL.S16  Q12, D20, D6[0]         @ Q12:  359*(V0,V1,V2,V3)     Red
+    VMULL.S16  Q13, D22, D6[1]         @ Q13:  -88*(U0,U1,U2,U3)     Green
+    VMLAL.S16  Q13, D20, D6[2]         @ Q13:  -88*(U0,U1,U2,U3) - 183*(V0,V1,V2,V3)
+    VMULL.S16  Q14, D22, D6[3]         @ Q14:  454*(U0,U1,U2,U3)     Blue
+
+    /*-------------------------------------------------------------------------
+     *  Add bias
+     * ------------------------------------------------------------------------ */
+    VADD.S32  Q12, Q0                  @ Q12 add Red   bias -45824
+    VADD.S32  Q13, Q1                  @ Q13 add Green bias  34816
+    VADD.S32  Q14, Q2                  @ Q14 add Blue  bias -57984
+
+    /*-------------------------------------------------------------------------
+     *  Calculate Red, Green, Blue
+     * ------------------------------------------------------------------------ */
+    VMLAL.S16  Q12, D18, D7[0]         @ Q12: R0, R1, R2, R3 in 32-bit Q8 format
+    VMLAL.S16  Q13, D18, D7[0]         @ Q13: G0, G1, G2, G3 in 32-bit Q8 format
+    VMLAL.S16  Q14, D18, D7[0]         @ Q14: B0, B1, B2, B3 in 32-bit Q8 format
+
+    /*-------------------------------------------------------------------------
+     *  Right shift eight bits with rounding
+     * ------------------------------------------------------------------------ */
+    VSHRN.S32   D18 , Q12, #8          @ D18: R0, R1, R2, R3 in 16-bit Q0 format
+    VSHRN.S32   D20 , Q13, #8          @ D20: G0, G1, G2, G3 in 16-bit Q0 format
+    VSHRN.S32   D22,  Q14, #8          @ D22: B0, B1, B2, B3 in 16-bit Q0 format
+
+    /*-------------------------------------------------------------------------
+     *  Done with the first 4 elements, continue on the next 4 elements
+     * ------------------------------------------------------------------------ */
+
+    /*-------------------------------------------------------------------------
+     *  Multiply contribution from chrominance, results are in 32-bit
+     * ------------------------------------------------------------------------ */
+    VMULL.S16  Q12, D21, D6[0]         @ Q12:  359*(V0,V1,V2,V3)     Red
+    VMULL.S16  Q13, D23, D6[1]         @ Q13:  -88*(U0,U1,U2,U3)     Green
+    VMLAL.S16  Q13, D21, D6[2]         @ Q13:  -88*(U0,U1,U2,U3) - 183*(V0,V1,V2,V3)
+    VMULL.S16  Q14, D23, D6[3]         @ Q14:  454*(U0,U1,U2,U3)     Blue
+
+    /*-------------------------------------------------------------------------
+     *  Add bias
+     * ------------------------------------------------------------------------ */
+    VADD.S32  Q12, Q0                  @ Q12 add Red   bias -45824
+    VADD.S32  Q13, Q1                  @ Q13 add Green bias  34816
+    VADD.S32  Q14, Q2                  @ Q14 add Blue  bias -57984
+
+    /*-------------------------------------------------------------------------
+     *  Calculate Red, Green, Blue
+     * ------------------------------------------------------------------------ */
+    VMLAL.S16  Q12, D19, D7[0]         @ Q12: R0, R1, R2, R3 in 32-bit Q8 format
+    VMLAL.S16  Q13, D19, D7[0]         @ Q13: G0, G1, G2, G3 in 32-bit Q8 format
+    VMLAL.S16  Q14, D19, D7[0]         @ Q14: B0, B1, B2, B3 in 32-bit Q8 format
+
+    /*-------------------------------------------------------------------------
+     *  Right shift eight bits with rounding
+     * ------------------------------------------------------------------------ */
+    VSHRN.S32   D19 , Q12, #8          @ D18: R0, R1, R2, R3 in 16-bit Q0 format
+    VSHRN.S32   D21 , Q13, #8          @ D20: G0, G1, G2, G3 in 16-bit Q0 format
+    VSHRN.S32   D23,  Q14, #8          @ D22: B0, B1, B2, B3 in 16-bit Q0 format
+
+    /*-------------------------------------------------------------------------
+     *  Clamp the value to be within [0~255]
+     * ------------------------------------------------------------------------ */
+    VMAX.S16  Q9, Q9, Q4               @ if Q9 <   0, Q9 =   0
+    VMIN.S16  Q9, Q9, Q5               @ if Q9 > 255, Q9 = 255
+    VQMOVUN.S16  D28, Q9               @ store Red to D28, narrow the value from int16 to int8
+
+    VMAX.S16  Q10, Q10, Q4             @ if Q10 <   0, Q10 =   0
+    VMIN.S16  Q10, Q10, Q5             @ if Q10 > 255, Q10 = 255
+    VQMOVUN.S16   D27, Q10             @ store Green to D27, narrow the value from int16 to int8
+
+    VMAX.S16  Q11, Q11, Q4             @ if Q11 <   0, Q11 =   0
+    VMIN.S16  Q11, Q11, Q5             @ if Q11 > 255, Q11 = 255
+    VQMOVUN.S16   D26, Q11             @ store Blue to D26, narrow the value from int16 to int8.
+
+    /*-------------------------------------------------------------------------
+     *  D27:  3 bits of Green + 5 bits of Blue
+     *  D28:  5 bits of Red   + 3 bits of Green
+     * ------------------------------------------------------------------------ */
+    VSRI.8   D28, D27, #5              @ right shift G by 5 and insert to R
+    VSHL.U8  D27, D27, #3              @ left  shift G by 3
+    VSRI.8   D27, D26, #3              @ right shift B by 3 and insert to G
+
+    SUBS length, length, #8            @ check if the length is less than 8
+
+    BMI  trailing_yvup2rgb565          @ jump to trailing processing if remaining length is less than 8
+
+    VST2.U8  {D27, D28}, [p_rgb]!      @ vector store Red, Green, Blue to destination
+                                       @ Blue at LSB
+
+    BHI loop_yvup2rgb565               @ loop if more than 8 pixels left
+
+    BEQ  end_yvup2rgb565               @ done if exactly 8 pixel processed in the loop
+
+
+trailing_yvup2rgb565:
+    /*-------------------------------------------------------------------------
+     *  There are from 1 ~ 7 pixels left in the trailing part.
+     *  First adding 7 to the length so the length would be from 0 ~ 6.
+     *  eg: 1 pixel left in the trailing part, so 1-8+7 = 0.
+     *  Then save 1 pixel unconditionally since at least 1 pixels left in the
+     *  trailing part.
+     * ------------------------------------------------------------------------ */
+    ADDS length, length, #7            @ there are 7 or less in the trailing part
+
+    VST2.U8 {D27[0], D28[0]}, [p_rgb]! @ at least 1 pixel left in the trailing part
+    BEQ  end_yvup2rgb565               @ done if 0 pixel left
+
+    SUBS length, length, #1            @ update length counter
+    VST2.U8 {D27[1], D28[1]}, [p_rgb]! @ store one more pixel
+    BEQ  end_yvup2rgb565               @ done if 0 pixel left
+
+    SUBS length, length, #1            @ update length counter
+    VST2.U8 {D27[2], D28[2]}, [p_rgb]! @ store one more pixel
+    BEQ  end_yvup2rgb565               @ done if 0 pixel left
+
+    SUBS length, length, #1            @ update length counter
+    VST2.U8 {D27[3], D28[3]}, [p_rgb]! @ store one more pixel
+    BEQ  end_yvup2rgb565               @ done if 0 pixel left
+
+    SUBS length, length, #1            @ update length counter
+    VST2.U8 {D27[4], D28[4]}, [p_rgb]! @ store one more pixel
+    BEQ  end_yvup2rgb565               @ done if 0 pixel left
+
+    SUBS length, length, #1            @ update length counter
+    VST2.U8 {D27[5], D28[5]}, [p_rgb]! @ store one more pixel
+    BEQ  end_yvup2rgb565               @ done if 0 pixel left
+
+    SUBS length, length, #1            @ update length counter
+    VST2.U8 {D27[6], D28[6]}, [p_rgb]! @ store one more pixel
+
+end_yvup2rgb565:
+    LDMFD SP!, {PC}
+
+                                       @ end of yvup2rgb565
+
+constants:
+    .hword (COEFF_V_RED),  (COEFF_U_GREEN), (COEFF_V_GREEN), (COEFF_U_BLUE) @   359  | -88   |  -183  | 454
+    .hword (COEFF_Y),      (COEFF_0),       (COEFF_255)    , (COEFF_0)      @   256  |   0   |   255  |  0
+    .word  (COEFF_BIAS_R), (COEFF_BIAS_G),  (COEFF_BIAS_B)                  @ -45824 | 34816 | -57984 |  X
+
+.end
diff -Nurp vlc-a/modules/arm_neon/yuv2rgb.c vlc-b/modules/arm_neon/yuv2rgb.c
--- vlc-a/modules/arm_neon/yuv2rgb.c	1970-01-01 08:00:00.000000000 +0800
+++ vlc-b/modules/arm_neon/yuv2rgb.c	2011-07-10 01:53:48.997262156 +0800
@@ -0,0 +1,289 @@
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <vlc_common.h>
+#include <vlc_plugin.h>
+#include <vlc_filter.h>
+
+#include "yuv2rgb.h"
+
+static int Activate(vlc_object_t *);
+static void Deactivate(vlc_object_t *);
+
+vlc_module_begin ()
+    set_description(("YUV to RGB conversions using yuv2rgb from theorarm, qcomm and mozilla"))
+#ifdef ANDROID
+    set_capability("video filter2", 160)
+#else
+    set_capability("video filter2", 0)
+#endif
+    set_callbacks(Activate, Deactivate)
+vlc_module_end ()
+
+static picture_t *yuv420_rgb565_filter(filter_t *, picture_t *);
+static picture_t *yuv422_rgb565_filter(filter_t *, picture_t *);
+static picture_t *yuv444_rgb565_filter(filter_t *, picture_t *);
+
+static int Activate(vlc_object_t *p_this) {
+    filter_t *p_filter = (filter_t *)p_this;
+
+    if (p_filter->fmt_out.video.i_chroma != VLC_CODEC_RGB16)
+        return VLC_EGENERIC;
+    // TODO: use pixman to resize
+    if (p_filter->fmt_in.video.i_width != p_filter->fmt_out.video.i_width)
+        return VLC_EGENERIC;
+    if (p_filter->fmt_in.video.i_height != p_filter->fmt_out.video.i_height)
+        return VLC_EGENERIC;
+    switch (p_filter->fmt_in.video.i_chroma) {
+        case VLC_CODEC_YV12:
+        case VLC_CODEC_I420:
+            p_filter->pf_video_filter = yuv420_rgb565_filter;
+            break;
+        // XXX: add I444 and I422
+        //case VLC_CODEC_YUVA:
+        //    p_filter->pf_video_filter = yuv444_rgb565_filter;
+        //    break;
+        default:
+            return VLC_EGENERIC;
+    }
+
+    return VLC_SUCCESS;
+}
+
+static void Deactivate( vlc_object_t *p_this ) {
+}
+
+#if HAVE_NEON
+
+void yvup2rgb565_venum(uint8_t  *p_y,
+                    uint8_t  *p_cr,
+                    uint8_t  *p_cb,
+                    uint8_t  *p_rgb565,
+                    uint32_t  length);
+
+void yyvup2rgb565_venum(uint8_t  *p_y,
+                    uint8_t  *p_cr,
+                    uint8_t  *p_cb,
+                    uint8_t  *p_rgb565,
+                    uint32_t  length);
+
+void yuv444_2_rgb565_aurora(uint8_t  *dst_ptr,
+               const uint8_t  *y_ptr,
+               const uint8_t  *u_ptr,
+               const uint8_t  *v_ptr,
+                     int32_t   pic_width,
+                     int32_t   pic_height,
+                     int32_t   y_pitch,
+                     int32_t   uv_pitch,
+                     int32_t   dst_pitch) {
+    for (int i = 0; i < pic_height; i++) {
+        yvup2rgb565_venum((uint8_t*)(y_ptr + y_pitch * i),
+                         (uint8_t*)(u_ptr + uv_pitch * i),
+                         (uint8_t*)(v_ptr + uv_pitch * i),
+                         (uint8_t*)(dst_ptr + dst_pitch * i),
+                         pic_width);
+    }
+}
+
+// XXX: Is this correct?
+void yuv422_2_rgb565_aurora(uint8_t  *dst_ptr,
+               const uint8_t  *y_ptr,
+               const uint8_t  *u_ptr,
+               const uint8_t  *v_ptr,
+                     int32_t   pic_width,
+                     int32_t   pic_height,
+                     int32_t   y_pitch,
+                     int32_t   uv_pitch,
+                     int32_t   dst_pitch) {
+    for (int i = 0; i < pic_height; i++) {
+        yyvup2rgb565_venum((uint8_t*)(y_ptr + y_pitch * i),
+                         (uint8_t*)(u_ptr + uv_pitch * i / 2),
+                         (uint8_t*)(v_ptr + uv_pitch * i / 2),
+                         (uint8_t*)(dst_ptr + dst_pitch * i),
+                         pic_width);
+    }
+}
+
+void __attribute((noinline)) yv12_to_rgb565_neon(uint16_t *dst, const uint8_t *y, const uint8_t *u, const uint8_t *v, int n, int oddflag);
+
+void yuv420_2_rgb565_mozilla(uint8_t  *dst_ptr,
+               const uint8_t  *y_ptr,
+               const uint8_t  *u_ptr,
+               const uint8_t  *v_ptr,
+                     int32_t   pic_width,
+                     int32_t   pic_height,
+                     int32_t   y_pitch,
+                     int32_t   uv_pitch,
+                     int32_t   dst_pitch) {
+    for (int i = 0; i < pic_height; i++) {
+        yv12_to_rgb565_neon((uint16_t*)(dst_ptr + dst_pitch * i),
+                         y_ptr + y_pitch * i,
+                         u_ptr + uv_pitch * (i / 2),
+                         v_ptr + uv_pitch * (i / 2),
+                         pic_width,
+                         0);
+    }
+}
+
+#endif
+
+// static mtime_t total = 0;
+// static int count = 0;
+
+static picture_t *yuv420_rgb565_filter(filter_t *p_filter, picture_t *p_pic) {
+    int width, height;
+    picture_t *p_dst;
+
+    // mtime_t bgn = mdate();
+    if (!p_pic)
+        return NULL;
+
+    p_dst = filter_NewPicture(p_filter);
+    if (!p_dst) {
+        picture_Release(p_pic);
+        return NULL;
+    }
+
+    width = p_filter->fmt_in.video.i_width;
+    height = p_filter->fmt_in.video.i_height;
+
+#ifdef HAVE_NEON
+    yuv420_2_rgb565_mozilla(
+        p_dst->p[0].p_pixels,   // dst ptr
+        p_pic->Y_PIXELS,        // y
+        p_pic->U_PIXELS,        // u
+        p_pic->V_PIXELS,        // v
+        width,                  // width
+        height,                 // height
+        p_pic->Y_PITCH,         // y stride
+        p_pic->U_PITCH,         // uv stride
+        p_dst->p[0].i_pitch     // dst stride
+        );
+#else
+    yuv420_2_rgb565(
+        p_dst->p[0].p_pixels,   // dst ptr
+        p_pic->Y_PIXELS,        // y
+        p_pic->U_PIXELS,        // u
+        p_pic->V_PIXELS,        // v
+        width,                  // width
+        height,                 // height
+        p_pic->Y_PITCH,         // y stride
+        p_pic->U_PITCH,         // uv stride
+        p_dst->p[0].i_pitch,    // dst stride
+        yuv2rgb565_table,       // table
+        0                       // dither
+    );
+#endif
+
+    picture_CopyProperties(p_dst, p_pic);
+    picture_Release(p_pic);
+    // mtime_t end = mdate();
+    // total += (end - bgn);
+    // count += 1;
+    // msg_Dbg(VLC_OBJECT(p_filter), "%s takes %lld us, average %lld", __func__, end - bgn, total / count);
+
+    return p_dst;
+}
+
+static picture_t *yuv422_rgb565_filter(filter_t *p_filter, picture_t *p_pic) {
+    int width, height;
+    picture_t *p_dst;
+
+    if (!p_pic)
+        return NULL;
+
+    p_dst = filter_NewPicture(p_filter);
+    if (!p_dst) {
+        picture_Release(p_pic);
+        return NULL;
+    }
+
+    width = p_filter->fmt_in.video.i_width;
+    height = p_filter->fmt_in.video.i_height;
+
+#ifdef HAVE_NEON
+    yuv422_2_rgb565_aurora(
+        p_dst->p[0].p_pixels,   // dst ptr
+        p_pic->Y_PIXELS,        // y
+        p_pic->U_PIXELS,        // u
+        p_pic->V_PIXELS,        // v
+        width,                  // width
+        height,                 // height
+        p_pic->Y_PITCH,         // y stride
+        p_pic->U_PITCH,         // uv stride
+        p_dst->p[0].i_pitch     // dst stride
+        );
+#else
+    yuv422_2_rgb565(
+        p_dst->p[0].p_pixels,   // dst ptr
+        p_pic->Y_PIXELS,        // y
+        p_pic->U_PIXELS,        // u
+        p_pic->V_PIXELS,        // v
+        width,                  // width
+        height,                 // height
+        p_pic->Y_PITCH,         // y stride
+        p_pic->U_PITCH,         // uv stride
+        p_dst->p[0].i_pitch,    // dst stride
+        yuv2rgb565_table,       // table
+        0                       // dither
+    );
+#endif
+
+    picture_CopyProperties(p_dst, p_pic);
+    picture_Release(p_pic);
+
+    return p_dst;
+}
+
+static picture_t *yuv444_rgb565_filter(filter_t *p_filter, picture_t *p_pic) {
+    int width, height;
+    picture_t *p_dst;
+
+    if (!p_pic)
+        return NULL;
+
+    p_dst = filter_NewPicture(p_filter);
+    if (!p_dst) {
+        picture_Release(p_pic);
+        return NULL;
+    }
+
+    width = p_filter->fmt_in.video.i_width;
+    height = p_filter->fmt_in.video.i_height;
+
+#ifdef HAVE_NEON
+    yuv444_2_rgb565_aurora(
+        p_dst->p[0].p_pixels,   // dst ptr
+        p_pic->Y_PIXELS,        // y
+        p_pic->U_PIXELS,        // u
+        p_pic->V_PIXELS,        // v
+        width,                  // width
+        height,                 // height
+        p_pic->Y_PITCH,         // y stride
+        p_pic->U_PITCH,         // uv stride
+        p_dst->p[0].i_pitch     // dst stride
+        );
+#else
+    yuv444_2_rgb565(
+        p_dst->p[0].p_pixels,   // dst ptr
+        p_pic->Y_PIXELS,        // y
+        p_pic->U_PIXELS,        // u
+        p_pic->V_PIXELS,        // v
+        width,                  // width
+        height,                 // height
+        p_pic->Y_PITCH,         // y stride
+        p_pic->U_PITCH,         // uv stride
+        p_dst->p[0].i_pitch,    // dst stride
+        yuv2rgb565_table,       // table
+        0                       // dither
+    );
+#endif
+
+    picture_CopyProperties(p_dst, p_pic);
+    picture_Release(p_pic);
+
+    return p_dst;
+}
+
diff -Nurp vlc-a/modules/arm_neon/yuv2rgb.h vlc-b/modules/arm_neon/yuv2rgb.h
--- vlc-a/modules/arm_neon/yuv2rgb.h	1970-01-01 08:00:00.000000000 +0800
+++ vlc-b/modules/arm_neon/yuv2rgb.h	2011-07-10 01:53:48.997262156 +0800
@@ -0,0 +1,150 @@
+/* YUV-> RGB conversion code.
+ *
+ * Copyright (C) 2008-9 Robin Watts (robin@wss.co.uk) for Pinknoise
+ * Productions Ltd.
+ *
+ * Licensed under the GNU GPL. If you need it under another license, contact
+ * me and ask.
+ *
+ *  This program is free software ; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation ; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY ; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program ; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#ifndef YUV2RGB_H
+
+#define YUV2RGB_H
+
+/* Define these to something appropriate in your build */
+
+#include <inttypes.h>
+
+//typedef unsigned int   uint32_t;
+//typedef signed   int   int32_t;
+//typedef unsigned short uint16_t;
+//typedef unsigned char  uint8_t;
+
+extern const uint32_t yuv2rgb565_table[];
+extern const uint32_t yuv2bgr565_table[];
+
+void yuv420_2_rgb565(uint8_t  *dst_ptr,
+               const uint8_t  *y_ptr,
+               const uint8_t  *u_ptr,
+               const uint8_t  *v_ptr,
+                     int32_t   width,
+                     int32_t   height,
+                     int32_t   y_span,
+                     int32_t   uv_span,
+                     int32_t   dst_span,
+               const uint32_t *tables,
+                     int32_t   dither);
+
+void yuv422_2_rgb565(uint8_t  *dst_ptr,
+               const uint8_t  *y_ptr,
+               const uint8_t  *u_ptr,
+               const uint8_t  *v_ptr,
+                     int32_t   width,
+                     int32_t   height,
+                     int32_t   y_span,
+                     int32_t   uv_span,
+                     int32_t   dst_span,
+               const uint32_t *tables,
+                     int32_t   dither);
+
+void yuv444_2_rgb565(uint8_t  *dst_ptr,
+               const uint8_t  *y_ptr,
+               const uint8_t  *u_ptr,
+               const uint8_t  *v_ptr,
+                     int32_t   width,
+                     int32_t   height,
+                     int32_t   y_span,
+                     int32_t   uv_span,
+                     int32_t   dst_span,
+               const uint32_t *tables,
+                     int32_t   dither);
+
+void yuv420_2_rgb888(uint8_t  *dst_ptr,
+               const uint8_t  *y_ptr,
+               const uint8_t  *u_ptr,
+               const uint8_t  *v_ptr,
+                     int32_t   width,
+                     int32_t   height,
+                     int32_t   y_span,
+                     int32_t   uv_span,
+                     int32_t   dst_span,
+               const uint32_t *tables,
+                     int32_t   dither);
+
+void yuv422_2_rgb888(uint8_t  *dst_ptr,
+               const uint8_t  *y_ptr,
+               const uint8_t  *u_ptr,
+               const uint8_t  *v_ptr,
+                     int32_t   width,
+                     int32_t   height,
+                     int32_t   y_span,
+                     int32_t   uv_span,
+                     int32_t   dst_span,
+               const uint32_t *tables,
+                     int32_t   dither);
+
+void yuv444_2_rgb888(uint8_t  *dst_ptr,
+               const uint8_t  *y_ptr,
+               const uint8_t  *u_ptr,
+               const uint8_t  *v_ptr,
+                     int32_t   width,
+                     int32_t   height,
+                     int32_t   y_span,
+                     int32_t   uv_span,
+                     int32_t   dst_span,
+               const uint32_t *tables,
+                     int32_t   dither);
+
+void yuv420_2_rgb8888(uint8_t  *dst_ptr,
+                const uint8_t  *y_ptr,
+                const uint8_t  *u_ptr,
+                const uint8_t  *v_ptr,
+                      int32_t   width,
+                      int32_t   height,
+                      int32_t   y_span,
+                      int32_t   uv_span,
+                      int32_t   dst_span,
+                const uint32_t *tables,
+                      int32_t   dither);
+
+void yuv422_2_rgb8888(uint8_t  *dst_ptr,
+                const uint8_t  *y_ptr,
+                const uint8_t  *u_ptr,
+                const uint8_t  *v_ptr,
+                      int32_t   width,
+                      int32_t   height,
+                      int32_t   y_span,
+                      int32_t   uv_span,
+                      int32_t   dst_span,
+                const uint32_t *tables,
+                      int32_t   dither);
+
+void yuv444_2_rgb8888(uint8_t  *dst_ptr,
+                const uint8_t  *y_ptr,
+                const uint8_t  *u_ptr,
+                const uint8_t  *v_ptr,
+                      int32_t   width,
+                      int32_t   height,
+                      int32_t   y_span,
+                      int32_t   uv_span,
+                      int32_t   dst_span,
+                const uint32_t *tables,
+                      int32_t   dither);
+
+
+#endif /* YUV2RGB_H */
diff -Nurp vlc-a/modules/arm_neon/yuv420rgb565.S vlc-b/modules/arm_neon/yuv420rgb565.S
--- vlc-a/modules/arm_neon/yuv420rgb565.S	1970-01-01 08:00:00.000000000 +0800
+++ vlc-b/modules/arm_neon/yuv420rgb565.S	2011-07-10 01:53:48.997262156 +0800
@@ -0,0 +1,1070 @@
+@ YUV-> RGB conversion code Copyright (C) 2008 Robin Watts (robin;wss.co.uk).
+@
+@ Licensed under the GPL. If you need it under another license, contact me
+@ and ask.
+@
+@  This program is free software ; you can redistribute it and/or modify
+@  it under the terms of the GNU General Public License as published by
+@  the Free Software Foundation ; either version 2 of the License, or
+@  (at your option) any later version.
+@
+@  This program is distributed in the hope that it will be useful,
+@  but WITHOUT ANY WARRANTY ; without even the implied warranty of
+@  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+@  GNU General Public License for more details.
+@
+@  You should have received a copy of the GNU General Public License
+@  along with this program ; if not, write to the Free Software
+@  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+@
+@
+@ The algorithm used here is based heavily on one created by Sophie Wilson
+@ of Acorn/e-14/Broadcomm. Many thanks.
+@
+@ Additional tweaks (in the fast fixup code) are from Paul Gardiner.
+@
+@ The old implementation of YUV -> RGB did:
+@
+@ R = CLAMP((Y-16)*1.164 +           1.596*V)
+@ G = CLAMP((Y-16)*1.164 - 0.391*U - 0.813*V)
+@ B = CLAMP((Y-16)*1.164 + 2.018*U          )
+@
+@ Were going to bend that here as follows:
+@
+@ R = CLAMP(y +           1.596*V)
+@ G = CLAMP(y - 0.383*U - 0.813*V)
+@ B = CLAMP(y + 1.976*U          )
+@
+@ where y = 0               for       Y <=  16,
+@       y = (  Y-16)*1.164, for  16 < Y <= 239,
+@       y = (239-16)*1.164, for 239 < Y
+@
+@ i.e. We clamp Y to the 16 to 239 range (which it is supposed to be in
+@ anyway). We then pick the B_U factor so that B never exceeds 511. We then
+@ shrink the G_U factor in line with that to avoid a colour shift as much as
+@ possible.
+@
+@ Were going to use tables to do it faster, but rather than doing it using
+@ 5 tables as as the above suggests, were going to do it using just 3.
+@
+@ We do this by working in parallel within a 32 bit word, and using one
+@ table each for Y U and V.
+@
+@ Source Y values are    0 to 255, so    0.. 260 after scaling
+@ Source U values are -128 to 127, so  -49.. 49(G), -253..251(B) after
+@ Source V values are -128 to 127, so -204..203(R), -104..103(G) after
+@
+@ So total summed values:
+@ -223 <= R <= 481, -173 <= G <= 431, -253 <= B < 511
+@
+@ We need to pack R G and B into a 32 bit word, and because of Bs range we
+@ need 2 bits above the valid range of B to detect overflow, and another one
+@ to detect the sense of the overflow. We therefore adopt the following
+@ representation:
+@
+@ osGGGGGgggggosBBBBBbbbosRRRRRrrr
+@
+@ Each such word breaks down into 3 ranges.
+@
+@ osGGGGGggggg   osBBBBBbbb   osRRRRRrrr
+@
+@ Thus we have 8 bits for each B and R table entry, and 10 bits for G (good
+@ as G is the most noticable one). The s bit for each represents the sign,
+@ and o represents the overflow.
+@
+@ For R and B we pack the table by taking the 11 bit representation of their
+@ values, and toggling bit 10 in the U and V tables.
+@
+@ For the green case we calculate 4*G (thus effectively using 10 bits for the
+@ valid range) truncate to 12 bits. We toggle bit 11 in the Y table.
+
+@ Theorarm library
+@ Copyright (C) 2009 Robin Watts for Pinknoise Productions Ltd
+
+    .text
+
+	.global	yuv420_2_rgb565
+	.global	yuv420_2_rgb565_PROFILE
+
+@ void yuv420_2_rgb565
+@  uint8_t *dst_ptr
+@  uint8_t *y_ptr
+@  uint8_t *u_ptr
+@  uint8_t *v_ptr
+@  int      width
+@  int      height
+@  int      y_span
+@  int      uv_span
+@  int      dst_span
+@  int     *tables
+@  int      dither
+
+ .set DITH1,	7
+ .set DITH2,	6
+
+yuv420_2_rgb565_PROFILE:		@ Symbol exposed for profiling purposes
+CONST_mask:
+	.word	0x07E0F81F
+CONST_flags:
+	.word	0x40080100
+yuv420_2_rgb565:
+	@ r0 = dst_ptr
+	@ r1 = y_ptr
+	@ r2 = u_ptr
+	@ r3 = v_ptr
+	@ <> = width
+	@ <> = height
+	@ <> = y_span
+	@ <> = uv_span
+	@ <> = dst_span
+	@ <> = y_table
+	@ <> = dither
+	STMFD	r13!,{r4-r11,r14}
+
+	LDR	r8, [r13,#10*4]		@ r8 = height
+	LDR	r10,[r13,#11*4]		@ r10= y_span
+	LDR	r9, [r13,#13*4]		@ r9 = dst_span
+	LDR	r14,[r13,#14*4]		@ r14= y_table
+	LDR	r11,[r13,#15*4]		@ r11= dither
+	LDR	r4, CONST_mask
+	LDR	r5, CONST_flags
+	ANDS	r11,r11,#3
+	BEQ	asm0
+	CMP	r11, #2
+	BEQ	asm3
+	BGT	asm2
+asm1:
+	@  Dither: 1 2
+	@          3 0
+	LDR	r11,[r13,#9*4]		@ r11= width
+	SUBS	r8, r8, #1
+	BLT	end
+	BEQ	trail_row1
+yloop1:
+	SUB	r8, r8, r11,LSL #16	@ r8 = height-(width<<16)
+	ADDS	r8, r8, #1<<16		@ if (width == 1)
+	BGE	trail_pair1		@    just do 1 column
+xloop1:
+	LDRB	r11,[r2], #1		@ r11 = u  = *u_ptr++
+	LDRB	r12,[r3], #1		@ r12 = v  = *v_ptr++
+	LDRB	r7, [r1, r10]		@ r7  = y2 = y_ptr[stride]
+	LDRB	r6, [r1], #1		@ r6  = y0 = *y_ptr++
+	ADD	r11,r11,#256
+	ADD	r12,r12,#512
+	LDR	r11,[r14,r11,LSL #2]	@ r11 = u  = u_table[u]
+	LDR	r12,[r14,r12,LSL #2]	@ r12 = v  = v_table[v]
+	LDR	r7, [r14,r7, LSL #2]	@ r7  = y2 = y_table[y2]
+	LDR	r6, [r14,r6, LSL #2]	@ r6  = y0 = y_table[y0]
+	ADD	r11,r11,r12		@ r11 = uv = u+v
+
+	ADD	r12,r11,r5, LSR #DITH1
+	ADD	r7, r7, r12		@ r7  = y2 + uv + dither1
+	ADD	r6, r6, r12		@ r6  = y0 + uv + dither1
+	ADD	r7, r7, r5, LSR #DITH2	@ r7  = y2 + uv + dither3
+	ANDS	r12,r7, r5
+	TSTEQ	r6, r5
+	BNE	fix101
+return101:
+	AND	r7, r4, r7, LSR #3
+	AND	r6, r4, r6, LSR #3
+	ORR	r7, r7, r7, LSR #16
+	STRH	r7, [r0, r9]
+	LDRB	r12,[r1, r10]		@ r12 = y3 = y_ptr[stride]
+	LDRB	r7, [r1], #1		@ r6  = y1 = *y_ptr++
+	ORR	r6, r6, r6, LSR #16
+	LDR	r12,[r14, r12,LSL #2]	@ r7  = y3 = y_table[y2]
+	STRH	r6, [r0], #2
+	LDR	r6, [r14, r7, LSL #2]	@ r6  = y1 = y_table[y0]
+
+	ADD	r7, r12,r11		@ r7  = y3 + uv
+	ADD	r6, r6, r11		@ r6  = y1 + uv
+	ADD	r6, r6, r5, LSR #DITH2	@ r6  = y1 + uv + dither2
+	ANDS	r12,r7, r5
+	TSTEQ	r6, r5
+	BNE	fix102
+return102:
+	AND	r7, r4, r7, LSR #3
+	AND	r6, r4, r6, LSR #3
+	ORR	r7, r7, r7, LSR #16
+	ORR	r6, r6, r6, LSR #16
+	STRH	r7, [r0, r9]
+	STRH	r6, [r0], #2
+	ADDS	r8, r8, #2<<16
+	BLT	xloop1
+	MOVS	r8, r8, LSL #16		@ Clear the top 16 bits of r8
+	MOV	r8, r8, LSR #16		@ If the C bit is clear we still have
+	BCC	trail_pair1		@ 1 more pixel pair to do
+end_xloop1:
+	LDR	r11,[r13,#9*4]		@ r11= width
+	LDR	r12,[r13,#12*4]		@ r12= uv_stride
+	ADD	r0, r0, r9, LSL #1
+	ADD	r1, r1, r10,LSL #1
+	SUB	r0, r0, r11,LSL #1
+	SUB	r1, r1, r11
+	SUB	r2, r2, r11,LSR #1
+	SUB	r3, r3, r11,LSR #1
+	ADD	r2, r2, r12
+	ADD	r3, r3, r12
+
+	SUBS	r8, r8, #2
+	BGT	yloop1
+
+	LDMLTFD	r13!,{r4-r11,pc}
+trail_row1:
+	@ We have a row of pixels left to do
+	SUB	r8, r8, r11,LSL #16	@ r8 = height-(width<<16)
+	ADDS	r8, r8, #1<<16		@ if (width == 1)
+	BGE	trail_pix1		@    just do 1 pixel
+xloop12:
+	LDRB	r11,[r2], #1		@ r11 = u  = *u_ptr++
+	LDRB	r12,[r3], #1		@ r12 = v  = *v_ptr++
+	LDRB	r6, [r1], #1		@ r6  = y0 = *y_ptr++
+	LDRB	r7, [r1], #1		@ r7  = y1 = *y_ptr++
+	ADD	r11,r11,#256
+	ADD	r12,r12,#512
+	LDR	r11,[r14,r11,LSL #2]	@ r11 = u  = u_table[u]
+	LDR	r12,[r14,r12,LSL #2]	@ r12 = v  = v_table[v]
+	LDR	r7, [r14,r7, LSL #2]	@ r7  = y1 = y_table[y1]
+	LDR	r6, [r14,r6, LSL #2]	@ r6  = y0 = y_table[y0]
+	ADD	r11,r11,r12		@ r11 = uv = u+v
+
+	ADD	r6, r6, r11		@ r6  = y0 + uv
+	ADD	r7, r7, r11		@ r7  = y1 + uv
+	ADD	r6, r6, r5, LSR #DITH1	@ r6  = y0 + uv + dither1
+	ADD	r7, r7, r5, LSR #DITH2	@ r7  = y1 + uv + dither2
+	ANDS	r12,r7, r5
+	TSTEQ	r6, r5
+	BNE	fix104
+return104:
+	AND	r6, r4, r6, LSR #3
+	AND	r7, r4, r7, LSR #3
+	ORR	r6, r6, r6, LSR #16
+	ORR	r7, r7, r7, LSR #16
+	STRH	r6, [r0], #2
+	STRH	r7, [r0], #2
+	ADDS	r8, r8, #2<<16
+	BLT	xloop12
+	MOVS	r8, r8, LSL #16		@ Clear the top 16 bits of r8
+	MOV	r8, r8, LSR #16		@ If the C bit is clear we still have
+	BCC	trail_pix1		@ 1 more pixel pair to do
+end:
+	LDMFD	r13!,{r4-r11,pc}
+trail_pix1:
+	@ We have a single extra pixel to do
+	LDRB	r11,[r2], #1		@ r11 = u  = *u_ptr++
+	LDRB	r12,[r3], #1		@ r12 = v  = *v_ptr++
+	LDRB	r6, [r1], #1		@ r6  = y0 = *y_ptr++
+	ADD	r11,r11,#256
+	ADD	r12,r12,#512
+	LDR	r11,[r14,r11,LSL #2]	@ r11 = u  = u_table[u]
+	LDR	r12,[r14,r12,LSL #2]	@ r12 = v  = v_table[v]
+	LDR	r6, [r14,r6, LSL #2]	@ r6  = y0 = y_table[y0]
+	ADD	r11,r11,r12		@ r11 = uv = u+v
+
+	ADD	r11,r11,r5, LSR #DITH1	@ (dither 1/4)
+	ADD	r6, r6, r11		@ r6  = y0 + uv + dither1
+	ANDS	r12,r6, r5
+	BNE	fix105
+return105:
+	AND	r6, r4, r6, LSR #3
+	ORR	r6, r6, r6, LSR #16
+	STRH	r6, [r0], #2
+
+	LDMFD	r13!,{r4-r11,pc}
+
+trail_pair1:
+	@ We have a pair of pixels left to do
+	LDRB	r11,[r2]		@ r11 = u  = *u_ptr++
+	LDRB	r12,[r3]		@ r12 = v  = *v_ptr++
+	LDRB	r7, [r1, r10]		@ r7  = y2 = y_ptr[stride]
+	LDRB	r6, [r1], #1		@ r6  = y0 = *y_ptr++
+	ADD	r11,r11,#256
+	ADD	r12,r12,#512
+	LDR	r11,[r14,r11,LSL #2]	@ r11 = u  = u_table[u]
+	LDR	r12,[r14,r12,LSL #2]	@ r12 = v  = v_table[v]
+	LDR	r7, [r14,r7, LSL #2]	@ r7  = y2 = y_table[y2]
+	LDR	r6, [r14,r6, LSL #2]	@ r6  = y0 = y_table[y0]
+	ADD	r11,r11,r12		@ r11 = uv = u+v
+
+	ADD	r11,r11,r5, LSR #DITH1
+	ADD	r7, r7, r11		@ r7  = y2 + uv + dither1
+	ADD	r6, r6, r11		@ r6  = y0 + uv
+	ADD	r7, r7, r5, LSR #DITH2	@ r7  = y2 + uv + dither3
+	ANDS	r12,r7, r5
+	TSTEQ	r6, r5
+	BNE	fix103
+return103:
+	AND	r7, r4, r7, LSR #3
+	AND	r6, r4, r6, LSR #3
+	ORR	r7, r7, r7, LSR #16
+	ORR	r6, r6, r6, LSR #16
+	STRH	r7, [r0, r9]
+	STRH	r6, [r0], #2
+	B	end_xloop1
+fix101:
+	@ r7 and r6 are the values, at least one of which has overflowed
+	@ r12 = r7 & mask = .s......s......s......
+	SUB	r12,r12,r12,LSR #8	@ r12 = ..SSSSSS.SSSSSS.SSSSSS
+	ORR	r7, r7, r12		@ r7 |= ..SSSSSS.SSSSSS.SSSSSS
+	BIC	r12,r5, r7, LSR #1	@ r12 = .o......o......o......
+	ADD	r7, r7, r12,LSR #8	@ r7  = fixed value
+
+	AND	r12, r6, r5		@ r12 = .S......S......S......
+	SUB	r12,r12,r12,LSR #8	@ r12 = ..SSSSSS.SSSSSS.SSSSSS
+	ORR	r6, r6, r12		@ r6 |= ..SSSSSS.SSSSSS.SSSSSS
+	BIC	r12,r5, r6, LSR #1	@ r12 = .o......o......o......
+	ADD	r6, r6, r12,LSR #8	@ r6  = fixed value
+	B	return101
+fix102:
+	@ r7 and r6 are the values, at least one of which has overflowed
+	@ r12 = r7 & mask = .s......s......s......
+	SUB	r12,r12,r12,LSR #8	@ r12 = ..SSSSSS.SSSSSS.SSSSSS
+	ORR	r7, r7, r12		@ r7 |= ..SSSSSS.SSSSSS.SSSSSS
+	BIC	r12,r5, r7, LSR #1	@ r12 = .o......o......o......
+	ADD	r7, r7, r12,LSR #8	@ r7  = fixed value
+
+	AND	r12, r6, r5		@ r12 = .S......S......S......
+	SUB	r12,r12,r12,LSR #8	@ r12 = ..SSSSSS..SSSSS.SSSSSS
+	ORR	r6, r6, r12		@ r6 |= ..SSSSSS..SSSSS.SSSSSS
+	BIC	r12,r5, r6, LSR #1	@ r12 = .o......o......o......
+	ADD	r6, r6, r12,LSR #8	@ r6  = fixed value
+	B	return102
+fix103:
+	@ r7 and r6 are the values, at least one of which has overflowed
+	@ r12 = r7 & mask = .s......s......s......
+	SUB	r12,r12,r12,LSR #8	@ r12 = ..SSSSSS.SSSSSS.SSSSSS
+	ORR	r7, r7, r12		@ r7 |= ..SSSSSS.SSSSSS.SSSSSS
+	BIC	r12,r5, r7, LSR #1	@ r12 = .o......o......o......
+	ADD	r7, r7, r12,LSR #8	@ r7  = fixed value
+
+	AND	r12, r6, r5		@ r12 = .S......S......S......
+	SUB	r12,r12,r12,LSR #8	@ r12 = ..SSSSSS.SSSSSS.SSSSSS
+	ORR	r6, r6, r12		@ r6 |= ..SSSSSS.SSSSSS.SSSSSS
+	BIC	r12,r5, r6, LSR #1	@ r12 = .o......o......o......
+	ADD	r6, r6, r12,LSR #8	@ r6  = fixed value
+	B	return103
+fix104:
+	@ r7 and r6 are the values, at least one of which has overflowed
+	@ r12 = r7 & mask = .s......s......s......
+	SUB	r12,r12,r12,LSR #8	@ r12 = ..SSSSSS.SSSSSS.SSSSSS
+	ORR	r7, r7, r12		@ r7 |= ..SSSSSS.SSSSSS.SSSSSS
+	BIC	r12,r5, r7, LSR #1	@ r12 = .o......o......o......
+	ADD	r7, r7, r12,LSR #8	@ r7  = fixed value
+
+	AND	r12, r6, r5		@ r12 = .S......S......S......
+	SUB	r12,r12,r12,LSR #8	@ r12 = ..SSSSSS.SSSSSS.SSSSSS
+	ORR	r6, r6, r12		@ r6 |= ..SSSSSS.SSSSSS.SSSSSS
+	BIC	r12,r5, r6, LSR #1	@ r12 = .o......o......o......
+	ADD	r6, r6, r12,LSR #8	@ r6  = fixed value
+	B	return104
+fix105:
+	@ r6 is the value, which has has overflowed
+	@ r12 = r7 & mask = .s......s......s......
+	SUB	r12,r12,r12,LSR #8	@ r12 = ..SSSSSS.SSSSSS.SSSSSS
+	ORR	r6, r6, r12		@ r6 |= ..SSSSSS.SSSSSS.SSSSSS
+	BIC	r12,r5, r6, LSR #1	@ r12 = .o......o......o......
+	ADD	r6, r6, r12,LSR #8	@ r6  = fixed value
+	B	return105
+
+@------------------------------------------------------------------------
+asm0:
+	@  Dither: 0 3
+	@          2 1
+	LDR	r11,[r13,#9*4]		@ r11= width
+	SUBS	r8, r8, #1
+	BLT	end
+	BEQ	trail_row0
+yloop0:
+	SUB	r8, r8, r11,LSL #16	@ r8 = height-(width<<16)
+	ADDS	r8, r8, #1<<16		@ if (width == 1)
+	BGE	trail_pair0		@    just do 1 column
+xloop0:
+	LDRB	r11,[r2], #1		@ r11 = u  = *u_ptr++
+	LDRB	r12,[r3], #1		@ r12 = v  = *v_ptr++
+	LDRB	r7, [r1, r10]		@ r7  = y2 = y_ptr[stride]
+	LDRB	r6, [r1], #1		@ r6  = y0 = *y_ptr++
+	ADD	r11,r11,#256
+	ADD	r12,r12,#512
+	LDR	r11,[r14,r11,LSL #2]	@ r11 = u  = u_table[u]
+	LDR	r12,[r14,r12,LSL #2]	@ r12 = v  = v_table[v]
+	LDR	r7, [r14,r7, LSL #2]	@ r7  = y2 = y_table[y2]
+	LDR	r6, [r14,r6, LSL #2]	@ r6  = y0 = y_table[y0]
+	ADD	r11,r11,r12		@ r11 = uv = u+v
+
+	ADD	r7, r7, r11		@ r7  = y2 + uv
+	ADD	r6, r6, r11		@ r6  = y0 + uv
+	ADD	r7, r7, r5, LSR #DITH2	@ r7  = y2 + uv + dither2
+	ANDS	r12,r7, r5
+	TSTEQ	r6, r5
+	BNE	fix001
+return001:
+	AND	r7, r4, r7, LSR #3
+	AND	r6, r4, r6, LSR #3
+	ORR	r7, r7, r7, LSR #16
+	STRH	r7, [r0, r9]
+	LDRB	r12,[r1, r10]		@ r12 = y3 = y_ptr[stride]
+	LDRB	r7, [r1], #1		@ r6  = y1 = *y_ptr++
+	ORR	r6, r6, r6, LSR #16
+	LDR	r12,[r14, r12,LSL #2]	@ r7  = y3 = y_table[y2]
+	STRH	r6, [r0], #2
+	LDR	r6, [r14, r7, LSL #2]	@ r6  = y1 = y_table[y0]
+
+	ADD	r11,r11,r5, LSR #DITH1
+	ADD	r7, r12,r11		@ r7  = y3 + uv + dither1
+	ADD	r6, r6, r11		@ r6  = y1 + uv + dither1
+	ADD	r6, r6, r5, LSR #DITH2	@ r6  = y1 + uv + dither3
+	ANDS	r12,r7, r5
+	TSTEQ	r6, r5
+	BNE	fix002
+return002:
+	AND	r7, r4, r7, LSR #3
+	AND	r6, r4, r6, LSR #3
+	ORR	r7, r7, r7, LSR #16
+	ORR	r6, r6, r6, LSR #16
+	STRH	r7, [r0, r9]
+	STRH	r6, [r0], #2
+	ADDS	r8, r8, #2<<16
+	BLT	xloop0
+	MOVS	r8, r8, LSL #16		@ Clear the top 16 bits of r8
+	MOV	r8, r8, LSR #16		@ If the C bit is clear we still have
+	BCC	trail_pair0		@ 1 more pixel pair to do
+end_xloop0:
+	LDR	r11,[r13,#9*4]		@ r11= width
+	LDR	r12,[r13,#12*4]		@ r12= uv_stride
+	ADD	r0, r0, r9, LSL #1
+	SUB	r0, r0, r11,LSL #1
+	ADD	r1, r1, r10,LSL #1
+	SUB	r1, r1, r11
+	SUB	r2, r2, r11,LSR #1
+	SUB	r3, r3, r11,LSR #1
+	ADD	r2, r2, r12
+	ADD	r3, r3, r12
+
+	SUBS	r8, r8, #2
+	BGT	yloop0
+
+	LDMLTFD	r13!,{r4-r11,pc}
+trail_row0:
+	@ We have a row of pixels left to do
+	SUB	r8, r8, r11,LSL #16	@ r8 = height-(width<<16)
+	ADDS	r8, r8, #1<<16		@ if (width == 1)
+	BGE	trail_pix0		@    just do 1 pixel
+xloop02:
+	LDRB	r11,[r2], #1		@ r11 = u  = *u_ptr++
+	LDRB	r12,[r3], #1		@ r12 = v  = *v_ptr++
+	LDRB	r6, [r1], #1		@ r6  = y0 = *y_ptr++
+	LDRB	r7, [r1], #1		@ r7  = y1 = *y_ptr++
+	ADD	r11,r11,#256
+	ADD	r12,r12,#512
+	LDR	r11,[r14,r11,LSL #2]	@ r11 = u  = u_table[u]
+	LDR	r12,[r14,r12,LSL #2]	@ r12 = v  = v_table[v]
+	LDR	r7, [r14,r7, LSL #2]	@ r7  = y1 = y_table[y1]
+	LDR	r6, [r14,r6, LSL #2]	@ r6  = y0 = y_table[y0]
+	ADD	r11,r11,r12		@ r11 = uv = u+v
+
+	ADD	r6, r6, r11		@ r6  = y0 + uv
+	ADD	r7, r7, r11		@ r7  = y1 + uv
+	ADD	r7, r7, r5, LSR #DITH1	@ r7  = y1 + uv + dither1
+	ADD	r7, r7, r5, LSR #DITH2	@ r7  = y1 + uv + dither3
+	ANDS	r12,r7, r5
+	TSTEQ	r6, r5
+	BNE	fix004
+return004:
+	AND	r6, r4, r6, LSR #3
+	AND	r7, r4, r7, LSR #3
+	ORR	r6, r6, r6, LSR #16
+	ORR	r7, r7, r7, LSR #16
+	STRH	r6, [r0], #2
+	STRH	r7, [r0], #2
+	ADDS	r8, r8, #2<<16
+	BLT	xloop02
+	MOVS	r8, r8, LSL #16		@ Clear the top 16 bits of r8
+	MOV	r8, r8, LSR #16		@ If the C bit is clear we still have
+	BCC	trail_pix0		@ 1 more pixel pair to do
+
+	LDMFD	r13!,{r4-r11,pc}
+trail_pix0:
+	@ We have a single extra pixel to do
+	LDRB	r11,[r2], #1		@ r11 = u  = *u_ptr++
+	LDRB	r12,[r3], #1		@ r12 = v  = *v_ptr++
+	LDRB	r6, [r1], #1		@ r6  = y0 = *y_ptr++
+	ADD	r11,r11,#256
+	ADD	r12,r12,#512
+	LDR	r11,[r14,r11,LSL #2]	@ r11 = u  = u_table[u]
+	LDR	r12,[r14,r12,LSL #2]	@ r12 = v  = v_table[v]
+	LDR	r6, [r14,r6, LSL #2]	@ r6  = y0 = y_table[y0]
+	@ Stall (on Xscale)
+	ADD	r11,r11,r12		@ r11 = uv = u+v
+
+	ADD	r6, r6, r11		@ r6  = y0 + uv
+	ANDS	r12,r6, r5
+	BNE	fix005
+return005:
+	AND	r6, r4, r6, LSR #3
+	ORR	r6, r6, r6, LSR #16
+	STRH	r6, [r0], #2
+
+	LDMFD	r13!,{r4-r11,pc}
+
+trail_pair0:
+	@ We have a pair of pixels left to do
+	LDRB	r11,[r2]		@ r11 = u  = *u_ptr++
+	LDRB	r12,[r3]		@ r12 = v  = *v_ptr++
+	LDRB	r7, [r1, r10]		@ r7  = y2 = y_ptr[stride]
+	LDRB	r6, [r1], #1		@ r6  = y0 = *y_ptr++
+	ADD	r11,r11,#256
+	ADD	r12,r12,#512
+	LDR	r11,[r14,r11,LSL #2]	@ r11 = u  = u_table[u]
+	LDR	r12,[r14,r12,LSL #2]	@ r12 = v  = v_table[v]
+	LDR	r7, [r14,r7, LSL #2]	@ r7  = y2 = y_table[y2]
+	LDR	r6, [r14,r6, LSL #2]	@ r6  = y0 = y_table[y0]
+	ADD	r11,r11,r12		@ r11 = uv = u+v
+
+	ADD	r7, r7, r11		@ r7  = y2 + uv
+	ADD	r6, r6, r11		@ r6  = y0 + uv
+	ADD	r7, r7, r5, LSR #DITH2	@ r7  = y2 + uv + dither2
+	ANDS	r12,r7, r5
+	TSTEQ	r6, r5
+	BNE	fix003
+return003:
+	AND	r7, r4, r7, LSR #3
+	AND	r6, r4, r6, LSR #3
+	ORR	r7, r7, r7, LSR #16
+	ORR	r6, r6, r6, LSR #16
+	STRH	r7, [r0, r9]
+	STRH	r6, [r0], #2
+	B	end_xloop0
+fix001:
+	@ r7 and r6 are the values, at least one of which has overflowed
+	@ r12 = r7 & mask = .s......s......s......
+	SUB	r12,r12,r12,LSR #8	@ r12 = ..SSSSSS.SSSSSS.SSSSSS
+	ORR	r7, r7, r12		@ r7 |= ..SSSSSS.SSSSSS.SSSSSS
+	BIC	r12,r5, r7, LSR #1	@ r12 = .o......o......o......
+	ADD	r7, r7, r12,LSR #8	@ r7  = fixed value
+
+	AND	r12, r6, r5		@ r12 = .S......S......S......
+	SUB	r12,r12,r12,LSR #8	@ r12 = ..SSSSSS.SSSSSS.SSSSSS
+	ORR	r6, r6, r12		@ r6 |= ..SSSSSS.SSSSSS.SSSSSS
+	BIC	r12,r5, r6, LSR #1	@ r12 = .o......o......o......
+	ADD	r6, r6, r12,LSR #8	@ r6  = fixed value
+	B	return001
+fix002:
+	@ r7 and r6 are the values, at least one of which has overflowed
+	@ r12 = r7 & mask = .s......s......s......
+	SUB	r12,r12,r12,LSR #8	@ r12 = ..SSSSSS.SSSSSS.SSSSSS
+	ORR	r7, r7, r12		@ r7 |= ..SSSSSS.SSSSSS.SSSSSS
+	BIC	r12,r5, r7, LSR #1	@ r12 = .o......o......o......
+	ADD	r7, r7, r12,LSR #8	@ r7  = fixed value
+
+	AND	r12, r6, r5		@ r12 = .S......S......S......
+	SUB	r12,r12,r12,LSR #8	@ r12 = ..SSSSSS..SSSSS.SSSSSS
+	ORR	r6, r6, r12		@ r6 |= ..SSSSSS..SSSSS.SSSSSS
+	BIC	r12,r5, r6, LSR #1	@ r12 = .o......o......o......
+	ADD	r6, r6, r12,LSR #8	@ r6  = fixed value
+	B	return002
+fix003:
+	@ r7 and r6 are the values, at least one of which has overflowed
+	@ r12 = r7 & mask = .s......s......s......
+	SUB	r12,r12,r12,LSR #8	@ r12 = ..SSSSSS.SSSSSS.SSSSSS
+	ORR	r7, r7, r12		@ r7 |= ..SSSSSS.SSSSSS.SSSSSS
+	BIC	r12,r5, r7, LSR #1	@ r12 = .o......o......o......
+	ADD	r7, r7, r12,LSR #8	@ r7  = fixed value
+
+	AND	r12, r6, r5		@ r12 = .S......S......S......
+	SUB	r12,r12,r12,LSR #8	@ r12 = ..SSSSSS.SSSSSS.SSSSSS
+	ORR	r6, r6, r12		@ r6 |= ..SSSSSS.SSSSSS.SSSSSS
+	BIC	r12,r5, r6, LSR #1	@ r12 = .o......o......o......
+	ADD	r6, r6, r12,LSR #8	@ r6  = fixed value
+	B	return003
+fix004:
+	@ r7 and r6 are the values, at least one of which has overflowed
+	@ r12 = r7 & mask = .s......s......s......
+	SUB	r12,r12,r12,LSR #8	@ r12 = ..SSSSSS.SSSSSS.SSSSSS
+	ORR	r7, r7, r12		@ r7 |= ..SSSSSS.SSSSSS.SSSSSS
+	BIC	r12,r5, r7, LSR #1	@ r12 = .o......o......o......
+	ADD	r7, r7, r12,LSR #8	@ r7  = fixed value
+
+	AND	r12, r6, r5		@ r12 = .S......S......S......
+	SUB	r12,r12,r12,LSR #8	@ r12 = ..SSSSSS.SSSSSS.SSSSSS
+	ORR	r6, r6, r12		@ r6 |= ..SSSSSS.SSSSSS.SSSSSS
+	BIC	r12,r5, r6, LSR #1	@ r12 = .o......o......o......
+	ADD	r6, r6, r12,LSR #8	@ r6  = fixed value
+	B	return004
+fix005:
+	@ r6 is the value, which has has overflowed
+	@ r12 = r7 & mask = .s......s......s......
+	SUB	r12,r12,r12,LSR #8	@ r12 = ..SSSSSS.SSSSSS.SSSSSS
+	ORR	r6, r6, r12		@ r6 |= ..SSSSSS.SSSSSS.SSSSSS
+	BIC	r12,r5, r6, LSR #1	@ r12 = .o......o......o......
+	ADD	r6, r6, r12,LSR #8	@ r6  = fixed value
+	B	return005
+
+@------------------------------------------------------------------------
+asm2:
+	@  Dither: 2 1
+	@          0 3
+	LDR	r11,[r13,#9*4]		@ r11= width
+	SUBS	r8, r8, #1
+	BLT	end
+	BEQ	trail_row2
+yloop2:
+	SUB	r8, r8, r11,LSL #16	@ r8 = height-(width<<16)
+	ADDS	r8, r8, #1<<16		@ if (width == 1)
+	BGE	trail_pair2		@    just do 1 column
+xloop2:
+	LDRB	r11,[r2], #1		@ r11 = u  = *u_ptr++
+	LDRB	r12,[r3], #1		@ r12 = v  = *v_ptr++
+	LDRB	r7, [r1, r10]		@ r7  = y2 = y_ptr[stride]
+	LDRB	r6, [r1], #1		@ r6  = y0 = *y_ptr++
+	ADD	r11,r11,#256
+	ADD	r12,r12,#512
+	LDR	r11,[r14,r11,LSL #2]	@ r11 = u  = u_table[u]
+	LDR	r12,[r14,r12,LSL #2]	@ r12 = v  = v_table[v]
+	LDR	r7, [r14,r7, LSL #2]	@ r7  = y2 = y_table[y2]
+	LDR	r6, [r14,r6, LSL #2]	@ r6  = y0 = y_table[y0]
+	ADD	r11,r11,r12		@ r11 = uv = u+v
+
+	ADD	r7, r7, r11		@ r7  = y2 + uv
+	ADD	r6, r6, r11		@ r6  = y0 + uv
+	ADD	r6, r6, r5, LSR #DITH2	@ r6  = y0 + uv + dither2
+	ANDS	r12,r7, r5
+	TSTEQ	r6, r5
+	BNE	fix201
+return201:
+	AND	r7, r4, r7, LSR #3
+	AND	r6, r4, r6, LSR #3
+	ORR	r7, r7, r7, LSR #16
+	STRH	r7, [r0, r9]
+	LDRB	r12,[r1, r10]		@ r12 = y3 = y_ptr[stride]
+	LDRB	r7, [r1], #1		@ r6  = y1 = *y_ptr++
+	ORR	r6, r6, r6, LSR #16
+	LDR	r12,[r14, r12,LSL #2]	@ r7  = y3 = y_table[y2]
+	STRH	r6, [r0], #2
+	LDR	r6, [r14, r7, LSL #2]	@ r6  = y1 = y_table[y0]
+
+	ADD	r11,r11,r5, LSR #DITH1
+	ADD	r7, r12,r11		@ r7  = y3 + uv + dither1
+	ADD	r7, r7, r5, LSR #DITH2	@ r7  = y3 + uv + dither3
+	ADD	r6, r6, r11		@ r6  = y1 + uv + dither1
+	ANDS	r12,r7, r5
+	TSTEQ	r6, r5
+	BNE	fix202
+return202:
+	AND	r7, r4, r7, LSR #3
+	AND	r6, r4, r6, LSR #3
+	ORR	r7, r7, r7, LSR #16
+	ORR	r6, r6, r6, LSR #16
+	STRH	r7, [r0, r9]
+	STRH	r6, [r0], #2
+	ADDS	r8, r8, #2<<16
+	BLT	xloop2
+	MOVS	r8, r8, LSL #16		@ Clear the top 16 bits of r8
+	MOV	r8, r8, LSR #16		@ If the C bit is clear we still have
+	BCC	trail_pair2		@ 1 more pixel pair to do
+end_xloop2:
+	LDR	r11,[r13,#9*4]		@ r11= width
+	LDR	r12,[r13,#12*4]		@ r12= uv_stride
+	ADD	r0, r0, r9, LSL #1
+	ADD	r1, r1, r10,LSL #1
+	SUB	r0, r0, r11,LSL #1
+	SUB	r1, r1, r11
+	SUB	r2, r2, r11,LSR #1
+	SUB	r3, r3, r11,LSR #1
+	ADD	r2, r2, r12
+	ADD	r3, r3, r12
+
+	SUBS	r8, r8, #2
+	BGT	yloop2
+
+	LDMLTFD	r13!,{r4-r11,pc}
+trail_row2:
+	@ We have a row of pixels left to do
+	SUB	r8, r8, r11,LSL #16	@ r8 = height-(width<<16)
+	ADDS	r8, r8, #1<<16		@ if (width == 1)
+	BGE	trail_pix2		@    just do 1 pixel
+xloop22:
+	LDRB	r11,[r2], #1		@ r11 = u  = *u_ptr++
+	LDRB	r12,[r3], #1		@ r12 = v  = *v_ptr++
+	LDRB	r6, [r1], #1		@ r6  = y0 = *y_ptr++
+	LDRB	r7, [r1], #1		@ r7  = y1 = *y_ptr++
+	ADD	r11,r11,#256
+	ADD	r12,r12,#512
+	LDR	r11,[r14,r11,LSL #2]	@ r11 = u  = u_table[u]
+	LDR	r12,[r14,r12,LSL #2]	@ r12 = v  = v_table[v]
+	LDR	r6, [r14,r6, LSL #2]	@ r6  = y0 = y_table[y0]
+	LDR	r7, [r14,r7, LSL #2]	@ r7  = y1 = y_table[y1]
+	ADD	r11,r11,r12		@ r11 = uv = u+v
+
+	ADD	r6, r6, r11		@ r6  = y0 + uv
+	ADD	r6, r6, r5, LSR #DITH2	@ r6  = y0 + uv + dither2
+	ADD	r7, r7, r11		@ r7  = y1 + uv
+	ADD	r7, r7, r5, LSR #DITH1	@ r7  = y1 + uv + dither1
+	ANDS	r12,r7, r5
+	TSTEQ	r6, r5
+	BNE	fix204
+return204:
+	AND	r6, r4, r6, LSR #3
+	AND	r7, r4, r7, LSR #3
+	ORR	r6, r6, r6, LSR #16
+	ORR	r7, r7, r7, LSR #16
+	STRH	r6, [r0], #2
+	STRH	r7, [r0], #2
+	ADDS	r8, r8, #2<<16
+	BLT	xloop22
+	MOVS	r8, r8, LSL #16		@ Clear the top 16 bits of r8
+	MOV	r8, r8, LSR #16		@ If the C bit is clear we still have
+	BCC	trail_pix2		@ 1 more pixel pair to do
+
+	LDMFD	r13!,{r4-r11,pc}
+trail_pix2:
+	@ We have a single extra pixel to do
+	LDRB	r11,[r2], #1		@ r11 = u  = *u_ptr++
+	LDRB	r12,[r3], #1		@ r12 = v  = *v_ptr++
+	LDRB	r6, [r1], #1		@ r6  = y0 = *y_ptr++
+	ADD	r11,r11,#256
+	ADD	r12,r12,#512
+	LDR	r11,[r14,r11,LSL #2]	@ r11 = u  = u_table[u]
+	LDR	r12,[r14,r12,LSL #2]	@ r12 = v  = v_table[v]
+	LDR	r6, [r14,r6, LSL #2]	@ r6  = y0 = y_table[y0]
+	ADD	r11,r11,r12		@ r11 = uv = u+v
+
+	ADD	r11,r11,r5, LSR #DITH2
+	ADD	r6, r6, r11		@ r6  = y0 + uv + dither2
+	ANDS	r12,r6, r5
+	BNE	fix205
+return205:
+	AND	r6, r4, r6, LSR #3
+	ORR	r6, r6, r6, LSR #16
+	STRH	r6, [r0], #2
+
+	LDMFD	r13!,{r4-r11,pc}
+
+trail_pair2:
+	@ We have a pair of pixels left to do
+	LDRB	r11,[r2]		@ r11 = u  = *u_ptr++
+	LDRB	r12,[r3]		@ r12 = v  = *v_ptr++
+	LDRB	r7, [r1, r10]		@ r7  = y2 = y_ptr[stride]
+	LDRB	r6, [r1], #1		@ r6  = y0 = *y_ptr++
+	ADD	r11,r11,#256
+	ADD	r12,r12,#512
+	LDR	r11,[r14,r11,LSL #2]	@ r11 = u  = u_table[u]
+	LDR	r12,[r14,r12,LSL #2]	@ r12 = v  = v_table[v]
+	LDR	r7, [r14,r7, LSL #2]	@ r7  = y2 = y_table[y2]
+	LDR	r6, [r14,r6, LSL #2]	@ r6  = y0 = y_table[y0]
+	ADD	r11,r11,r12		@ r11 = uv = u+v
+
+	ADD	r7, r7, r11		@ r7  = y2 + uv
+	ADD	r6, r6, r11		@ r6  = y0 + uv
+	ADD	r6, r6, r5, LSR #DITH2	@ r6  = y0 + uv + 2
+	ANDS	r12,r7, r5
+	TSTEQ	r6, r5
+	BNE	fix203
+return203:
+	AND	r7, r4, r7, LSR #3
+	AND	r6, r4, r6, LSR #3
+	ORR	r7, r7, r7, LSR #16
+	ORR	r6, r6, r6, LSR #16
+	STRH	r7, [r0, r9]
+	STRH	r6, [r0], #2
+	B	end_xloop2
+fix201:
+	@ r7 and r6 are the values, at least one of which has overflowed
+	@ r12 = r7 & mask = .s......s......s......
+	SUB	r12,r12,r12,LSR #8	@ r12 = ..SSSSSS.SSSSSS.SSSSSS
+	ORR	r7, r7, r12		@ r7 |= ..SSSSSS.SSSSSS.SSSSSS
+	BIC	r12,r5, r7, LSR #1	@ r12 = .o......o......o......
+	ADD	r7, r7, r12,LSR #8	@ r7  = fixed value
+
+	AND	r12, r6, r5		@ r12 = .S......S......S......
+	SUB	r12,r12,r12,LSR #8	@ r12 = ..SSSSSS.SSSSSS.SSSSSS
+	ORR	r6, r6, r12		@ r6 |= ..SSSSSS.SSSSSS.SSSSSS
+	BIC	r12,r5, r6, LSR #1	@ r12 = .o......o......o......
+	ADD	r6, r6, r12,LSR #8	@ r6  = fixed value
+	B	return201
+fix202:
+	@ r7 and r6 are the values, at least one of which has overflowed
+	@ r12 = r7 & mask = .s......s......s......
+	SUB	r12,r12,r12,LSR #8	@ r12 = ..SSSSSS.SSSSSS.SSSSSS
+	ORR	r7, r7, r12		@ r7 |= ..SSSSSS.SSSSSS.SSSSSS
+	BIC	r12,r5, r7, LSR #1	@ r12 = .o......o......o......
+	ADD	r7, r7, r12,LSR #8	@ r7  = fixed value
+
+	AND	r12, r6, r5		@ r12 = .S......S......S......
+	SUB	r12,r12,r12,LSR #8	@ r12 = ..SSSSSS..SSSSS.SSSSSS
+	ORR	r6, r6, r12		@ r6 |= ..SSSSSS..SSSSS.SSSSSS
+	BIC	r12,r5, r6, LSR #1	@ r12 = .o......o......o......
+	ADD	r6, r6, r12,LSR #8	@ r6  = fixed value
+	B	return202
+fix203:
+	@ r7 and r6 are the values, at least one of which has overflowed
+	@ r12 = r7 & mask = .s......s......s......
+	SUB	r12,r12,r12,LSR #8	@ r12 = ..SSSSSS.SSSSSS.SSSSSS
+	ORR	r7, r7, r12		@ r7 |= ..SSSSSS.SSSSSS.SSSSSS
+	BIC	r12,r5, r7, LSR #1	@ r12 = .o......o......o......
+	ADD	r7, r7, r12,LSR #8	@ r7  = fixed value
+
+	AND	r12, r6, r5		@ r12 = .S......S......S......
+	SUB	r12,r12,r12,LSR #8	@ r12 = ..SSSSSS.SSSSSS.SSSSSS
+	ORR	r6, r6, r12		@ r6 |= ..SSSSSS.SSSSSS.SSSSSS
+	BIC	r12,r5, r6, LSR #1	@ r12 = .o......o......o......
+	ADD	r6, r6, r12,LSR #8	@ r6  = fixed value
+	B	return203
+fix204:
+	@ r7 and r6 are the values, at least one of which has overflowed
+	@ r12 = r7 & mask = .s......s......s......
+	SUB	r12,r12,r12,LSR #8	@ r12 = ..SSSSSS.SSSSSS.SSSSSS
+	ORR	r7, r7, r12		@ r7 |= ..SSSSSS.SSSSSS.SSSSSS
+	BIC	r12,r5, r7, LSR #1	@ r12 = .o......o......o......
+	ADD	r7, r7, r12,LSR #8	@ r7  = fixed value
+
+	AND	r12, r6, r5		@ r12 = .S......S......S......
+	SUB	r12,r12,r12,LSR #8	@ r12 = ..SSSSSS.SSSSSS.SSSSSS
+	ORR	r6, r6, r12		@ r6 |= ..SSSSSS.SSSSSS.SSSSSS
+	BIC	r12,r5, r6, LSR #1	@ r12 = .o......o......o......
+	ADD	r6, r6, r12,LSR #8	@ r6  = fixed value
+	B	return204
+fix205:
+	@ r6 is the value, which has has overflowed
+	@ r12 = r7 & mask = .s......s......s......
+	SUB	r12,r12,r12,LSR #8	@ r12 = ..SSSSSS.SSSSSS.SSSSSS
+	ORR	r6, r6, r12		@ r6 |= ..SSSSSS.SSSSSS.SSSSSS
+	BIC	r12,r5, r6, LSR #1	@ r12 = .o......o......o......
+	ADD	r6, r6, r12,LSR #8	@ r6  = fixed value
+	B	return205
+
+@------------------------------------------------------------------------
+asm3:
+	@  Dither: 3 0
+	@          1 2
+	LDR	r11,[r13,#9*4]		@ r11= width
+	SUBS	r8, r8, #1
+	BLT	end
+	BEQ	trail_row3
+yloop3:
+	SUB	r8, r8, r11,LSL #16	@ r8 = height-(width<<16)
+	ADDS	r8, r8, #1<<16		@ if (width == 1)
+	BGE	trail_pair3		@    just do 1 column
+xloop3:
+	LDRB	r11,[r2], #1		@ r11 = u  = *u_ptr++
+	LDRB	r12,[r3], #1		@ r12 = v  = *v_ptr++
+	LDRB	r7, [r1, r10]		@ r7  = y2 = y_ptr[stride]
+	LDRB	r6, [r1], #1		@ r6  = y0 = *y_ptr++
+	ADD	r11,r11,#256
+	ADD	r12,r12,#512
+	LDR	r11,[r14,r11,LSL #2]	@ r11 = u  = u_table[u]
+	LDR	r12,[r14,r12,LSL #2]	@ r12 = v  = v_table[v]
+	LDR	r7, [r14,r7, LSL #2]	@ r7  = y2 = y_table[y2]
+	LDR	r6, [r14,r6, LSL #2]	@ r6  = y0 = y_table[y0]
+	ADD	r11,r11,r12		@ r11 = uv = u+v
+
+	ADD	r12,r11,r5, LSR #DITH1
+	ADD	r7, r7, r12		@ r7  = y2 + uv + dither1
+	ADD	r6, r6, r12		@ r6  = y0 + uv + dither1
+	ADD	r6, r6, r5, LSR #DITH2	@ r6  = y0 + uv + dither3
+	ANDS	r12,r7, r5
+	TSTEQ	r6, r5
+	BNE	fix301
+return301:
+	AND	r7, r4, r7, LSR #3
+	AND	r6, r4, r6, LSR #3
+	ORR	r7, r7, r7, LSR #16
+	STRH	r7, [r0, r9]
+	LDRB	r12,[r1, r10]		@ r12 = y3 = y_ptr[stride]
+	LDRB	r7, [r1], #1		@ r6  = y1 = *y_ptr++
+	ORR	r6, r6, r6, LSR #16
+	LDR	r12,[r14, r12,LSL #2]	@ r7  = y3 = y_table[y2]
+	STRH	r6, [r0], #2
+	LDR	r6, [r14, r7, LSL #2]	@ r6  = y1 = y_table[y0]
+
+	ADD	r7, r12,r11		@ r7  = y3 + uv
+	ADD	r7, r7, r5, LSR #DITH2	@ r7  = y3 + uv + dither2
+	ADD	r6, r6, r11		@ r6  = y1 + uv
+	ANDS	r12,r7, r5
+	TSTEQ	r6, r5
+	BNE	fix302
+return302:
+	AND	r7, r4, r7, LSR #3
+	AND	r6, r4, r6, LSR #3
+	ORR	r7, r7, r7, LSR #16
+	ORR	r6, r6, r6, LSR #16
+	STRH	r7, [r0, r9]
+	STRH	r6, [r0], #2
+	ADDS	r8, r8, #2<<16
+	BLT	xloop3
+	MOVS	r8, r8, LSL #16		@ Clear the top 16 bits of r8
+	MOV	r8, r8, LSR #16		@ If the C bit is clear we still have
+	BCC	trail_pair3		@ 1 more pixel pair to do
+end_xloop3:
+	LDR	r11,[r13,#9*4]		@ r11= width
+	LDR	r12,[r13,#12*4]		@ r12= uv_stride
+	ADD	r0, r0, r9, LSL #1
+	SUB	r0, r0, r11,LSL #1
+	ADD	r1, r1, r10,LSL #1
+	SUB	r1, r1, r11
+	SUB	r2, r2, r11,LSR #1
+	SUB	r3, r3, r11,LSR #1
+	ADD	r2, r2, r12
+	ADD	r3, r3, r12
+
+	SUBS	r8, r8, #2
+	BGT	yloop3
+
+	LDMLTFD	r13!,{r4-r11,pc}
+trail_row3:
+	@ We have a row of pixels left to do
+	SUB	r8, r8, r11,LSL #16	@ r8 = height-(width<<16)
+	ADDS	r8, r8, #1<<16		@ if (width == 1)
+	BGE	trail_pix3		@    just do 1 pixel
+xloop32:
+	LDRB	r11,[r2], #1		@ r11 = u  = *u_ptr++
+	LDRB	r12,[r3], #1		@ r12 = v  = *v_ptr++
+	LDRB	r6, [r1], #1		@ r6  = y0 = *y_ptr++
+	LDRB	r7, [r1], #1		@ r7  = y1 = *y_ptr++
+	ADD	r11,r11,#256
+	ADD	r12,r12,#512
+	LDR	r11,[r14,r11,LSL #2]	@ r11 = u  = u_table[u]
+	LDR	r12,[r14,r12,LSL #2]	@ r12 = v  = v_table[v]
+	LDR	r7, [r14,r7, LSL #2]	@ r7  = y1 = y_table[y1]
+	LDR	r6, [r14,r6, LSL #2]	@ r6  = y0 = y_table[y0]
+	ADD	r11,r11,r12		@ r11 = uv = u+v
+
+	ADD	r6, r6, r11		@ r6  = y0 + uv
+	ADD	r6, r6, r5, LSR #DITH1	@ r6  = y0 + uv + dither1
+	ADD	r7, r7, r11		@ r7  = y1 + uv
+	ADD	r6, r6, r5, LSR #DITH2	@ r6  = y0 + uv + dither3
+	ANDS	r12,r7, r5
+	TSTEQ	r6, r5
+	BNE	fix304
+return304:
+	AND	r6, r4, r6, LSR #3
+	AND	r7, r4, r7, LSR #3
+	ORR	r6, r6, r6, LSR #16
+	ORR	r7, r7, r7, LSR #16
+	STRH	r6, [r0], #2
+	STRH	r7, [r0], #2
+	ADDS	r8, r8, #2<<16
+	BLT	xloop32
+	MOVS	r8, r8, LSL #16		@ Clear the top 16 bits of r8
+	MOV	r8, r8, LSR #16		@ If the C bit is clear we still have
+	BCC	trail_pix3		@ 1 more pixel pair to do
+
+	LDMFD	r13!,{r4-r11,pc}
+trail_pix3:
+	@ We have a single extra pixel to do
+	LDRB	r11,[r2], #1		@ r11 = u  = *u_ptr++
+	LDRB	r12,[r3], #1		@ r12 = v  = *v_ptr++
+	LDRB	r6, [r1], #1		@ r6  = y0 = *y_ptr++
+	ADD	r11,r11,#256
+	ADD	r12,r12,#512
+	LDR	r11,[r14,r11,LSL #2]	@ r11 = u  = u_table[u]
+	LDR	r12,[r14,r12,LSL #2]	@ r12 = v  = v_table[v]
+	LDR	r6, [r14,r6, LSL #2]	@ r6  = y0 = y_table[y0]
+	ADD	r11,r11,r12		@ r11 = uv = u+v
+
+	ADD	r11,r11,r5, LSR #DITH1
+	ADD	r11,r11,r5, LSR #DITH2
+	ADD	r6, r6, r11		@ r6  = y0 + uv + dither3
+	ANDS	r12,r6, r5
+	BNE	fix305
+return305:
+	AND	r6, r4, r6, LSR #3
+	ORR	r6, r6, r6, LSR #16
+	STRH	r6, [r0], #2
+
+	LDMFD	r13!,{r4-r11,pc}
+
+trail_pair3:
+	@ We have a pair of pixels left to do
+	LDRB	r11,[r2]		@ r11 = u  = *u_ptr++
+	LDRB	r12,[r3]		@ r12 = v  = *v_ptr++
+	LDRB	r7, [r1, r10]		@ r7  = y2 = y_ptr[stride]
+	LDRB	r6, [r1], #1		@ r6  = y0 = *y_ptr++
+	ADD	r11,r11,#256
+	ADD	r12,r12,#512
+	LDR	r11,[r14,r11,LSL #2]	@ r11 = u  = u_table[u]
+	LDR	r12,[r14,r12,LSL #2]	@ r12 = v  = v_table[v]
+	LDR	r7, [r14,r7, LSL #2]	@ r7  = y2 = y_table[y2]
+	LDR	r6, [r14,r6, LSL #2]	@ r6  = y0 = y_table[y0]
+	ADD	r11,r11,r12		@ r11 = uv = u+v
+
+	ADD	r12,r11,r5, LSR #DITH1
+	ADD	r7, r7, r12		@ r7  = y2 + uv + dither1
+	ADD	r6, r6, r12		@ r6  = y0 + uv + dither1
+	ADD	r6, r6, r5, LSR #DITH2	@ r6  = y0 + uv + dither3
+	ANDS	r12,r7, r5
+	TSTEQ	r6, r5
+	BNE	fix303
+return303:
+	AND	r7, r4, r7, LSR #3
+	AND	r6, r4, r6, LSR #3
+	ORR	r7, r7, r7, LSR #16
+	ORR	r6, r6, r6, LSR #16
+	STRH	r7, [r0, r9]
+	STRH	r6, [r0], #2
+	B	end_xloop3
+fix301:
+	@ r7 and r6 are the values, at least one of which has overflowed
+	@ r12 = r7 & mask = .s......s......s......
+	SUB	r12,r12,r12,LSR #8	@ r12 = ..SSSSSS.SSSSSS.SSSSSS
+	ORR	r7, r7, r12		@ r7 |= ..SSSSSS.SSSSSS.SSSSSS
+	BIC	r12,r5, r7, LSR #1	@ r12 = .o......o......o......
+	ADD	r7, r7, r12,LSR #8	@ r7  = fixed value
+
+	AND	r12, r6, r5		@ r12 = .S......S......S......
+	SUB	r12,r12,r12,LSR #8	@ r12 = ..SSSSSS.SSSSSS.SSSSSS
+	ORR	r6, r6, r12		@ r6 |= ..SSSSSS.SSSSSS.SSSSSS
+	BIC	r12,r5, r6, LSR #1	@ r12 = .o......o......o......
+	ADD	r6, r6, r12,LSR #8	@ r6  = fixed value
+	B	return301
+fix302:
+	@ r7 and r6 are the values, at least one of which has overflowed
+	@ r12 = r7 & mask = .s......s......s......
+	SUB	r12,r12,r12,LSR #8	@ r12 = ..SSSSSS.SSSSSS.SSSSSS
+	ORR	r7, r7, r12		@ r7 |= ..SSSSSS.SSSSSS.SSSSSS
+	BIC	r12,r5, r7, LSR #1	@ r12 = .o......o......o......
+	ADD	r7, r7, r12,LSR #8	@ r7  = fixed value
+
+	AND	r12, r6, r5		@ r12 = .S......S......S......
+	SUB	r12,r12,r12,LSR #8	@ r12 = ..SSSSSS..SSSSS.SSSSSS
+	ORR	r6, r6, r12		@ r6 |= ..SSSSSS..SSSSS.SSSSSS
+	BIC	r12,r5, r6, LSR #1	@ r12 = .o......o......o......
+	ADD	r6, r6, r12,LSR #8	@ r6  = fixed value
+	B	return302
+fix303:
+	@ r7 and r6 are the values, at least one of which has overflowed
+	@ r12 = r7 & mask = .s......s......s......
+	SUB	r12,r12,r12,LSR #8	@ r12 = ..SSSSSS.SSSSSS.SSSSSS
+	ORR	r7, r7, r12		@ r7 |= ..SSSSSS.SSSSSS.SSSSSS
+	BIC	r12,r5, r7, LSR #1	@ r12 = .o......o......o......
+	ADD	r7, r7, r12,LSR #8	@ r7  = fixed value
+
+	AND	r12, r6, r5		@ r12 = .S......S......S......
+	SUB	r12,r12,r12,LSR #8	@ r12 = ..SSSSSS.SSSSSS.SSSSSS
+	ORR	r6, r6, r12		@ r6 |= ..SSSSSS.SSSSSS.SSSSSS
+	BIC	r12,r5, r6, LSR #1	@ r12 = .o......o......o......
+	ADD	r6, r6, r12,LSR #8	@ r6  = fixed value
+	B	return303
+fix304:
+	@ r7 and r6 are the values, at least one of which has overflowed
+	@ r12 = r7 & mask = .s......s......s......
+	SUB	r12,r12,r12,LSR #8	@ r12 = ..SSSSSS.SSSSSS.SSSSSS
+	ORR	r7, r7, r12		@ r7 |= ..SSSSSS.SSSSSS.SSSSSS
+	BIC	r12,r5, r7, LSR #1	@ r12 = .o......o......o......
+	ADD	r7, r7, r12,LSR #8	@ r7  = fixed value
+
+	AND	r12, r6, r5		@ r12 = .S......S......S......
+	SUB	r12,r12,r12,LSR #8	@ r12 = ..SSSSSS.SSSSSS.SSSSSS
+	ORR	r6, r6, r12		@ r6 |= ..SSSSSS.SSSSSS.SSSSSS
+	BIC	r12,r5, r6, LSR #1	@ r12 = .o......o......o......
+	ADD	r6, r6, r12,LSR #8	@ r6  = fixed value
+	B	return304
+fix305:
+	@ r6 is the value, which has has overflowed
+	@ r12 = r7 & mask = .s......s......s......
+	SUB	r12,r12,r12,LSR #8	@ r12 = ..SSSSSS.SSSSSS.SSSSSS
+	ORR	r6, r6, r12		@ r6 |= ..SSSSSS.SSSSSS.SSSSSS
+	BIC	r12,r5, r6, LSR #1	@ r12 = .o......o......o......
+	ADD	r6, r6, r12,LSR #8	@ r6  = fixed value
+	B	return305
+
+	@ END
diff -Nurp vlc-a/modules/arm_neon/yuv422rgb565.S vlc-b/modules/arm_neon/yuv422rgb565.S
--- vlc-a/modules/arm_neon/yuv422rgb565.S	1970-01-01 08:00:00.000000000 +0800
+++ vlc-b/modules/arm_neon/yuv422rgb565.S	2011-07-10 01:53:48.998262162 +0800
@@ -0,0 +1,898 @@
+@ YUV-> RGB conversion code Copyright (C) 2008 Robin Watts (robin;wss.co.uk).
+@
+@ Licensed under the GPL. If you need it under another license, contact me
+@ and ask.
+@
+@  This program is free software ; you can redistribute it and/or modify
+@  it under the terms of the GNU General Public License as published by
+@  the Free Software Foundation ; either version 2 of the License, or
+@  (at your option) any later version.
+@
+@  This program is distributed in the hope that it will be useful,
+@  but WITHOUT ANY WARRANTY ; without even the implied warranty of
+@  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+@  GNU General Public License for more details.
+@
+@  You should have received a copy of the GNU General Public License
+@  along with this program ; if not, write to the Free Software
+@  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+@
+@
+@ The algorithm used here is based heavily on one created by Sophie Wilson
+@ of Acorn/e-14/Broadcomm. Many thanks.
+@
+@ Additional tweaks (in the fast fixup code) are from Paul Gardiner.
+@
+@ The old implementation of YUV -> RGB did:
+@
+@ R = CLAMP((Y-16)*1.164 +           1.596*V)
+@ G = CLAMP((Y-16)*1.164 - 0.391*U - 0.813*V)
+@ B = CLAMP((Y-16)*1.164 + 2.018*U          )
+@
+@ Were going to bend that here as follows:
+@
+@ R = CLAMP(y +           1.596*V)
+@ G = CLAMP(y - 0.383*U - 0.813*V)
+@ B = CLAMP(y + 1.976*U          )
+@
+@ where y = 0               for       Y <=  16,
+@       y = (  Y-16)*1.164, for  16 < Y <= 239,
+@       y = (239-16)*1.164, for 239 < Y
+@
+@ i.e. We clamp Y to the 16 to 239 range (which it is supposed to be in
+@ anyway). We then pick the B_U factor so that B never exceeds 511. We then
+@ shrink the G_U factor in line with that to avoid a colour shift as much as
+@ possible.
+@
+@ Were going to use tables to do it faster, but rather than doing it using
+@ 5 tables as as the above suggests, were going to do it using just 3.
+@
+@ We do this by working in parallel within a 32 bit word, and using one
+@ table each for Y U and V.
+@
+@ Source Y values are    0 to 255, so    0.. 260 after scaling
+@ Source U values are -128 to 127, so  -49.. 49(G), -253..251(B) after
+@ Source V values are -128 to 127, so -204..203(R), -104..103(G) after
+@
+@ So total summed values:
+@ -223 <= R <= 481, -173 <= G <= 431, -253 <= B < 511
+@
+@ We need to pack R G and B into a 32 bit word, and because of Bs range we
+@ need 2 bits above the valid range of B to detect overflow, and another one
+@ to detect the sense of the overflow. We therefore adopt the following
+@ representation:
+@
+@ osGGGGGgggggosBBBBBbbbosRRRRRrrr
+@
+@ Each such word breaks down into 3 ranges.
+@
+@ osGGGGGggggg   osBBBBBbbb   osRRRRRrrr
+@
+@ Thus we have 8 bits for each B and R table entry, and 10 bits for G (good
+@ as G is the most noticable one). The s bit for each represents the sign,
+@ and o represents the overflow.
+@
+@ For R and B we pack the table by taking the 11 bit representation of their
+@ values, and toggling bit 10 in the U and V tables.
+@
+@ For the green case we calculate 4*G (thus effectively using 10 bits for the
+@ valid range) truncate to 12 bits. We toggle bit 11 in the Y table.
+
+@ Theorarm library
+@ Copyright (C) 2009 Robin Watts for Pinknoise Productions Ltd
+
+    .text
+
+	.global	yuv422_2_rgb565
+
+@ void yuv444_2_rgb565
+@  uint8_t *dst_ptr
+@  uint8_t *y_ptr
+@  uint8_t *u_ptr
+@  uint8_t *v_ptr
+@  int      width
+@  int      height
+@  int      y_span
+@  int      uv_span
+@  int      dst_span
+@  int     *tables
+@  int      dither
+
+ .set DITH1,	7
+ .set DITH2,	6
+
+CONST_mask:
+	.word	0x07E0F81F
+CONST_flags:
+	.word	0x40080100
+yuv422_2_rgb565:
+	@ r0 = dst_ptr
+	@ r1 = y_ptr
+	@ r2 = u_ptr
+	@ r3 = v_ptr
+	@ <> = width
+	@ <> = height
+	@ <> = y_span
+	@ <> = uv_span
+	@ <> = dst_span
+	@ <> = y_table
+	@ <> = dither
+	STMFD	r13!,{r4-r11,r14}
+
+	LDR	r11,[r13,#9*4]		@ r11= width
+	LDR	r8, [r13,#10*4]		@ r8 = height
+	LDR	r14,[r13,#14*4]		@ r14= y_table
+	LDR	r6, [r13,#15*4]		@ r11= dither
+	LDR	r4, CONST_mask
+	LDR	r5, CONST_flags
+	ADD	r9, r14,#256*4		@ r9 = u_table
+	ADD	r10,r14,#512*4		@ r10= v_table
+	ANDS	r6, r6, #3
+	BEQ	asm0
+	CMP	r6, #2
+	BEQ	asm3
+	BGT	asm2
+asm1:
+	@  Dither: 1 3
+	@          2 0
+yloop1:
+	SUB	r8, r8, r11,LSL #16	@ r8 = height-(width<<16)
+	ADDS	r8, r8, #1<<16		@ if (width == 1)
+	BGE	trail_pix10		@    just do 1 column
+xloop10:
+	LDRB	r11,[r2], #1		@ r11 = u0 = *u_ptr++
+	LDRB	r12,[r3], #1		@ r12 = v0 = *v_ptr++
+	LDRB	r6, [r1], #1		@ r6  = y0 = *y_ptr++
+	LDRB	r7, [r1], #1		@ r7  = y1 = *y_ptr++
+	LDR	r11,[r9, r11,LSL #2]	@ r11 = u  = u_table[u0]
+	LDR	r12,[r10,r12,LSL #2]	@ r12 = v  = v_table[v0]
+	LDR	r6, [r14,r6, LSL #2]	@ r6  = y0 = y_table[y0]
+	LDR	r7, [r14,r7, LSL #2]	@ r7  = y1 = y_table[y1]
+	ADD	r11,r11,r12
+	ADD	r11,r11,r5, LSR #DITH1
+	ADD	r6, r6, r11		@ r6 = y0 + u0 + v0 + dither1
+	ADD	r7, r7, r11
+	ADD	r7, r7, r5, LSR #DITH2	@ r7 = y1 + u1 + v1 + dither3
+
+	ANDS	r12,r7, r5
+	TSTEQ	r6, r5
+	BNE	fix101
+return101:
+	AND	r6, r4, r6, LSR #3
+	ORR	r6, r6, r6, LSR #16
+	STRH	r6, [r0], #2
+	AND	r7, r4, r7, LSR #3
+	ORR	r7, r7, r7, LSR #16
+	STRH	r7, [r0], #2
+	ADDS	r8, r8, #2<<16
+	BLT	xloop10
+	MOVS	r8, r8, LSL #16		@ Clear the top 16 bits of r8
+	MOV	r8, r8, LSR #16		@ If the C bit is clear we still have
+	BCC	trail_pix10		@ 1 more pixel to do
+trail_pix10ret:
+	LDR	r11,[r13,#9*4]		@ r11= width
+	LDR	r7, [r13,#11*4]		@ r7 = y_span
+	LDR	r12,[r13,#12*4]		@ r12= uv_stride
+	LDR	r6, [r13,#13*4]		@ r6 = dst_span
+	SUB	r0, r0, r11,LSL #1
+	ADD	r1, r1, r7
+	ADD	r0, r0, r6
+	SUB	r1, r1, r11
+	SUB	r2, r2, r11,LSR #1
+	SUB	r3, r3, r11,LSR #1
+	ADD	r2, r2, r12
+	ADD	r3, r3, r12
+
+	SUBS	r8, r8, #1
+	BEQ	end
+
+	@ Now we do the second row
+	SUB	r8, r8, r11,LSL #16	@ r8 = height-(width<<16)
+	ADDS	r8, r8, #1<<16		@ if (width == 1)
+	BGE	trail_pix11		@    just do 1 column
+xloop11:
+	LDRB	r11,[r2], #1		@ r11 = u2 = *u_ptr++
+	LDRB	r12,[r3], #1		@ r12 = v2 = *v_ptr++
+	LDRB	r7, [r1], #1		@ r6  = y2 = *y_ptr++
+	LDRB	r6, [r1], #1		@ r6  = y3 = *y_ptr++
+	LDR	r11,[r9, r11,LSL #2]	@ r11 = u2 = u_table[u2]
+	LDR	r12,[r10,r12,LSL #2]	@ r12 = v2 = v_table[v2]
+	LDR	r7, [r14,r7, LSL #2]	@ r6  = y2 = y_table[y2]
+	LDR	r6, [r14,r6, LSL #2]	@ r6  = y3 = y_table[y1]
+	ADD	r11,r11,r12
+	ADD	r7, r7, r11
+	ADD	r7, r7, r5, LSR #DITH2	@ r7 = y2 + u2 + v2 + dither2
+	ADD	r6, r6, r11
+
+	ANDS	r12,r7, r5
+	TSTEQ	r6, r5
+	BNE	fix102
+return102:
+	AND	r7, r4, r7, LSR #3
+	ORR	r7, r7, r7, LSR #16
+	STRH	r7, [r0], #2
+	AND	r6, r4, r6, LSR #3
+	ORR	r6, r6, r6, LSR #16
+	STRH	r6, [r0], #2
+	ADDS	r8, r8, #2<<16
+	BLT	xloop11
+	MOVS	r8, r8, LSL #16		@ Clear the top 16 bits of r8
+	MOV	r8, r8, LSR #16		@ If the C bit is clear we still have
+	BCC	trail_pix11		@ 1 more pixel to do
+trail_pix11ret:
+	LDR	r11,[r13,#9*4]		@ r11= width
+	LDR	r7, [r13,#11*4]		@ r7 = y_span
+	LDR	r12,[r13,#12*4]		@ r12= uv_stride
+	LDR	r6, [r13,#13*4]		@ r6 = dst_span
+	SUB	r0, r0, r11,LSL #1
+	ADD	r1, r1, r7
+	ADD	r0, r0, r6
+	SUB	r1, r1, r11
+	SUB	r2, r2, r11,LSR #1
+	SUB	r3, r3, r11,LSR #1
+	ADD	r2, r2, r12
+	ADD	r3, r3, r12
+
+	SUBS	r8, r8, #1
+	BNE	yloop1
+end:
+	LDMFD	r13!,{r4-r11,pc}
+trail_pix10:
+	@ We have a single extra pixel to do
+	LDRB	r6, [r1], #1		@ r6  = y0 = *y_ptr++
+	LDRB	r11,[r2]		@ r11 = u0 = *u_ptr++
+	LDRB	r12,[r3]		@ r12 = v0 = *v_ptr++
+	LDR	r6, [r14,r6, LSL #2]	@ r6  = y0 = y_table[y0]
+	LDR	r11,[r9, r11,LSL #2]	@ r11 = u0 = u_table[u]
+	LDR	r12,[r10,r12,LSL #2]	@ r12 = v0 = v_table[v]
+	ADD	r6, r6, r5, LSR #DITH1
+	ADD	r6, r6, r11
+	ADD	r6, r6, r12		@ r6  = y0 + uv + dither1
+	ANDS	r12,r6, r5
+	BNE	fix103
+return103:
+	AND	r6, r4, r6, LSR #3
+	ORR	r6, r6, r6, LSR #16
+	STRH	r6, [r0], #2
+	B	trail_pix10ret
+trail_pix11:
+	@ We have a single extra pixel to do
+	LDRB	r6, [r1], #1		@ r6  = y0 = *y_ptr++
+	LDRB	r11,[r2]		@ r11 = u0 = *u_ptr++
+	LDRB	r12,[r3]		@ r12 = v0 = *v_ptr++
+	LDR	r6, [r14,r6, LSL #2]	@ r6  = y0 = y_table[y0]
+	LDR	r11,[r9, r11,LSL #2]	@ r11 = u0 = u_table[u]
+	LDR	r12,[r10,r12,LSL #2]	@ r12 = v0 = v_table[v]
+	ADD	r6, r6, r5, LSR #DITH2
+	ADD	r6, r6, r11
+	ADD	r6, r6, r12		@ r6  = y0 + uv + dither2
+
+	ANDS	r12,r6, r5
+	BNE	fix104
+return104:
+	AND	r6, r4, r6, LSR #3
+	ORR	r6, r6, r6, LSR #16
+	STRH	r6, [r0], #2
+	B	trail_pix11ret
+
+	LDMFD	r13!,{r4-r11,pc}
+
+fix101:
+	@ r7 and r6 are the values, at least one of which has overflowed
+	@ r12 = r7 & mask = .s......s......s......
+	SUB	r12,r12,r12,LSR #8	@ r12 = ..SSSSSS.SSSSSS.SSSSSS
+	ORR	r7, r7, r12		@ r7 |= ..SSSSSS.SSSSSS.SSSSSS
+	BIC	r12,r5, r7, LSR #1	@ r12 = .o......o......o......
+	ADD	r7, r7, r12,LSR #8	@ r7  = fixed value
+
+	AND	r12, r6, r5		@ r12 = .S......S......S......
+	SUB	r12,r12,r12,LSR #8	@ r12 = ..SSSSSS.SSSSSS.SSSSSS
+	ORR	r6, r6, r12		@ r6 |= ..SSSSSS.SSSSSS.SSSSSS
+	BIC	r12,r5, r6, LSR #1	@ r12 = .o......o......o......
+	ADD	r6, r6, r12,LSR #8	@ r6  = fixed value
+	B	return101
+fix102:
+	@ r7 and r6 are the values, at least one of which has overflowed
+	@ r12 = r7 & mask = .s......s......s......
+	SUB	r12,r12,r12,LSR #8	@ r12 = ..SSSSSS.SSSSSS.SSSSSS
+	ORR	r7, r7, r12		@ r7 |= ..SSSSSS.SSSSSS.SSSSSS
+	BIC	r12,r5, r7, LSR #1	@ r12 = .o......o......o......
+	ADD	r7, r7, r12,LSR #8	@ r7  = fixed value
+
+	AND	r12, r6, r5		@ r12 = .S......S......S......
+	SUB	r12,r12,r12,LSR #8	@ r12 = ..SSSSSS..SSSSS.SSSSSS
+	ORR	r6, r6, r12		@ r6 |= ..SSSSSS..SSSSS.SSSSSS
+	BIC	r12,r5, r6, LSR #1	@ r12 = .o......o......o......
+	ADD	r6, r6, r12,LSR #8	@ r6  = fixed value
+	B	return102
+fix103:
+	@ r6 is the value, which has has overflowed
+	@ r12 = r7 & mask = .s......s......s......
+	SUB	r12,r12,r12,LSR #8	@ r12 = ..SSSSSS.SSSSSS.SSSSSS
+	ORR	r6, r6, r12		@ r6 |= ..SSSSSS.SSSSSS.SSSSSS
+	BIC	r12,r5, r6, LSR #1	@ r12 = .o......o......o......
+	ADD	r6, r6, r12,LSR #8	@ r6  = fixed value
+	B	return103
+fix104:
+	@ r6 is the value, which has has overflowed
+	@ r12 = r7 & mask = .s......s......s......
+	SUB	r12,r12,r12,LSR #8	@ r12 = ..SSSSSS.SSSSSS.SSSSSS
+	ORR	r6, r6, r12		@ r6 |= ..SSSSSS.SSSSSS.SSSSSS
+	BIC	r12,r5, r6, LSR #1	@ r12 = .o......o......o......
+	ADD	r6, r6, r12,LSR #8	@ r6  = fixed value
+	B	return104
+
+@------------------------------------------------------------------------
+asm0:
+	@  Dither: 0 2
+	@          3 1
+yloop0:
+	SUB	r8, r8, r11,LSL #16	@ r8 = height-(width<<16)
+	ADDS	r8, r8, #1<<16		@ if (width == 1)
+	BGE	trail_pix00		@    just do 1 column
+xloop00:
+	LDRB	r11,[r2], #1		@ r11 = u0 = *u_ptr++
+	LDRB	r12,[r3], #1		@ r12 = v0 = *v_ptr++
+	LDRB	r6, [r1], #1		@ r6  = y0 = *y_ptr++
+	LDRB	r7, [r1], #1		@ r7  = y1 = *y_ptr++
+	LDR	r11,[r9, r11,LSL #2]	@ r11 = u  = u_table[u0]
+	LDR	r12,[r10,r12,LSL #2]	@ r12 = v  = v_table[v0]
+	LDR	r6, [r14,r6, LSL #2]	@ r6  = y0 = y_table[y0]
+	LDR	r7, [r14,r7, LSL #2]	@ r7  = y1 = y_table[y1]
+	ADD	r11,r11,r12
+	ADD	r6, r6, r11
+	ADD	r7, r7, r11
+	ADD	r7, r7, r5, LSR #DITH2	@ r7 = y0 + u0 + v0 + dither2
+
+	ANDS	r12,r7, r5
+	TSTEQ	r6, r5
+	BNE	fix001
+return001:
+	AND	r6, r4, r6, LSR #3
+	ORR	r6, r6, r6, LSR #16
+	STRH	r6, [r0], #2
+	AND	r7, r4, r7, LSR #3
+	ORR	r7, r7, r7, LSR #16
+	STRH	r7, [r0], #2
+	ADDS	r8, r8, #2<<16
+	BLT	xloop00
+	MOVS	r8, r8, LSL #16		@ Clear the top 16 bits of r8
+	MOV	r8, r8, LSR #16		@ If the C bit is clear we still have
+	BCC	trail_pix00		@ 1 more pixel to do
+trail_pix00ret:
+	LDR	r11,[r13,#9*4]		@ r11= width
+	LDR	r7, [r13,#11*4]		@ r7 = y_span
+	LDR	r12,[r13,#12*4]		@ r12= uv_stride
+	LDR	r6, [r13,#13*4]		@ r6 = dst_span
+	SUB	r0, r0, r11,LSL #1
+	ADD	r1, r1, r7
+	ADD	r0, r0, r6
+	SUB	r1, r1, r11
+	SUB	r2, r2, r11,LSR #1
+	SUB	r3, r3, r11,LSR #1
+	ADD	r2, r2, r12
+	ADD	r3, r3, r12
+
+	SUBS	r8, r8, #1
+	BEQ	end0
+
+	@ Now we do the second row
+	SUB	r8, r8, r11,LSL #16	@ r8 = height-(width<<16)
+	ADDS	r8, r8, #1<<16		@ if (width == 1)
+	BGE	trail_pix01		@    just do 1 column
+xloop01:
+	LDRB	r11,[r2], #1		@ r11 = u2 = *u_ptr++
+	LDRB	r12,[r3], #1		@ r12 = v2 = *v_ptr++
+	LDRB	r7, [r1], #1		@ r6  = y2 = *y_ptr++
+	LDRB	r6, [r1], #1		@ r6  = y3 = *y_ptr++
+	LDR	r11,[r9, r11,LSL #2]	@ r11 = u2 = u_table[u2]
+	LDR	r12,[r10,r12,LSL #2]	@ r12 = v2 = v_table[v2]
+	LDR	r7, [r14,r7, LSL #2]	@ r6  = y2 = y_table[y2]
+	LDR	r6, [r14,r6, LSL #2]	@ r6  = y3 = y_table[y1]
+	ADD	r11,r11,r12
+	ADD	r11,r11,r5, LSR #DITH1
+	ADD	r7, r7, r5, LSR #DITH2
+	ADD	r7, r7, r11		@ r7 = y2 + u2 + v2 + dither3
+	ADD	r6, r6, r11		@ r6 = y3 + u3 + v3 + dither1
+
+	ANDS	r12,r7, r5
+	TSTEQ	r6, r5
+	BNE	fix002
+return002:
+	AND	r7, r4, r7, LSR #3
+	ORR	r7, r7, r7, LSR #16
+	STRH	r7, [r0], #2
+	AND	r6, r4, r6, LSR #3
+	ORR	r6, r6, r6, LSR #16
+	STRH	r6, [r0], #2
+	ADDS	r8, r8, #2<<16
+	BLT	xloop01
+	MOVS	r8, r8, LSL #16		@ Clear the top 16 bits of r8
+	MOV	r8, r8, LSR #16		@ If the C bit is clear we still have
+	BCC	trail_pix01		@ 1 more pixel to do
+trail_pix01ret:
+	LDR	r11,[r13,#9*4]		@ r11= width
+	LDR	r7, [r13,#11*4]		@ r7 = y_span
+	LDR	r12,[r13,#12*4]		@ r12= uv_stride
+	LDR	r6, [r13,#13*4]		@ r6 = dst_span
+	SUB	r0, r0, r11,LSL #1
+	ADD	r1, r1, r7
+	ADD	r0, r0, r6
+	SUB	r1, r1, r11
+	SUB	r2, r2, r11,LSR #1
+	SUB	r3, r3, r11,LSR #1
+	ADD	r2, r2, r12
+	ADD	r3, r3, r12
+
+	SUBS	r8, r8, #1
+	BNE	yloop0
+end0:
+	LDMFD	r13!,{r4-r11,pc}
+trail_pix00:
+	@ We have a single extra pixel to do
+	LDRB	r6, [r1], #1		@ r6  = y0 = *y_ptr++
+	LDRB	r11,[r2]		@ r11 = u0 = *u_ptr++
+	LDRB	r12,[r3]		@ r12 = v0 = *v_ptr++
+	LDR	r6, [r14,r6, LSL #2]	@ r6  = y0 = y_table[y0]
+	LDR	r11,[r9, r11,LSL #2]	@ r11 = u0 = u_table[u]
+	LDR	r12,[r10,r12,LSL #2]	@ r12 = v0 = v_table[v]
+	@ Stall on Xscale
+	ADD	r6, r6, r11
+	ADD	r6, r6, r12		@ r6  = y0 + uv
+	ANDS	r12,r6, r5
+	BNE	fix003
+return003:
+	AND	r6, r4, r6, LSR #3
+	ORR	r6, r6, r6, LSR #16
+	STRH	r6, [r0], #2
+	B	trail_pix00ret
+trail_pix01:
+	@ We have a single extra pixel to do
+	LDRB	r6, [r1], #1		@ r6  = y0 = *y_ptr++
+	LDRB	r11,[r2]		@ r11 = u0 = *u_ptr++
+	LDRB	r12,[r3]		@ r12 = v0 = *v_ptr++
+	LDR	r6, [r14,r6, LSL #2]	@ r6  = y0 = y_table[y0]
+	LDR	r11,[r9, r11,LSL #2]	@ r11 = u0 = u_table[u]
+	LDR	r12,[r10,r12,LSL #2]	@ r12 = v0 = v_table[v]
+	ADD	r6, r6, r5, LSR #DITH1
+	ADD	r6, r6, r5, LSR #DITH2
+	ADD	r6, r6, r11
+	ADD	r6, r6, r12		@ r6  = y0 + uv + dither3
+
+	ANDS	r12,r6, r5
+	BNE	fix004
+return004:
+	AND	r6, r4, r6, LSR #3
+	ORR	r6, r6, r6, LSR #16
+	STRH	r6, [r0], #2
+	B	trail_pix01ret
+
+	LDMFD	r13!,{r4-r11,pc}
+
+fix001:
+	@ r7 and r6 are the values, at least one of which has overflowed
+	@ r12 = r7 & mask = .s......s......s......
+	SUB	r12,r12,r12,LSR #8	@ r12 = ..SSSSSS.SSSSSS.SSSSSS
+	ORR	r7, r7, r12		@ r7 |= ..SSSSSS.SSSSSS.SSSSSS
+	BIC	r12,r5, r7, LSR #1	@ r12 = .o......o......o......
+	ADD	r7, r7, r12,LSR #8	@ r7  = fixed value
+
+	AND	r12, r6, r5		@ r12 = .S......S......S......
+	SUB	r12,r12,r12,LSR #8	@ r12 = ..SSSSSS.SSSSSS.SSSSSS
+	ORR	r6, r6, r12		@ r6 |= ..SSSSSS.SSSSSS.SSSSSS
+	BIC	r12,r5, r6, LSR #1	@ r12 = .o......o......o......
+	ADD	r6, r6, r12,LSR #8	@ r6  = fixed value
+	B	return001
+fix002:
+	@ r7 and r6 are the values, at least one of which has overflowed
+	@ r12 = r7 & mask = .s......s......s......
+	SUB	r12,r12,r12,LSR #8	@ r12 = ..SSSSSS.SSSSSS.SSSSSS
+	ORR	r7, r7, r12		@ r7 |= ..SSSSSS.SSSSSS.SSSSSS
+	BIC	r12,r5, r7, LSR #1	@ r12 = .o......o......o......
+	ADD	r7, r7, r12,LSR #8	@ r7  = fixed value
+
+	AND	r12, r6, r5		@ r12 = .S......S......S......
+	SUB	r12,r12,r12,LSR #8	@ r12 = ..SSSSSS..SSSSS.SSSSSS
+	ORR	r6, r6, r12		@ r6 |= ..SSSSSS..SSSSS.SSSSSS
+	BIC	r12,r5, r6, LSR #1	@ r12 = .o......o......o......
+	ADD	r6, r6, r12,LSR #8	@ r6  = fixed value
+	B	return002
+fix003:
+	@ r6 is the value, which has has overflowed
+	@ r12 = r7 & mask = .s......s......s......
+	SUB	r12,r12,r12,LSR #8	@ r12 = ..SSSSSS.SSSSSS.SSSSSS
+	ORR	r6, r6, r12		@ r6 |= ..SSSSSS.SSSSSS.SSSSSS
+	BIC	r12,r5, r6, LSR #1	@ r12 = .o......o......o......
+	ADD	r6, r6, r12,LSR #8	@ r6  = fixed value
+	B	return003
+fix004:
+	@ r6 is the value, which has has overflowed
+	@ r12 = r7 & mask = .s......s......s......
+	SUB	r12,r12,r12,LSR #8	@ r12 = ..SSSSSS.SSSSSS.SSSSSS
+	ORR	r6, r6, r12		@ r6 |= ..SSSSSS.SSSSSS.SSSSSS
+	BIC	r12,r5, r6, LSR #1	@ r12 = .o......o......o......
+	ADD	r6, r6, r12,LSR #8	@ r6  = fixed value
+	B	return004
+@------------------------------------------------------------------------
+asm2:
+	@  Dither: 2 0
+	@          1 3
+yloop2:
+	SUB	r8, r8, r11,LSL #16	@ r8 = height-(width<<16)
+	ADDS	r8, r8, #1<<16		@ if (width == 1)
+	BGE	trail_pix20		@    just do 1 column
+xloop20:
+	LDRB	r11,[r2], #1		@ r11 = u0 = *u_ptr++
+	LDRB	r12,[r3], #1		@ r12 = v0 = *v_ptr++
+	LDRB	r6, [r1], #1		@ r6  = y0 = *y_ptr++
+	LDRB	r7, [r1], #1		@ r7  = y1 = *y_ptr++
+	LDR	r11,[r9, r11,LSL #2]	@ r11 = u  = u_table[u0]
+	LDR	r12,[r10,r12,LSL #2]	@ r12 = v  = v_table[v0]
+	LDR	r6, [r14,r6, LSL #2]	@ r6  = y0 = y_table[y0]
+	LDR	r7, [r14,r7, LSL #2]	@ r7  = y1 = y_table[y1]
+	ADD	r11,r11,r12
+	ADD	r6, r6, r11
+	ADD	r6, r6, r5, LSR #DITH2	@ r6 = y0 + u0 + v0 + dither2
+	ADD	r7, r7, r11
+
+	ANDS	r12,r7, r5
+	TSTEQ	r6, r5
+	BNE	fix201
+return201:
+	AND	r6, r4, r6, LSR #3
+	ORR	r6, r6, r6, LSR #16
+	STRH	r6, [r0], #2
+	AND	r7, r4, r7, LSR #3
+	ORR	r7, r7, r7, LSR #16
+	STRH	r7, [r0], #2
+	ADDS	r8, r8, #2<<16
+	BLT	xloop20
+	MOVS	r8, r8, LSL #16		@ Clear the top 16 bits of r8
+	MOV	r8, r8, LSR #16		@ If the C bit is clear we still have
+	BCC	trail_pix20		@ 1 more pixel to do
+trail_pix20ret:
+	LDR	r11,[r13,#9*4]		@ r11= width
+	LDR	r7, [r13,#11*4]		@ r7 = y_span
+	LDR	r12,[r13,#12*4]		@ r12= uv_stride
+	LDR	r6, [r13,#13*4]		@ r6 = dst_span
+	SUB	r0, r0, r11,LSL #1
+	ADD	r1, r1, r7
+	ADD	r0, r0, r6
+	SUB	r1, r1, r11
+	SUB	r2, r2, r11,LSR #1
+	SUB	r3, r3, r11,LSR #1
+	ADD	r2, r2, r12
+	ADD	r3, r3, r12
+
+	SUBS	r8, r8, #1
+	BEQ	end2
+
+	@ Now we do the second row
+	SUB	r8, r8, r11,LSL #16	@ r8 = height-(width<<16)
+	ADDS	r8, r8, #1<<16		@ if (width == 1)
+	BGE	trail_pix21		@    just do 1 column
+xloop21:
+	LDRB	r11,[r2], #1		@ r11 = u2 = *u_ptr++
+	LDRB	r12,[r3], #1		@ r12 = v2 = *v_ptr++
+	LDRB	r7, [r1], #1		@ r6  = y2 = *y_ptr++
+	LDRB	r6, [r1], #1		@ r6  = y3 = *y_ptr++
+	LDR	r11,[r9, r11,LSL #2]	@ r11 = u2 = u_table[u2]
+	LDR	r12,[r10,r12,LSL #2]	@ r12 = v2 = v_table[v2]
+	LDR	r7, [r14,r7, LSL #2]	@ r6  = y2 = y_table[y2]
+	LDR	r6, [r14,r6, LSL #2]	@ r6  = y3 = y_table[y1]
+	ADD	r11,r11,r12
+	ADD	r11,r11,r5, LSR #DITH1
+	ADD	r7, r7, r11		@ r7 = y2 + u2 + v2 + dither1
+	ADD	r6, r6, r11
+	ADD	r6, r6, r5, LSR #DITH2	@ r6 = y3 + u3 + v3 + dither3
+
+	ANDS	r12,r7, r5
+	TSTEQ	r6, r5
+	BNE	fix202
+return202:
+	AND	r7, r4, r7, LSR #3
+	ORR	r7, r7, r7, LSR #16
+	STRH	r7, [r0], #2
+	AND	r6, r4, r6, LSR #3
+	ORR	r6, r6, r6, LSR #16
+	STRH	r6, [r0], #2
+	ADDS	r8, r8, #2<<16
+	BLT	xloop21
+	MOVS	r8, r8, LSL #16		@ Clear the top 16 bits of r8
+	MOV	r8, r8, LSR #16		@ If the C bit is clear we still have
+	BCC	trail_pix21		@ 1 more pixel to do
+trail_pix21ret:
+	LDR	r11,[r13,#9*4]		@ r11= width
+	LDR	r7, [r13,#11*4]		@ r7 = y_span
+	LDR	r12,[r13,#12*4]		@ r12= uv_stride
+	LDR	r6, [r13,#13*4]		@ r6 = dst_span
+	SUB	r0, r0, r11,LSL #1
+	ADD	r1, r1, r7
+	ADD	r0, r0, r6
+	SUB	r1, r1, r11
+	SUB	r2, r2, r11,LSR #1
+	SUB	r3, r3, r11,LSR #1
+	ADD	r2, r2, r12
+	ADD	r3, r3, r12
+
+	SUBS	r8, r8, #1
+	BNE	yloop2
+end2:
+	LDMFD	r13!,{r4-r11,pc}
+trail_pix20:
+	@ We have a single extra pixel to do
+	LDRB	r6, [r1], #1		@ r6  = y0 = *y_ptr++
+	LDRB	r11,[r2]		@ r11 = u0 = *u_ptr++
+	LDRB	r12,[r3]		@ r12 = v0 = *v_ptr++
+	LDR	r6, [r14,r6, LSL #2]	@ r6  = y0 = y_table[y0]
+	LDR	r11,[r9, r11,LSL #2]	@ r11 = u0 = u_table[u]
+	LDR	r12,[r10,r12,LSL #2]	@ r12 = v0 = v_table[v]
+	ADD	r6, r6, r5, LSR #DITH2
+	ADD	r6, r6, r11
+	ADD	r6, r6, r12		@ r6  = y0 + uv + dither2
+	ANDS	r12,r6, r5
+	BNE	fix203
+return203:
+	AND	r6, r4, r6, LSR #3
+	ORR	r6, r6, r6, LSR #16
+	STRH	r6, [r0], #2
+	B	trail_pix20ret
+trail_pix21:
+	@ We have a single extra pixel to do
+	LDRB	r6, [r1], #1		@ r6  = y0 = *y_ptr++
+	LDRB	r11,[r2]		@ r11 = u0 = *u_ptr++
+	LDRB	r12,[r3]		@ r12 = v0 = *v_ptr++
+	LDR	r6, [r14,r6, LSL #2]	@ r6  = y0 = y_table[y0]
+	LDR	r11,[r9, r11,LSL #2]	@ r11 = u0 = u_table[u]
+	LDR	r12,[r10,r12,LSL #2]	@ r12 = v0 = v_table[v]
+	ADD	r6, r6, r5, LSR #DITH1
+	ADD	r6, r6, r11
+	ADD	r6, r6, r12		@ r6  = y0 + uv + dither1
+
+	ANDS	r12,r6, r5
+	BNE	fix204
+return204:
+	AND	r6, r4, r6, LSR #3
+	ORR	r6, r6, r6, LSR #16
+	STRH	r6, [r0], #2
+	B	trail_pix21ret
+
+	LDMFD	r13!,{r4-r11,pc}
+
+fix201:
+	@ r7 and r6 are the values, at least one of which has overflowed
+	@ r12 = r7 & mask = .s......s......s......
+	SUB	r12,r12,r12,LSR #8	@ r12 = ..SSSSSS.SSSSSS.SSSSSS
+	ORR	r7, r7, r12		@ r7 |= ..SSSSSS.SSSSSS.SSSSSS
+	BIC	r12,r5, r7, LSR #1	@ r12 = .o......o......o......
+	ADD	r7, r7, r12,LSR #8	@ r7  = fixed value
+
+	AND	r12, r6, r5		@ r12 = .S......S......S......
+	SUB	r12,r12,r12,LSR #8	@ r12 = ..SSSSSS.SSSSSS.SSSSSS
+	ORR	r6, r6, r12		@ r6 |= ..SSSSSS.SSSSSS.SSSSSS
+	BIC	r12,r5, r6, LSR #1	@ r12 = .o......o......o......
+	ADD	r6, r6, r12,LSR #8	@ r6  = fixed value
+	B	return201
+fix202:
+	@ r7 and r6 are the values, at least one of which has overflowed
+	@ r12 = r7 & mask = .s......s......s......
+	SUB	r12,r12,r12,LSR #8	@ r12 = ..SSSSSS.SSSSSS.SSSSSS
+	ORR	r7, r7, r12		@ r7 |= ..SSSSSS.SSSSSS.SSSSSS
+	BIC	r12,r5, r7, LSR #1	@ r12 = .o......o......o......
+	ADD	r7, r7, r12,LSR #8	@ r7  = fixed value
+
+	AND	r12, r6, r5		@ r12 = .S......S......S......
+	SUB	r12,r12,r12,LSR #8	@ r12 = ..SSSSSS..SSSSS.SSSSSS
+	ORR	r6, r6, r12		@ r6 |= ..SSSSSS..SSSSS.SSSSSS
+	BIC	r12,r5, r6, LSR #1	@ r12 = .o......o......o......
+	ADD	r6, r6, r12,LSR #8	@ r6  = fixed value
+	B	return202
+fix203:
+	@ r6 is the value, which has has overflowed
+	@ r12 = r7 & mask = .s......s......s......
+	SUB	r12,r12,r12,LSR #8	@ r12 = ..SSSSSS.SSSSSS.SSSSSS
+	ORR	r6, r6, r12		@ r6 |= ..SSSSSS.SSSSSS.SSSSSS
+	BIC	r12,r5, r6, LSR #1	@ r12 = .o......o......o......
+	ADD	r6, r6, r12,LSR #8	@ r6  = fixed value
+	B	return203
+fix204:
+	@ r6 is the value, which has has overflowed
+	@ r12 = r7 & mask = .s......s......s......
+	SUB	r12,r12,r12,LSR #8	@ r12 = ..SSSSSS.SSSSSS.SSSSSS
+	ORR	r6, r6, r12		@ r6 |= ..SSSSSS.SSSSSS.SSSSSS
+	BIC	r12,r5, r6, LSR #1	@ r12 = .o......o......o......
+	ADD	r6, r6, r12,LSR #8	@ r6  = fixed value
+	B	return204
+@------------------------------------------------------------------------
+asm3:
+	@  Dither: 3 1
+	@          0 2
+yloop3:
+	SUB	r8, r8, r11,LSL #16	@ r8 = height-(width<<16)
+	ADDS	r8, r8, #1<<16		@ if (width == 1)
+	BGE	trail_pix30		@    just do 1 column
+xloop30:
+	LDRB	r11,[r2], #1		@ r11 = u0 = *u_ptr++
+	LDRB	r12,[r3], #1		@ r12 = v0 = *v_ptr++
+	LDRB	r6, [r1], #1		@ r6  = y0 = *y_ptr++
+	LDRB	r7, [r1], #1		@ r7  = y1 = *y_ptr++
+	LDR	r11,[r9, r11,LSL #2]	@ r11 = u  = u_table[u0]
+	LDR	r12,[r10,r12,LSL #2]	@ r12 = v  = v_table[v0]
+	LDR	r6, [r14,r6, LSL #2]	@ r6  = y0 = y_table[y0]
+	LDR	r7, [r14,r7, LSL #2]	@ r7  = y1 = y_table[y1]
+	ADD	r11,r11,r12
+	ADD	r11,r11,r5, LSR #DITH1
+	ADD	r6, r6, r11
+	ADD	r6, r6, r5, LSR #DITH2	@ r6 = y0 + u0 + v0 + dither3
+	ADD	r7, r7, r11
+
+	ANDS	r12,r7, r5
+	TSTEQ	r6, r5
+	BNE	fix301
+return301:
+	AND	r6, r4, r6, LSR #3
+	ORR	r6, r6, r6, LSR #16
+	STRH	r6, [r0], #2
+	AND	r7, r4, r7, LSR #3
+	ORR	r7, r7, r7, LSR #16
+	STRH	r7, [r0], #2
+	ADDS	r8, r8, #2<<16
+	BLT	xloop30
+	MOVS	r8, r8, LSL #16		@ Clear the top 16 bits of r8
+	MOV	r8, r8, LSR #16		@ If the C bit is clear we still have
+	BCC	trail_pix30		@ 1 more pixel to do
+trail_pix30ret:
+	LDR	r11,[r13,#9*4]		@ r11= width
+	LDR	r7, [r13,#11*4]		@ r7 = y_span
+	LDR	r12,[r13,#12*4]		@ r12= uv_stride
+	LDR	r6, [r13,#13*4]		@ r6 = dst_span
+	SUB	r0, r0, r11,LSL #1
+	ADD	r1, r1, r7
+	ADD	r0, r0, r6
+	SUB	r1, r1, r11
+	SUB	r2, r2, r11,LSR #1
+	SUB	r3, r3, r11,LSR #1
+	ADD	r2, r2, r12
+	ADD	r3, r3, r12
+
+	SUBS	r8, r8, #1
+	BEQ	end3
+
+	@ Now we do the second row
+	SUB	r8, r8, r11,LSL #16	@ r8 = height-(width<<16)
+	ADDS	r8, r8, #1<<16		@ if (width == 1)
+	BGE	trail_pix31		@    just do 1 column
+xloop31:
+	LDRB	r11,[r2], #1		@ r11 = u2 = *u_ptr++
+	LDRB	r12,[r3], #1		@ r12 = v2 = *v_ptr++
+	LDRB	r7, [r1], #1		@ r6  = y2 = *y_ptr++
+	LDRB	r6, [r1], #1		@ r6  = y3 = *y_ptr++
+	LDR	r11,[r9, r11,LSL #2]	@ r11 = u2 = u_table[u2]
+	LDR	r12,[r10,r12,LSL #2]	@ r12 = v2 = v_table[v2]
+	LDR	r7, [r14,r7, LSL #2]	@ r6  = y2 = y_table[y2]
+	LDR	r6, [r14,r6, LSL #2]	@ r6  = y3 = y_table[y1]
+	ADD	r11,r11,r12
+	ADD	r7, r7, r11		@ r7 = y2 + u2 + v2
+	ADD	r6, r6, r11
+	ADD	r6, r6, r5, LSR #DITH2	@ r6 = y3 + u3 + v3 + dither2
+
+	ANDS	r12,r7, r5
+	TSTEQ	r6, r5
+	BNE	fix302
+return302:
+	AND	r7, r4, r7, LSR #3
+	ORR	r7, r7, r7, LSR #16
+	STRH	r7, [r0], #2
+	AND	r6, r4, r6, LSR #3
+	ORR	r6, r6, r6, LSR #16
+	STRH	r6, [r0], #2
+	ADDS	r8, r8, #2<<16
+	BLT	xloop31
+	MOVS	r8, r8, LSL #16		@ Clear the top 16 bits of r8
+	MOV	r8, r8, LSR #16		@ If the C bit is clear we still have
+	BCC	trail_pix31		@ 1 more pixel to do
+trail_pix31ret:
+	LDR	r11,[r13,#9*4]		@ r11= width
+	LDR	r7, [r13,#11*4]		@ r7 = y_span
+	LDR	r12,[r13,#12*4]		@ r12= uv_stride
+	LDR	r6, [r13,#13*4]		@ r6 = dst_span
+	SUB	r0, r0, r11,LSL #1
+	ADD	r1, r1, r7
+	ADD	r0, r0, r6
+	SUB	r1, r1, r11
+	SUB	r2, r2, r11,LSR #1
+	SUB	r3, r3, r11,LSR #1
+	ADD	r2, r2, r12
+	ADD	r3, r3, r12
+
+	SUBS	r8, r8, #1
+	BNE	yloop3
+end3:
+	LDMFD	r13!,{r4-r11,pc}
+trail_pix30:
+	@ We have a single extra pixel to do
+	LDRB	r6, [r1], #1		@ r6  = y0 = *y_ptr++
+	LDRB	r11,[r2]		@ r11 = u0 = *u_ptr++
+	LDRB	r12,[r3]		@ r12 = v0 = *v_ptr++
+	LDR	r6, [r14,r6, LSL #2]	@ r6  = y0 = y_table[y0]
+	LDR	r11,[r9, r11,LSL #2]	@ r11 = u0 = u_table[u]
+	LDR	r12,[r10,r12,LSL #2]	@ r12 = v0 = v_table[v]
+	ADD	r6, r6, r5, LSR #DITH1
+	ADD	r6, r6, r5, LSR #DITH2
+	ADD	r6, r6, r11
+	ADD	r6, r6, r12		@ r6  = y0 + uv + dither3
+	ANDS	r12,r6, r5
+	BNE	fix303
+return303:
+	AND	r6, r4, r6, LSR #3
+	ORR	r6, r6, r6, LSR #16
+	STRH	r6, [r0], #2
+	B	trail_pix30ret
+trail_pix31:
+	@ We have a single extra pixel to do
+	LDRB	r6, [r1], #1		@ r6  = y0 = *y_ptr++
+	LDRB	r11,[r2]		@ r11 = u0 = *u_ptr++
+	LDRB	r12,[r3]		@ r12 = v0 = *v_ptr++
+	LDR	r6, [r14,r6, LSL #2]	@ r6  = y0 = y_table[y0]
+	LDR	r11,[r9, r11,LSL #2]	@ r11 = u0 = u_table[u]
+	LDR	r12,[r10,r12,LSL #2]	@ r12 = v0 = v_table[v]
+	@ Stall on Xscale
+	ADD	r6, r6, r11
+	ADD	r6, r6, r12		@ r6  = y0 + uv
+
+	ANDS	r12,r6, r5
+	BNE	fix304
+return304:
+	AND	r6, r4, r6, LSR #3
+	ORR	r6, r6, r6, LSR #16
+	STRH	r6, [r0], #2
+	B	trail_pix31ret
+
+	LDMFD	r13!,{r4-r11,pc}
+
+fix301:
+	@ r7 and r6 are the values, at least one of which has overflowed
+	@ r12 = r7 & mask = .s......s......s......
+	SUB	r12,r12,r12,LSR #8	@ r12 = ..SSSSSS.SSSSSS.SSSSSS
+	ORR	r7, r7, r12		@ r7 |= ..SSSSSS.SSSSSS.SSSSSS
+	BIC	r12,r5, r7, LSR #1	@ r12 = .o......o......o......
+	ADD	r7, r7, r12,LSR #8	@ r7  = fixed value
+
+	AND	r12, r6, r5		@ r12 = .S......S......S......
+	SUB	r12,r12,r12,LSR #8	@ r12 = ..SSSSSS.SSSSSS.SSSSSS
+	ORR	r6, r6, r12		@ r6 |= ..SSSSSS.SSSSSS.SSSSSS
+	BIC	r12,r5, r6, LSR #1	@ r12 = .o......o......o......
+	ADD	r6, r6, r12,LSR #8	@ r6  = fixed value
+	B	return301
+fix302:
+	@ r7 and r6 are the values, at least one of which has overflowed
+	@ r12 = r7 & mask = .s......s......s......
+	SUB	r12,r12,r12,LSR #8	@ r12 = ..SSSSSS.SSSSSS.SSSSSS
+	ORR	r7, r7, r12		@ r7 |= ..SSSSSS.SSSSSS.SSSSSS
+	BIC	r12,r5, r7, LSR #1	@ r12 = .o......o......o......
+	ADD	r7, r7, r12,LSR #8	@ r7  = fixed value
+
+	AND	r12, r6, r5		@ r12 = .S......S......S......
+	SUB	r12,r12,r12,LSR #8	@ r12 = ..SSSSSS..SSSSS.SSSSSS
+	ORR	r6, r6, r12		@ r6 |= ..SSSSSS..SSSSS.SSSSSS
+	BIC	r12,r5, r6, LSR #1	@ r12 = .o......o......o......
+	ADD	r6, r6, r12,LSR #8	@ r6  = fixed value
+	B	return302
+fix303:
+	@ r6 is the value, which has has overflowed
+	@ r12 = r7 & mask = .s......s......s......
+	SUB	r12,r12,r12,LSR #8	@ r12 = ..SSSSSS.SSSSSS.SSSSSS
+	ORR	r6, r6, r12		@ r6 |= ..SSSSSS.SSSSSS.SSSSSS
+	BIC	r12,r5, r6, LSR #1	@ r12 = .o......o......o......
+	ADD	r6, r6, r12,LSR #8	@ r6  = fixed value
+	B	return303
+fix304:
+	@ r6 is the value, which has has overflowed
+	@ r12 = r7 & mask = .s......s......s......
+	SUB	r12,r12,r12,LSR #8	@ r12 = ..SSSSSS.SSSSSS.SSSSSS
+	ORR	r6, r6, r12		@ r6 |= ..SSSSSS.SSSSSS.SSSSSS
+	BIC	r12,r5, r6, LSR #1	@ r12 = .o......o......o......
+	ADD	r6, r6, r12,LSR #8	@ r6  = fixed value
+	B	return304
+
+	@ END
diff -Nurp vlc-a/modules/arm_neon/yuv444rgb565.S vlc-b/modules/arm_neon/yuv444rgb565.S
--- vlc-a/modules/arm_neon/yuv444rgb565.S	1970-01-01 08:00:00.000000000 +0800
+++ vlc-b/modules/arm_neon/yuv444rgb565.S	2011-07-10 01:53:48.998262162 +0800
@@ -0,0 +1,950 @@
+@ YUV-> RGB conversion code Copyright (C) 2008 Robin Watts (robin;wss.co.uk).
+@
+@ Licensed under the GPL. If you need it under another license, contact me
+@ and ask.
+@
+@  This program is free software ; you can redistribute it and/or modify
+@  it under the terms of the GNU General Public License as published by
+@  the Free Software Foundation ; either version 2 of the License, or
+@  (at your option) any later version.
+@
+@  This program is distributed in the hope that it will be useful,
+@  but WITHOUT ANY WARRANTY ; without even the implied warranty of
+@  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+@  GNU General Public License for more details.
+@
+@  You should have received a copy of the GNU General Public License
+@  along with this program ; if not, write to the Free Software
+@  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+@
+@
+@ The algorithm used here is based heavily on one created by Sophie Wilson
+@ of Acorn/e-14/Broadcomm. Many thanks.
+@
+@ Additional tweaks (in the fast fixup code) are from Paul Gardiner.
+@
+@ The old implementation of YUV -> RGB did:
+@
+@ R = CLAMP((Y-16)*1.164 +           1.596*V)
+@ G = CLAMP((Y-16)*1.164 - 0.391*U - 0.813*V)
+@ B = CLAMP((Y-16)*1.164 + 2.018*U          )
+@
+@ Were going to bend that here as follows:
+@
+@ R = CLAMP(y +           1.596*V)
+@ G = CLAMP(y - 0.383*U - 0.813*V)
+@ B = CLAMP(y + 1.976*U          )
+@
+@ where y = 0               for       Y <=  16,
+@       y = (  Y-16)*1.164, for  16 < Y <= 239,
+@       y = (239-16)*1.164, for 239 < Y
+@
+@ i.e. We clamp Y to the 16 to 239 range (which it is supposed to be in
+@ anyway). We then pick the B_U factor so that B never exceeds 511. We then
+@ shrink the G_U factor in line with that to avoid a colour shift as much as
+@ possible.
+@
+@ Were going to use tables to do it faster, but rather than doing it using
+@ 5 tables as as the above suggests, were going to do it using just 3.
+@
+@ We do this by working in parallel within a 32 bit word, and using one
+@ table each for Y U and V.
+@
+@ Source Y values are    0 to 255, so    0.. 260 after scaling
+@ Source U values are -128 to 127, so  -49.. 49(G), -253..251(B) after
+@ Source V values are -128 to 127, so -204..203(R), -104..103(G) after
+@
+@ So total summed values:
+@ -223 <= R <= 481, -173 <= G <= 431, -253 <= B < 511
+@
+@ We need to pack R G and B into a 32 bit word, and because of Bs range we
+@ need 2 bits above the valid range of B to detect overflow, and another one
+@ to detect the sense of the overflow. We therefore adopt the following
+@ representation:
+@
+@ osGGGGGgggggosBBBBBbbbosRRRRRrrr
+@
+@ Each such word breaks down into 3 ranges.
+@
+@ osGGGGGggggg   osBBBBBbbb   osRRRRRrrr
+@
+@ Thus we have 8 bits for each B and R table entry, and 10 bits for G (good
+@ as G is the most noticable one). The s bit for each represents the sign,
+@ and o represents the overflow.
+@
+@ For R and B we pack the table by taking the 11 bit representation of their
+@ values, and toggling bit 10 in the U and V tables.
+@
+@ For the green case we calculate 4*G (thus effectively using 10 bits for the
+@ valid range) truncate to 12 bits. We toggle bit 11 in the Y table.
+
+@ Theorarm library
+@ Copyright (C) 2009 Robin Watts for Pinknoise Productions Ltd
+
+    .text
+
+	.global	yuv444_2_rgb565
+
+@ void yuv444_2_rgb565
+@  uint8_t *dst_ptr
+@  uint8_t *y_ptr
+@  uint8_t *u_ptr
+@  uint8_t *v_ptr
+@  int      width
+@  int      height
+@  int      y_span
+@  int      uv_span
+@  int      dst_span
+@  int     *tables
+@  int      dither
+
+ .set DITH1,	7
+ .set DITH2,	6
+
+CONST_mask:
+	.word	0x07E0F81F
+CONST_flags:
+	.word	0x40080100
+yuv444_2_rgb565:
+	@ r0 = dst_ptr
+	@ r1 = y_ptr
+	@ r2 = u_ptr
+	@ r3 = v_ptr
+	@ <> = width
+	@ <> = height
+	@ <> = y_span
+	@ <> = uv_span
+	@ <> = dst_span
+	@ <> = y_table
+	@ <> = dither
+	STMFD	r13!,{r4-r11,r14}
+
+	LDR	r11,[r13,#9*4]		@ r11= width
+	LDR	r8, [r13,#10*4]		@ r8 = height
+	LDR	r14,[r13,#14*4]		@ r14= y_table
+	LDR	r6, [r13,#15*4]		@ r11= dither
+	LDR	r4, CONST_mask
+	LDR	r5, CONST_flags
+	ADD	r9, r14,#256*4		@ r9 = u_table
+	ADD	r10,r14,#512*4		@ r10= v_table
+	ANDS	r6, r6, #3
+	BEQ	asm0
+	CMP	r6, #2
+	BEQ	asm3
+	BGT	asm2
+asm1:
+	@  Dither: 1 3
+	@          2 0
+yloop1:
+	SUB	r8, r8, r11,LSL #16	@ r8 = height-(width<<16)
+	ADDS	r8, r8, #1<<16		@ if (width == 1)
+	BGE	trail_pix10		@    just do 1 column
+xloop10:
+	LDRB	r6, [r1], #1		@ r6  = y0 = *y_ptr++
+	LDRB	r11,[r2], #1		@ r11 = u0 = *u_ptr++
+	LDRB	r12,[r3], #1		@ r12 = v0 = *v_ptr++
+	LDR	r6, [r14,r6, LSL #2]	@ r6  = y0 = y_table[y0]
+	LDR	r11,[r9, r11,LSL #2]	@ r11 = u  = u_table[u0]
+	LDR	r12,[r10,r12,LSL #2]	@ r12 = v  = v_table[v0]
+	ADD	r6, r6, r11
+	ADD	r6, r6, r12
+	ADD	r6, r6, r5, LSR #DITH1	@ r6 = y0 + u0 + v0 + dither1
+
+	LDRB	r7, [r1], #1		@ r7  = y1 = *y_ptr++
+	LDRB	r11,[r2], #1		@ r11 = u1 = *u_ptr++
+	LDRB	r12,[r3], #1		@ r12 = v1 = *v_ptr++
+	LDR	r7, [r14,r7, LSL #2]	@ r7  = y1 = y_table[y1]
+	LDR	r11,[r9, r11,LSL #2]	@ r11 = u1 = u_table[u1]
+	LDR	r12,[r10,r12,LSL #2]	@ r12 = v1 = v_table[v1]
+	ADD	r7, r7, r5, LSR #DITH1
+	ADD	r7, r7, r11
+	ADD	r7, r7, r12
+	ADD	r7, r7, r5, LSR #DITH2	@ r7 = y0 + u0 + v0 + dither3
+
+	ANDS	r12,r7, r5
+	TSTEQ	r6, r5
+	BNE	fix101
+return101:
+	AND	r6, r4, r6, LSR #3
+	ORR	r6, r6, r6, LSR #16
+	STRH	r6, [r0], #2
+	AND	r7, r4, r7, LSR #3
+	ORR	r7, r7, r7, LSR #16
+	STRH	r7, [r0], #2
+	ADDS	r8, r8, #2<<16
+	BLT	xloop10
+	MOVS	r8, r8, LSL #16		@ Clear the top 16 bits of r8
+	MOV	r8, r8, LSR #16		@ If the C bit is clear we still have
+	BCC	trail_pix10		@ 1 more pixel to do
+trail_pix10ret:
+	LDR	r11,[r13,#9*4]		@ r11= width
+	LDR	r7, [r13,#11*4]		@ r7 = y_span
+	LDR	r12,[r13,#12*4]		@ r12= uv_stride
+	LDR	r6, [r13,#13*4]		@ r6 = dst_span
+	SUB	r0, r0, r11,LSL #1
+	ADD	r1, r1, r7
+	ADD	r0, r0, r6
+	SUB	r1, r1, r11
+	SUB	r2, r2, r11
+	SUB	r3, r3, r11
+	ADD	r2, r2, r12
+	ADD	r3, r3, r12
+
+	SUBS	r8, r8, #1
+	BEQ	end
+
+	@ Now we do the second row
+	SUB	r8, r8, r11,LSL #16	@ r8 = height-(width<<16)
+	ADDS	r8, r8, #1<<16		@ if (width == 1)
+	BGE	trail_pix11		@    just do 1 column
+xloop11:
+	LDRB	r7, [r1], #1		@ r6  = y2 = *y_ptr++
+	LDRB	r11,[r2], #1		@ r11 = u2 = *u_ptr++
+	LDRB	r12,[r3], #1		@ r12 = v2 = *v_ptr++
+	LDR	r7, [r14,r7, LSL #2]	@ r6  = y2 = y_table[y2]
+	LDR	r11,[r9, r11,LSL #2]	@ r11 = u2 = u_table[u2]
+	LDR	r12,[r10,r12,LSL #2]	@ r12 = v2 = v_table[v2]
+	LDRB	r6, [r1], #1		@ r6  = y3 = *y_ptr++
+	ADD	r7, r7, r11
+	ADD	r7, r7, r12		@ r7 = y2 + u2 + v2 + dither2
+
+	LDRB	r11,[r2], #1		@ r11 = u3 = *u_ptr++
+	LDRB	r12,[r3], #1		@ r12 = v3 = *v_ptr++
+	LDR	r6, [r14,r6, LSL #2]	@ r6  = y3 = y_table[y1]
+	LDR	r11,[r9, r11,LSL #2]	@ r11 = u3 = u_table[u1]
+	LDR	r12,[r10,r12,LSL #2]	@ r12 = v3 = v_table[v1]
+	ADD	r7, r7, r5, LSR #DITH2
+	ADD	r6, r6, r11
+	ADD	r6, r6, r12
+
+	ANDS	r12,r7, r5
+	TSTEQ	r6, r5
+	BNE	fix102
+return102:
+	AND	r7, r4, r7, LSR #3
+	ORR	r7, r7, r7, LSR #16
+	STRH	r7, [r0], #2
+	AND	r6, r4, r6, LSR #3
+	ORR	r6, r6, r6, LSR #16
+	STRH	r6, [r0], #2
+	ADDS	r8, r8, #2<<16
+	BLT	xloop11
+	MOVS	r8, r8, LSL #16		@ Clear the top 16 bits of r8
+	MOV	r8, r8, LSR #16		@ If the C bit is clear we still have
+	BCC	trail_pix11		@ 1 more pixel to do
+trail_pix11ret:
+	LDR	r11,[r13,#9*4]		@ r11= width
+	LDR	r7, [r13,#11*4]		@ r7 = y_span
+	LDR	r12,[r13,#12*4]		@ r12= uv_stride
+	LDR	r6, [r13,#13*4]		@ r6 = dst_span
+	SUB	r0, r0, r11,LSL #1
+	ADD	r1, r1, r7
+	ADD	r0, r0, r6
+	SUB	r1, r1, r11
+	SUB	r2, r2, r11
+	SUB	r3, r3, r11
+	ADD	r2, r2, r12
+	ADD	r3, r3, r12
+
+	SUBS	r8, r8, #1
+	BNE	yloop1
+end:
+	LDMFD	r13!,{r4-r11,pc}
+trail_pix10:
+	@ We have a single extra pixel to do
+	LDRB	r6, [r1], #1		@ r6  = y0 = *y_ptr++
+	LDRB	r11,[r2], #1		@ r11 = u0 = *u_ptr++
+	LDRB	r12,[r3], #1		@ r12 = v0 = *v_ptr++
+	LDR	r6, [r14,r6, LSL #2]	@ r6  = y0 = y_table[y0]
+	LDR	r11,[r9, r11,LSL #2]	@ r11 = u0 = u_table[u]
+	LDR	r12,[r10,r12,LSL #2]	@ r12 = v0 = v_table[v]
+	ADD	r6, r6, r5, LSR #DITH1
+	ADD	r6, r6, r11
+	ADD	r6, r6, r12		@ r6  = y0 + uv + dither1
+	ANDS	r12,r6, r5
+	BNE	fix103
+return103:
+	AND	r6, r4, r6, LSR #3
+	ORR	r6, r6, r6, LSR #16
+	STRH	r6, [r0], #2
+	B	trail_pix10ret
+trail_pix11:
+	@ We have a single extra pixel to do
+	LDRB	r6, [r1], #1		@ r6  = y0 = *y_ptr++
+	LDRB	r11,[r2], #1		@ r11 = u0 = *u_ptr++
+	LDRB	r12,[r3], #1		@ r12 = v0 = *v_ptr++
+	LDR	r6, [r14,r6, LSL #2]	@ r6  = y0 = y_table[y0]
+	LDR	r11,[r9, r11,LSL #2]	@ r11 = u0 = u_table[u]
+	LDR	r12,[r10,r12,LSL #2]	@ r12 = v0 = v_table[v]
+	ADD	r6, r6, r5, LSR #DITH2
+	ADD	r6, r6, r11
+	ADD	r6, r6, r12		@ r6  = y0 + uv + dither2
+
+	ANDS	r12,r6, r5
+	BNE	fix104
+return104:
+	AND	r6, r4, r6, LSR #3
+	ORR	r6, r6, r6, LSR #16
+	STRH	r6, [r0], #2
+	B	trail_pix11ret
+
+	LDMFD	r13!,{r4-r11,pc}
+
+fix101:
+	@ r7 and r6 are the values, at least one of which has overflowed
+	@ r12 = r7 & mask = .s......s......s......
+	SUB	r12,r12,r12,LSR #8	@ r12 = ..SSSSSS.SSSSSS.SSSSSS
+	ORR	r7, r7, r12		@ r7 |= ..SSSSSS.SSSSSS.SSSSSS
+	BIC	r12,r5, r7, LSR #1	@ r12 = .o......o......o......
+	ADD	r7, r7, r12,LSR #8	@ r7  = fixed value
+
+	AND	r12, r6, r5		@ r12 = .S......S......S......
+	SUB	r12,r12,r12,LSR #8	@ r12 = ..SSSSSS.SSSSSS.SSSSSS
+	ORR	r6, r6, r12		@ r6 |= ..SSSSSS.SSSSSS.SSSSSS
+	BIC	r12,r5, r6, LSR #1	@ r12 = .o......o......o......
+	ADD	r6, r6, r12,LSR #8	@ r6  = fixed value
+	B	return101
+fix102:
+	@ r7 and r6 are the values, at least one of which has overflowed
+	@ r12 = r7 & mask = .s......s......s......
+	SUB	r12,r12,r12,LSR #8	@ r12 = ..SSSSSS.SSSSSS.SSSSSS
+	ORR	r7, r7, r12		@ r7 |= ..SSSSSS.SSSSSS.SSSSSS
+	BIC	r12,r5, r7, LSR #1	@ r12 = .o......o......o......
+	ADD	r7, r7, r12,LSR #8	@ r7  = fixed value
+
+	AND	r12, r6, r5		@ r12 = .S......S......S......
+	SUB	r12,r12,r12,LSR #8	@ r12 = ..SSSSSS..SSSSS.SSSSSS
+	ORR	r6, r6, r12		@ r6 |= ..SSSSSS..SSSSS.SSSSSS
+	BIC	r12,r5, r6, LSR #1	@ r12 = .o......o......o......
+	ADD	r6, r6, r12,LSR #8	@ r6  = fixed value
+	B	return102
+fix103:
+	@ r6 is the value, which has has overflowed
+	@ r12 = r7 & mask = .s......s......s......
+	SUB	r12,r12,r12,LSR #8	@ r12 = ..SSSSSS.SSSSSS.SSSSSS
+	ORR	r6, r6, r12		@ r6 |= ..SSSSSS.SSSSSS.SSSSSS
+	BIC	r12,r5, r6, LSR #1	@ r12 = .o......o......o......
+	ADD	r6, r6, r12,LSR #8	@ r6  = fixed value
+	B	return103
+fix104:
+	@ r6 is the value, which has has overflowed
+	@ r12 = r7 & mask = .s......s......s......
+	SUB	r12,r12,r12,LSR #8	@ r12 = ..SSSSSS.SSSSSS.SSSSSS
+	ORR	r6, r6, r12		@ r6 |= ..SSSSSS.SSSSSS.SSSSSS
+	BIC	r12,r5, r6, LSR #1	@ r12 = .o......o......o......
+	ADD	r6, r6, r12,LSR #8	@ r6  = fixed value
+	B	return104
+
+@------------------------------------------------------------------------
+asm0:
+	@  Dither: 0 2
+	@          3 1
+yloop0:
+	SUB	r8, r8, r11,LSL #16	@ r8 = height-(width<<16)
+	ADDS	r8, r8, #1<<16		@ if (width == 1)
+	BGE	trail_pix00		@    just do 1 column
+xloop00:
+	LDRB	r6, [r1], #1		@ r6  = y0 = *y_ptr++
+	LDRB	r11,[r2], #1		@ r11 = u0 = *u_ptr++
+	LDRB	r12,[r3], #1		@ r12 = v0 = *v_ptr++
+	LDR	r6, [r14,r6, LSL #2]	@ r6  = y0 = y_table[y0]
+	LDR	r11,[r9, r11,LSL #2]	@ r11 = u  = u_table[u0]
+	LDR	r12,[r10,r12,LSL #2]	@ r12 = v  = v_table[v0]
+	LDRB	r7, [r1], #1		@ r7  = y1 = *y_ptr++
+	ADD	r6, r6, r11
+	ADD	r6, r6, r12
+
+	LDRB	r11,[r2], #1		@ r11 = u1 = *u_ptr++
+	LDRB	r12,[r3], #1		@ r12 = v1 = *v_ptr++
+	LDR	r7, [r14,r7, LSL #2]	@ r7  = y1 = y_table[y1]
+	LDR	r11,[r9, r11,LSL #2]	@ r11 = u1 = u_table[u1]
+	LDR	r12,[r10,r12,LSL #2]	@ r12 = v1 = v_table[v1]
+	ADD	r7, r7, r5, LSR #DITH2
+	ADD	r7, r7, r11
+	ADD	r7, r7, r12		@ r7 = y0 + u0 + v0 + dither2
+
+	ANDS	r12,r7, r5
+	TSTEQ	r6, r5
+	BNE	fix001
+return001:
+	AND	r6, r4, r6, LSR #3
+	ORR	r6, r6, r6, LSR #16
+	STRH	r6, [r0], #2
+	AND	r7, r4, r7, LSR #3
+	ORR	r7, r7, r7, LSR #16
+	STRH	r7, [r0], #2
+	ADDS	r8, r8, #2<<16
+	BLT	xloop00
+	MOVS	r8, r8, LSL #16		@ Clear the top 16 bits of r8
+	MOV	r8, r8, LSR #16		@ If the C bit is clear we still have
+	BCC	trail_pix00		@ 1 more pixel to do
+trail_pix00ret:
+	LDR	r11,[r13,#9*4]		@ r11= width
+	LDR	r7, [r13,#11*4]		@ r7 = y_span
+	LDR	r12,[r13,#12*4]		@ r12= uv_stride
+	LDR	r6, [r13,#13*4]		@ r6 = dst_span
+	SUB	r0, r0, r11,LSL #1
+	ADD	r1, r1, r7
+	ADD	r0, r0, r6
+	SUB	r1, r1, r11
+	SUB	r2, r2, r11
+	SUB	r3, r3, r11
+	ADD	r2, r2, r12
+	ADD	r3, r3, r12
+
+	SUBS	r8, r8, #1
+	BEQ	end0
+
+	@ Now we do the second row
+	SUB	r8, r8, r11,LSL #16	@ r8 = height-(width<<16)
+	ADDS	r8, r8, #1<<16		@ if (width == 1)
+	BGE	trail_pix01		@    just do 1 column
+xloop01:
+	LDRB	r7, [r1], #1		@ r6  = y2 = *y_ptr++
+	LDRB	r11,[r2], #1		@ r11 = u2 = *u_ptr++
+	LDRB	r12,[r3], #1		@ r12 = v2 = *v_ptr++
+	LDR	r7, [r14,r7, LSL #2]	@ r6  = y2 = y_table[y2]
+	LDR	r11,[r9, r11,LSL #2]	@ r11 = u2 = u_table[u2]
+	LDR	r12,[r10,r12,LSL #2]	@ r12 = v2 = v_table[v2]
+	ADD	r7, r7, r5, LSR #DITH1
+	ADD	r7, r7, r5, LSR #DITH2
+	ADD	r7, r7, r11
+	ADD	r7, r7, r12		@ r7 = y2 + u2 + v2 + dither3
+
+	LDRB	r6, [r1], #1		@ r6  = y3 = *y_ptr++
+	LDRB	r11,[r2], #1		@ r11 = u3 = *u_ptr++
+	LDRB	r12,[r3], #1		@ r12 = v3 = *v_ptr++
+	LDR	r6, [r14,r6, LSL #2]	@ r6  = y3 = y_table[y1]
+	LDR	r11,[r9, r11,LSL #2]	@ r11 = u3 = u_table[u1]
+	LDR	r12,[r10,r12,LSL #2]	@ r12 = v3 = v_table[v1]
+	ADD	r6, r6, r5, LSR #DITH1
+	ADD	r6, r6, r11
+	ADD	r6, r6, r12		@ r6 = y3 + u3 + v3 + dither1
+
+	ANDS	r12,r7, r5
+	TSTEQ	r6, r5
+	BNE	fix002
+return002:
+	AND	r7, r4, r7, LSR #3
+	ORR	r7, r7, r7, LSR #16
+	STRH	r7, [r0], #2
+	AND	r6, r4, r6, LSR #3
+	ORR	r6, r6, r6, LSR #16
+	STRH	r6, [r0], #2
+	ADDS	r8, r8, #2<<16
+	BLT	xloop01
+	MOVS	r8, r8, LSL #16		@ Clear the top 16 bits of r8
+	MOV	r8, r8, LSR #16		@ If the C bit is clear we still have
+	BCC	trail_pix01		@ 1 more pixel to do
+trail_pix01ret:
+	LDR	r11,[r13,#9*4]		@ r11= width
+	LDR	r7, [r13,#11*4]		@ r7 = y_span
+	LDR	r12,[r13,#12*4]		@ r12= uv_stride
+	LDR	r6, [r13,#13*4]		@ r6 = dst_span
+	SUB	r0, r0, r11,LSL #1
+	ADD	r1, r1, r7
+	ADD	r0, r0, r6
+	SUB	r1, r1, r11
+	SUB	r2, r2, r11
+	SUB	r3, r3, r11
+	ADD	r2, r2, r12
+	ADD	r3, r3, r12
+
+	SUBS	r8, r8, #1
+	BNE	yloop0
+end0:
+	LDMFD	r13!,{r4-r11,pc}
+trail_pix00:
+	@ We have a single extra pixel to do
+	LDRB	r6, [r1], #1		@ r6  = y0 = *y_ptr++
+	LDRB	r11,[r2], #1		@ r11 = u0 = *u_ptr++
+	LDRB	r12,[r3], #1		@ r12 = v0 = *v_ptr++
+	LDR	r6, [r14,r6, LSL #2]	@ r6  = y0 = y_table[y0]
+	LDR	r11,[r9, r11,LSL #2]	@ r11 = u0 = u_table[u]
+	LDR	r12,[r10,r12,LSL #2]	@ r12 = v0 = v_table[v]
+	@ Stall on Xscale
+	ADD	r6, r6, r11
+	ADD	r6, r6, r12		@ r6  = y0 + uv
+	ANDS	r12,r6, r5
+	BNE	fix003
+return003:
+	AND	r6, r4, r6, LSR #3
+	ORR	r6, r6, r6, LSR #16
+	STRH	r6, [r0], #2
+	B	trail_pix00ret
+trail_pix01:
+	@ We have a single extra pixel to do
+	LDRB	r6, [r1], #1		@ r6  = y0 = *y_ptr++
+	LDRB	r11,[r2], #1		@ r11 = u0 = *u_ptr++
+	LDRB	r12,[r3], #1		@ r12 = v0 = *v_ptr++
+	LDR	r6, [r14,r6, LSL #2]	@ r6  = y0 = y_table[y0]
+	LDR	r11,[r9, r11,LSL #2]	@ r11 = u0 = u_table[u]
+	LDR	r12,[r10,r12,LSL #2]	@ r12 = v0 = v_table[v]
+	ADD	r6, r6, r5, LSR #DITH1
+	ADD	r6, r6, r5, LSR #DITH2
+	ADD	r6, r6, r11
+	ADD	r6, r6, r12		@ r6  = y0 + uv + dither3
+
+	ANDS	r12,r6, r5
+	BNE	fix004
+return004:
+	AND	r6, r4, r6, LSR #3
+	ORR	r6, r6, r6, LSR #16
+	STRH	r6, [r0], #2
+	B	trail_pix01ret
+
+	LDMFD	r13!,{r4-r11,pc}
+
+fix001:
+	@ r7 and r6 are the values, at least one of which has overflowed
+	@ r12 = r7 & mask = .s......s......s......
+	SUB	r12,r12,r12,LSR #8	@ r12 = ..SSSSSS.SSSSSS.SSSSSS
+	ORR	r7, r7, r12		@ r7 |= ..SSSSSS.SSSSSS.SSSSSS
+	BIC	r12,r5, r7, LSR #1	@ r12 = .o......o......o......
+	ADD	r7, r7, r12,LSR #8	@ r7  = fixed value
+
+	AND	r12, r6, r5		@ r12 = .S......S......S......
+	SUB	r12,r12,r12,LSR #8	@ r12 = ..SSSSSS.SSSSSS.SSSSSS
+	ORR	r6, r6, r12		@ r6 |= ..SSSSSS.SSSSSS.SSSSSS
+	BIC	r12,r5, r6, LSR #1	@ r12 = .o......o......o......
+	ADD	r6, r6, r12,LSR #8	@ r6  = fixed value
+	B	return001
+fix002:
+	@ r7 and r6 are the values, at least one of which has overflowed
+	@ r12 = r7 & mask = .s......s......s......
+	SUB	r12,r12,r12,LSR #8	@ r12 = ..SSSSSS.SSSSSS.SSSSSS
+	ORR	r7, r7, r12		@ r7 |= ..SSSSSS.SSSSSS.SSSSSS
+	BIC	r12,r5, r7, LSR #1	@ r12 = .o......o......o......
+	ADD	r7, r7, r12,LSR #8	@ r7  = fixed value
+
+	AND	r12, r6, r5		@ r12 = .S......S......S......
+	SUB	r12,r12,r12,LSR #8	@ r12 = ..SSSSSS..SSSSS.SSSSSS
+	ORR	r6, r6, r12		@ r6 |= ..SSSSSS..SSSSS.SSSSSS
+	BIC	r12,r5, r6, LSR #1	@ r12 = .o......o......o......
+	ADD	r6, r6, r12,LSR #8	@ r6  = fixed value
+	B	return002
+fix003:
+	@ r6 is the value, which has has overflowed
+	@ r12 = r7 & mask = .s......s......s......
+	SUB	r12,r12,r12,LSR #8	@ r12 = ..SSSSSS.SSSSSS.SSSSSS
+	ORR	r6, r6, r12		@ r6 |= ..SSSSSS.SSSSSS.SSSSSS
+	BIC	r12,r5, r6, LSR #1	@ r12 = .o......o......o......
+	ADD	r6, r6, r12,LSR #8	@ r6  = fixed value
+	B	return003
+fix004:
+	@ r6 is the value, which has has overflowed
+	@ r12 = r7 & mask = .s......s......s......
+	SUB	r12,r12,r12,LSR #8	@ r12 = ..SSSSSS.SSSSSS.SSSSSS
+	ORR	r6, r6, r12		@ r6 |= ..SSSSSS.SSSSSS.SSSSSS
+	BIC	r12,r5, r6, LSR #1	@ r12 = .o......o......o......
+	ADD	r6, r6, r12,LSR #8	@ r6  = fixed value
+	B	return004
+@------------------------------------------------------------------------
+asm2:
+	@  Dither: 2 0
+	@          1 3
+yloop2:
+	SUB	r8, r8, r11,LSL #16	@ r8 = height-(width<<16)
+	ADDS	r8, r8, #1<<16		@ if (width == 1)
+	BGE	trail_pix20		@    just do 1 column
+xloop20:
+	LDRB	r6, [r1], #1		@ r6  = y0 = *y_ptr++
+	LDRB	r11,[r2], #1		@ r11 = u0 = *u_ptr++
+	LDRB	r12,[r3], #1		@ r12 = v0 = *v_ptr++
+	LDR	r6, [r14,r6, LSL #2]	@ r6  = y0 = y_table[y0]
+	LDR	r11,[r9, r11,LSL #2]	@ r11 = u  = u_table[u0]
+	LDR	r12,[r10,r12,LSL #2]	@ r12 = v  = v_table[v0]
+	LDRB	r7, [r1], #1		@ r7  = y1 = *y_ptr++
+	ADD	r6, r6, r11
+	ADD	r6, r6, r12
+
+	LDRB	r11,[r2], #1		@ r11 = u1 = *u_ptr++
+	LDRB	r12,[r3], #1		@ r12 = v1 = *v_ptr++
+	LDR	r7, [r14,r7, LSL #2]	@ r7  = y1 = y_table[y1]
+	LDR	r11,[r9, r11,LSL #2]	@ r11 = u1 = u_table[u1]
+	LDR	r12,[r10,r12,LSL #2]	@ r12 = v1 = v_table[v1]
+	ADD	r6, r6, r5, LSR #DITH2	@ r6 = y0 + u0 + v0 + dither2
+	ADD	r7, r7, r11
+	ADD	r7, r7, r12
+
+	ANDS	r12,r7, r5
+	TSTEQ	r6, r5
+	BNE	fix201
+return201:
+	AND	r6, r4, r6, LSR #3
+	ORR	r6, r6, r6, LSR #16
+	STRH	r6, [r0], #2
+	AND	r7, r4, r7, LSR #3
+	ORR	r7, r7, r7, LSR #16
+	STRH	r7, [r0], #2
+	ADDS	r8, r8, #2<<16
+	BLT	xloop20
+	MOVS	r8, r8, LSL #16		@ Clear the top 16 bits of r8
+	MOV	r8, r8, LSR #16		@ If the C bit is clear we still have
+	BCC	trail_pix20		@ 1 more pixel to do
+trail_pix20ret:
+	LDR	r11,[r13,#9*4]		@ r11= width
+	LDR	r7, [r13,#11*4]		@ r7 = y_span
+	LDR	r12,[r13,#12*4]		@ r12= uv_stride
+	LDR	r6, [r13,#13*4]		@ r6 = dst_span
+	SUB	r0, r0, r11,LSL #1
+	ADD	r1, r1, r7
+	ADD	r0, r0, r6
+	SUB	r1, r1, r11
+	SUB	r2, r2, r11
+	SUB	r3, r3, r11
+	ADD	r2, r2, r12
+	ADD	r3, r3, r12
+
+	SUBS	r8, r8, #1
+	BEQ	end2
+
+	@ Now we do the second row
+	SUB	r8, r8, r11,LSL #16	@ r8 = height-(width<<16)
+	ADDS	r8, r8, #1<<16		@ if (width == 1)
+	BGE	trail_pix21		@    just do 1 column
+xloop21:
+	LDRB	r7, [r1], #1		@ r6  = y2 = *y_ptr++
+	LDRB	r11,[r2], #1		@ r11 = u2 = *u_ptr++
+	LDRB	r12,[r3], #1		@ r12 = v2 = *v_ptr++
+	LDR	r7, [r14,r7, LSL #2]	@ r6  = y2 = y_table[y2]
+	LDR	r11,[r9, r11,LSL #2]	@ r11 = u2 = u_table[u2]
+	LDR	r12,[r10,r12,LSL #2]	@ r12 = v2 = v_table[v2]
+	ADD	r7, r7, r5, LSR #DITH1
+	ADD	r7, r7, r11
+	ADD	r7, r7, r12		@ r7 = y2 + u2 + v2 + dither1
+
+	LDRB	r6, [r1], #1		@ r6  = y3 = *y_ptr++
+	LDRB	r11,[r2], #1		@ r11 = u3 = *u_ptr++
+	LDRB	r12,[r3], #1		@ r12 = v3 = *v_ptr++
+	LDR	r6, [r14,r6, LSL #2]	@ r6  = y3 = y_table[y1]
+	LDR	r11,[r9, r11,LSL #2]	@ r11 = u3 = u_table[u1]
+	LDR	r12,[r10,r12,LSL #2]	@ r12 = v3 = v_table[v1]
+	ADD	r6, r6, r5, LSR #DITH1
+	ADD	r6, r6, r5, LSR #DITH2
+	ADD	r6, r6, r11
+	ADD	r6, r6, r12		@ r6 = y3 + u3 + v3 + dither3
+
+	ANDS	r12,r7, r5
+	TSTEQ	r6, r5
+	BNE	fix202
+return202:
+	AND	r7, r4, r7, LSR #3
+	ORR	r7, r7, r7, LSR #16
+	STRH	r7, [r0], #2
+	AND	r6, r4, r6, LSR #3
+	ORR	r6, r6, r6, LSR #16
+	STRH	r6, [r0], #2
+	ADDS	r8, r8, #2<<16
+	BLT	xloop21
+	MOVS	r8, r8, LSL #16		@ Clear the top 16 bits of r8
+	MOV	r8, r8, LSR #16		@ If the C bit is clear we still have
+	BCC	trail_pix21		@ 1 more pixel to do
+trail_pix21ret:
+	LDR	r11,[r13,#9*4]		@ r11= width
+	LDR	r7, [r13,#11*4]		@ r7 = y_span
+	LDR	r12,[r13,#12*4]		@ r12= uv_stride
+	LDR	r6, [r13,#13*4]		@ r6 = dst_span
+	SUB	r0, r0, r11,LSL #1
+	ADD	r1, r1, r7
+	ADD	r0, r0, r6
+	SUB	r1, r1, r11
+	SUB	r2, r2, r11
+	SUB	r3, r3, r11
+	ADD	r2, r2, r12
+	ADD	r3, r3, r12
+
+	SUBS	r8, r8, #1
+	BNE	yloop2
+end2:
+	LDMFD	r13!,{r4-r11,pc}
+trail_pix20:
+	@ We have a single extra pixel to do
+	LDRB	r6, [r1], #1		@ r6  = y0 = *y_ptr++
+	LDRB	r11,[r2], #1		@ r11 = u0 = *u_ptr++
+	LDRB	r12,[r3], #1		@ r12 = v0 = *v_ptr++
+	LDR	r6, [r14,r6, LSL #2]	@ r6  = y0 = y_table[y0]
+	LDR	r11,[r9, r11,LSL #2]	@ r11 = u0 = u_table[u]
+	LDR	r12,[r10,r12,LSL #2]	@ r12 = v0 = v_table[v]
+	ADD	r6, r6, r5, LSR #DITH2
+	ADD	r6, r6, r11
+	ADD	r6, r6, r12		@ r6  = y0 + uv + dither2
+	ANDS	r12,r6, r5
+	BNE	fix203
+return203:
+	AND	r6, r4, r6, LSR #3
+	ORR	r6, r6, r6, LSR #16
+	STRH	r6, [r0], #2
+	B	trail_pix20ret
+trail_pix21:
+	@ We have a single extra pixel to do
+	LDRB	r6, [r1], #1		@ r6  = y0 = *y_ptr++
+	LDRB	r11,[r2], #1		@ r11 = u0 = *u_ptr++
+	LDRB	r12,[r3], #1		@ r12 = v0 = *v_ptr++
+	LDR	r6, [r14,r6, LSL #2]	@ r6  = y0 = y_table[y0]
+	LDR	r11,[r9, r11,LSL #2]	@ r11 = u0 = u_table[u]
+	LDR	r12,[r10,r12,LSL #2]	@ r12 = v0 = v_table[v]
+	ADD	r6, r6, r5, LSR #DITH1
+	ADD	r6, r6, r11
+	ADD	r6, r6, r12		@ r6  = y0 + uv + dither1
+
+	ANDS	r12,r6, r5
+	BNE	fix204
+return204:
+	AND	r6, r4, r6, LSR #3
+	ORR	r6, r6, r6, LSR #16
+	STRH	r6, [r0], #2
+	B	trail_pix21ret
+
+	LDMFD	r13!,{r4-r11,pc}
+
+fix201:
+	@ r7 and r6 are the values, at least one of which has overflowed
+	@ r12 = r7 & mask = .s......s......s......
+	SUB	r12,r12,r12,LSR #8	@ r12 = ..SSSSSS.SSSSSS.SSSSSS
+	ORR	r7, r7, r12		@ r7 |= ..SSSSSS.SSSSSS.SSSSSS
+	BIC	r12,r5, r7, LSR #1	@ r12 = .o......o......o......
+	ADD	r7, r7, r12,LSR #8	@ r7  = fixed value
+
+	AND	r12, r6, r5		@ r12 = .S......S......S......
+	SUB	r12,r12,r12,LSR #8	@ r12 = ..SSSSSS.SSSSSS.SSSSSS
+	ORR	r6, r6, r12		@ r6 |= ..SSSSSS.SSSSSS.SSSSSS
+	BIC	r12,r5, r6, LSR #1	@ r12 = .o......o......o......
+	ADD	r6, r6, r12,LSR #8	@ r6  = fixed value
+	B	return201
+fix202:
+	@ r7 and r6 are the values, at least one of which has overflowed
+	@ r12 = r7 & mask = .s......s......s......
+	SUB	r12,r12,r12,LSR #8	@ r12 = ..SSSSSS.SSSSSS.SSSSSS
+	ORR	r7, r7, r12		@ r7 |= ..SSSSSS.SSSSSS.SSSSSS
+	BIC	r12,r5, r7, LSR #1	@ r12 = .o......o......o......
+	ADD	r7, r7, r12,LSR #8	@ r7  = fixed value
+
+	AND	r12, r6, r5		@ r12 = .S......S......S......
+	SUB	r12,r12,r12,LSR #8	@ r12 = ..SSSSSS..SSSSS.SSSSSS
+	ORR	r6, r6, r12		@ r6 |= ..SSSSSS..SSSSS.SSSSSS
+	BIC	r12,r5, r6, LSR #1	@ r12 = .o......o......o......
+	ADD	r6, r6, r12,LSR #8	@ r6  = fixed value
+	B	return202
+fix203:
+	@ r6 is the value, which has has overflowed
+	@ r12 = r7 & mask = .s......s......s......
+	SUB	r12,r12,r12,LSR #8	@ r12 = ..SSSSSS.SSSSSS.SSSSSS
+	ORR	r6, r6, r12		@ r6 |= ..SSSSSS.SSSSSS.SSSSSS
+	BIC	r12,r5, r6, LSR #1	@ r12 = .o......o......o......
+	ADD	r6, r6, r12,LSR #8	@ r6  = fixed value
+	B	return203
+fix204:
+	@ r6 is the value, which has has overflowed
+	@ r12 = r7 & mask = .s......s......s......
+	SUB	r12,r12,r12,LSR #8	@ r12 = ..SSSSSS.SSSSSS.SSSSSS
+	ORR	r6, r6, r12		@ r6 |= ..SSSSSS.SSSSSS.SSSSSS
+	BIC	r12,r5, r6, LSR #1	@ r12 = .o......o......o......
+	ADD	r6, r6, r12,LSR #8	@ r6  = fixed value
+	B	return204
+@------------------------------------------------------------------------
+asm3:
+	@  Dither: 3 1
+	@          0 2
+yloop3:
+	SUB	r8, r8, r11,LSL #16	@ r8 = height-(width<<16)
+	ADDS	r8, r8, #1<<16		@ if (width == 1)
+	BGE	trail_pix30		@    just do 1 column
+xloop30:
+	LDRB	r6, [r1], #1		@ r6  = y0 = *y_ptr++
+	LDRB	r11,[r2], #1		@ r11 = u0 = *u_ptr++
+	LDRB	r12,[r3], #1		@ r12 = v0 = *v_ptr++
+	LDR	r6, [r14,r6, LSL #2]	@ r6  = y0 = y_table[y0]
+	LDR	r11,[r9, r11,LSL #2]	@ r11 = u  = u_table[u0]
+	LDR	r12,[r10,r12,LSL #2]	@ r12 = v  = v_table[v0]
+	ADD	r6, r6, r5, LSR #DITH2
+	ADD	r6, r6, r11
+	ADD	r6, r6, r12
+	ADD	r6, r6, r5, LSR #DITH1	@ r6 = y0 + u0 + v0 + dither3
+
+	LDRB	r7, [r1], #1		@ r7  = y1 = *y_ptr++
+	LDRB	r11,[r2], #1		@ r11 = u1 = *u_ptr++
+	LDRB	r12,[r3], #1		@ r12 = v1 = *v_ptr++
+	LDR	r7, [r14,r7, LSL #2]	@ r7  = y1 = y_table[y1]
+	LDR	r11,[r9, r11,LSL #2]	@ r11 = u1 = u_table[u1]
+	LDR	r12,[r10,r12,LSL #2]	@ r12 = v1 = v_table[v1]
+	ADD	r7, r7, r5, LSR #DITH1	@ r7 = y1 + u1 + v1 + dither1
+	ADD	r7, r7, r11
+	ADD	r7, r7, r12
+
+	ANDS	r12,r7, r5
+	TSTEQ	r6, r5
+	BNE	fix301
+return301:
+	AND	r6, r4, r6, LSR #3
+	ORR	r6, r6, r6, LSR #16
+	STRH	r6, [r0], #2
+	AND	r7, r4, r7, LSR #3
+	ORR	r7, r7, r7, LSR #16
+	STRH	r7, [r0], #2
+	ADDS	r8, r8, #2<<16
+	BLT	xloop30
+	MOVS	r8, r8, LSL #16		@ Clear the top 16 bits of r8
+	MOV	r8, r8, LSR #16		@ If the C bit is clear we still have
+	BCC	trail_pix30		@ 1 more pixel to do
+trail_pix30ret:
+	LDR	r11,[r13,#9*4]		@ r11= width
+	LDR	r7, [r13,#11*4]		@ r7 = y_span
+	LDR	r12,[r13,#12*4]		@ r12= uv_stride
+	LDR	r6, [r13,#13*4]		@ r6 = dst_span
+	SUB	r0, r0, r11,LSL #1
+	ADD	r1, r1, r7
+	ADD	r0, r0, r6
+	SUB	r1, r1, r11
+	SUB	r2, r2, r11
+	SUB	r3, r3, r11
+	ADD	r2, r2, r12
+	ADD	r3, r3, r12
+
+	SUBS	r8, r8, #1
+	BEQ	end3
+
+	@ Now we do the second row
+	SUB	r8, r8, r11,LSL #16	@ r8 = height-(width<<16)
+	ADDS	r8, r8, #1<<16		@ if (width == 1)
+	BGE	trail_pix31		@    just do 1 column
+xloop31:
+	LDRB	r7, [r1], #1		@ r6  = y2 = *y_ptr++
+	LDRB	r11,[r2], #1		@ r11 = u2 = *u_ptr++
+	LDRB	r12,[r3], #1		@ r12 = v2 = *v_ptr++
+	LDR	r7, [r14,r7, LSL #2]	@ r6  = y2 = y_table[y2]
+	LDR	r11,[r9, r11,LSL #2]	@ r11 = u2 = u_table[u2]
+	LDR	r12,[r10,r12,LSL #2]	@ r12 = v2 = v_table[v2]
+	LDRB	r6, [r1], #1		@ r6  = y3 = *y_ptr++
+	ADD	r7, r7, r11
+	ADD	r7, r7, r12		@ r7 = y2 + u2 + v2
+
+	LDRB	r11,[r2], #1		@ r11 = u3 = *u_ptr++
+	LDRB	r12,[r3], #1		@ r12 = v3 = *v_ptr++
+	LDR	r6, [r14,r6, LSL #2]	@ r6  = y3 = y_table[y1]
+	LDR	r11,[r9, r11,LSL #2]	@ r11 = u3 = u_table[u1]
+	LDR	r12,[r10,r12,LSL #2]	@ r12 = v3 = v_table[v1]
+	ADD	r6, r6, r5, LSR #DITH2
+	ADD	r6, r6, r11
+	ADD	r6, r6, r12		@ r6 = y3 + u3 + v3 + dither2
+
+	ANDS	r12,r7, r5
+	TSTEQ	r6, r5
+	BNE	fix302
+return302:
+	AND	r7, r4, r7, LSR #3
+	ORR	r7, r7, r7, LSR #16
+	STRH	r7, [r0], #2
+	AND	r6, r4, r6, LSR #3
+	ORR	r6, r6, r6, LSR #16
+	STRH	r6, [r0], #2
+	ADDS	r8, r8, #2<<16
+	BLT	xloop31
+	MOVS	r8, r8, LSL #16		@ Clear the top 16 bits of r8
+	MOV	r8, r8, LSR #16		@ If the C bit is clear we still have
+	BCC	trail_pix31		@ 1 more pixel to do
+trail_pix31ret:
+	LDR	r11,[r13,#9*4]		@ r11= width
+	LDR	r7, [r13,#11*4]		@ r7 = y_span
+	LDR	r12,[r13,#12*4]		@ r12= uv_stride
+	LDR	r6, [r13,#13*4]		@ r6 = dst_span
+	SUB	r0, r0, r11,LSL #1
+	ADD	r1, r1, r7
+	ADD	r0, r0, r6
+	SUB	r1, r1, r11
+	SUB	r2, r2, r11
+	SUB	r3, r3, r11
+	ADD	r2, r2, r12
+	ADD	r3, r3, r12
+
+	SUBS	r8, r8, #1
+	BNE	yloop3
+end3:
+	LDMFD	r13!,{r4-r11,pc}
+trail_pix30:
+	@ We have a single extra pixel to do
+	LDRB	r6, [r1], #1		@ r6  = y0 = *y_ptr++
+	LDRB	r11,[r2], #1		@ r11 = u0 = *u_ptr++
+	LDRB	r12,[r3], #1		@ r12 = v0 = *v_ptr++
+	LDR	r6, [r14,r6, LSL #2]	@ r6  = y0 = y_table[y0]
+	LDR	r11,[r9, r11,LSL #2]	@ r11 = u0 = u_table[u]
+	LDR	r12,[r10,r12,LSL #2]	@ r12 = v0 = v_table[v]
+	ADD	r6, r6, r5, LSR #DITH1
+	ADD	r6, r6, r5, LSR #DITH2
+	ADD	r6, r6, r11
+	ADD	r6, r6, r12		@ r6  = y0 + uv + dither3
+	ANDS	r12,r6, r5
+	BNE	fix303
+return303:
+	AND	r6, r4, r6, LSR #3
+	ORR	r6, r6, r6, LSR #16
+	STRH	r6, [r0], #2
+	B	trail_pix30ret
+trail_pix31:
+	@ We have a single extra pixel to do
+	LDRB	r6, [r1], #1		@ r6  = y0 = *y_ptr++
+	LDRB	r11,[r2], #1		@ r11 = u0 = *u_ptr++
+	LDRB	r12,[r3], #1		@ r12 = v0 = *v_ptr++
+	LDR	r6, [r14,r6, LSL #2]	@ r6  = y0 = y_table[y0]
+	LDR	r11,[r9, r11,LSL #2]	@ r11 = u0 = u_table[u]
+	LDR	r12,[r10,r12,LSL #2]	@ r12 = v0 = v_table[v]
+	@ Stall on Xscale
+	ADD	r6, r6, r11
+	ADD	r6, r6, r12		@ r6  = y0 + uv
+
+	ANDS	r12,r6, r5
+	BNE	fix304
+return304:
+	AND	r6, r4, r6, LSR #3
+	ORR	r6, r6, r6, LSR #16
+	STRH	r6, [r0], #2
+	B	trail_pix31ret
+
+	LDMFD	r13!,{r4-r11,pc}
+
+fix301:
+	@ r7 and r6 are the values, at least one of which has overflowed
+	@ r12 = r7 & mask = .s......s......s......
+	SUB	r12,r12,r12,LSR #8	@ r12 = ..SSSSSS.SSSSSS.SSSSSS
+	ORR	r7, r7, r12		@ r7 |= ..SSSSSS.SSSSSS.SSSSSS
+	BIC	r12,r5, r7, LSR #1	@ r12 = .o......o......o......
+	ADD	r7, r7, r12,LSR #8	@ r7  = fixed value
+
+	AND	r12, r6, r5		@ r12 = .S......S......S......
+	SUB	r12,r12,r12,LSR #8	@ r12 = ..SSSSSS.SSSSSS.SSSSSS
+	ORR	r6, r6, r12		@ r6 |= ..SSSSSS.SSSSSS.SSSSSS
+	BIC	r12,r5, r6, LSR #1	@ r12 = .o......o......o......
+	ADD	r6, r6, r12,LSR #8	@ r6  = fixed value
+	B	return301
+fix302:
+	@ r7 and r6 are the values, at least one of which has overflowed
+	@ r12 = r7 & mask = .s......s......s......
+	SUB	r12,r12,r12,LSR #8	@ r12 = ..SSSSSS.SSSSSS.SSSSSS
+	ORR	r7, r7, r12		@ r7 |= ..SSSSSS.SSSSSS.SSSSSS
+	BIC	r12,r5, r7, LSR #1	@ r12 = .o......o......o......
+	ADD	r7, r7, r12,LSR #8	@ r7  = fixed value
+
+	AND	r12, r6, r5		@ r12 = .S......S......S......
+	SUB	r12,r12,r12,LSR #8	@ r12 = ..SSSSSS..SSSSS.SSSSSS
+	ORR	r6, r6, r12		@ r6 |= ..SSSSSS..SSSSS.SSSSSS
+	BIC	r12,r5, r6, LSR #1	@ r12 = .o......o......o......
+	ADD	r6, r6, r12,LSR #8	@ r6  = fixed value
+	B	return302
+fix303:
+	@ r6 is the value, which has has overflowed
+	@ r12 = r7 & mask = .s......s......s......
+	SUB	r12,r12,r12,LSR #8	@ r12 = ..SSSSSS.SSSSSS.SSSSSS
+	ORR	r6, r6, r12		@ r6 |= ..SSSSSS.SSSSSS.SSSSSS
+	BIC	r12,r5, r6, LSR #1	@ r12 = .o......o......o......
+	ADD	r6, r6, r12,LSR #8	@ r6  = fixed value
+	B	return303
+fix304:
+	@ r6 is the value, which has has overflowed
+	@ r12 = r7 & mask = .s......s......s......
+	SUB	r12,r12,r12,LSR #8	@ r12 = ..SSSSSS.SSSSSS.SSSSSS
+	ORR	r6, r6, r12		@ r6 |= ..SSSSSS.SSSSSS.SSSSSS
+	BIC	r12,r5, r6, LSR #1	@ r12 = .o......o......o......
+	ADD	r6, r6, r12,LSR #8	@ r6  = fixed value
+	B	return304
+
+	@ END
diff -Nurp vlc-a/modules/audio_filter/Android.mk vlc-b/modules/audio_filter/Android.mk
--- vlc-a/modules/audio_filter/Android.mk	1970-01-01 08:00:00.000000000 +0800
+++ vlc-b/modules/audio_filter/Android.mk	2011-07-10 01:53:48.998262162 +0800
@@ -0,0 +1,3 @@
+LOCAL_PATH := $(call my-dir)
+include $(CLEAR_VARS)
+include $(call all-makefiles-under,$(LOCAL_PATH))
diff -Nurp vlc-a/modules/audio_filter/channel_mixer/Android.mk vlc-b/modules/audio_filter/channel_mixer/Android.mk
--- vlc-a/modules/audio_filter/channel_mixer/Android.mk	1970-01-01 08:00:00.000000000 +0800
+++ vlc-b/modules/audio_filter/channel_mixer/Android.mk	2011-07-10 01:53:48.998262162 +0800
@@ -0,0 +1,28 @@
+
+LOCAL_PATH := $(call my-dir)
+
+include $(CLEAR_VARS)
+
+LOCAL_ARM_MODE := arm
+ifeq ($(BUILD_WITH_NEON),1)
+LOCAL_ARM_NEON := true
+endif
+
+LOCAL_MODULE := simple_channel_mixer_plugin
+
+LOCAL_CFLAGS += \
+    -std=c99 \
+    -DHAVE_CONFIG_H \
+    -DMODULE_STRING=\"simple_channel_mixer\" \
+    -DMODULE_NAME=simple_channel_mixer
+
+LOCAL_C_INCLUDES += \
+    $(VLCROOT) \
+    $(VLCROOT)/include \
+    $(VLCROOT)/src
+
+LOCAL_SRC_FILES := \
+    simple.c
+
+include $(BUILD_STATIC_LIBRARY)
+
diff -Nurp vlc-a/modules/audio_filter/converter/Android.mk vlc-b/modules/audio_filter/converter/Android.mk
--- vlc-a/modules/audio_filter/converter/Android.mk	1970-01-01 08:00:00.000000000 +0800
+++ vlc-b/modules/audio_filter/converter/Android.mk	2011-07-10 01:53:49.000262172 +0800
@@ -0,0 +1,28 @@
+
+LOCAL_PATH := $(call my-dir)
+
+include $(CLEAR_VARS)
+
+LOCAL_ARM_MODE := arm
+ifeq ($(BUILD_WITH_NEON),1)
+LOCAL_ARM_NEON := true
+endif
+
+LOCAL_MODULE := converter_fixed_plugin
+
+LOCAL_CFLAGS += \
+    -std=c99 \
+    -DHAVE_CONFIG_H \
+    -DMODULE_STRING=\"converter_fixed\" \
+    -DMODULE_NAME=converter_fixed
+
+LOCAL_C_INCLUDES += \
+    $(VLCROOT) \
+    $(VLCROOT)/include \
+    $(VLCROOT)/src
+
+LOCAL_SRC_FILES := \
+    fixed.c
+
+include $(BUILD_STATIC_LIBRARY)
+
diff -Nurp vlc-a/modules/audio_filter/resampler/Android.mk vlc-b/modules/audio_filter/resampler/Android.mk
--- vlc-a/modules/audio_filter/resampler/Android.mk	1970-01-01 08:00:00.000000000 +0800
+++ vlc-b/modules/audio_filter/resampler/Android.mk	2011-07-10 01:53:49.002262183 +0800
@@ -0,0 +1,53 @@
+
+LOCAL_PATH := $(call my-dir)
+
+include $(CLEAR_VARS)
+
+LOCAL_ARM_MODE := arm
+ifeq ($(BUILD_WITH_NEON),1)
+LOCAL_ARM_NEON := true
+endif
+
+LOCAL_MODULE := bandlimited_resampler_plugin
+
+LOCAL_CFLAGS += \
+    -std=c99 \
+    -DHAVE_CONFIG_H \
+    -DMODULE_STRING=\"bandlimited_resampler\" \
+    -DMODULE_NAME=bandlimited_resampler
+
+LOCAL_C_INCLUDES += \
+    $(VLCROOT) \
+    $(VLCROOT)/include \
+    $(VLCROOT)/src
+
+LOCAL_SRC_FILES := \
+    bandlimited.c
+
+include $(BUILD_STATIC_LIBRARY)
+
+include $(CLEAR_VARS)
+
+LOCAL_ARM_MODE := arm
+ifeq ($(BUILD_WITH_NEON),1)
+LOCAL_ARM_NEON := true
+endif
+
+LOCAL_MODULE := ugly_resampler_plugin
+
+LOCAL_CFLAGS += \
+    -std=c99 \
+    -DHAVE_CONFIG_H \
+    -DMODULE_STRING=\"ugly_resampler\" \
+    -DMODULE_NAME=ugly_resampler
+
+LOCAL_C_INCLUDES += \
+    $(VLCROOT) \
+    $(VLCROOT)/include \
+    $(VLCROOT)/src
+
+LOCAL_SRC_FILES := \
+    ugly.c
+
+include $(BUILD_STATIC_LIBRARY)
+
diff -Nurp vlc-a/modules/audio_mixer/Android.mk vlc-b/modules/audio_mixer/Android.mk
--- vlc-a/modules/audio_mixer/Android.mk	1970-01-01 08:00:00.000000000 +0800
+++ vlc-b/modules/audio_mixer/Android.mk	2011-07-10 01:53:49.004262195 +0800
@@ -0,0 +1,78 @@
+
+LOCAL_PATH := $(call my-dir)
+
+include $(CLEAR_VARS)
+
+LOCAL_ARM_MODE := arm
+ifeq ($(BUILD_WITH_NEON),1)
+LOCAL_ARM_NEON := true
+endif
+
+LOCAL_MODULE := fixed32_mixer_plugin
+
+LOCAL_CFLAGS += \
+    -std=c99 \
+    -DHAVE_CONFIG_H \
+    -DMODULE_STRING=\"fixed32_mixer\" \
+    -DMODULE_NAME=fixed32_mixer
+
+LOCAL_C_INCLUDES += \
+    $(VLCROOT) \
+    $(VLCROOT)/include \
+    $(VLCROOT)/src
+
+LOCAL_SRC_FILES := \
+    fixed32.c
+
+include $(BUILD_STATIC_LIBRARY)
+
+include $(CLEAR_VARS)
+
+LOCAL_ARM_MODE := arm
+ifeq ($(BUILD_WITH_NEON),1)
+LOCAL_ARM_NEON := true
+endif
+
+LOCAL_MODULE := float32_mixer_plugin
+
+LOCAL_CFLAGS += \
+    -std=c99 \
+    -DHAVE_CONFIG_H \
+    -DMODULE_STRING=\"float32_mixer\" \
+    -DMODULE_NAME=float32_mixer
+
+LOCAL_C_INCLUDES += \
+    $(VLCROOT) \
+    $(VLCROOT)/include \
+    $(VLCROOT)/src
+
+LOCAL_SRC_FILES := \
+    float32.c
+
+include $(BUILD_STATIC_LIBRARY)
+
+include $(CLEAR_VARS)
+
+LOCAL_ARM_MODE := arm
+ifeq ($(BUILD_WITH_NEON),1)
+LOCAL_ARM_NEON := true
+endif
+
+LOCAL_MODULE := trivial_mixer_plugin
+
+LOCAL_CFLAGS += \
+    -std=c99 \
+    -DHAVE_CONFIG_H \
+    -DMODULE_STRING=\"trivial_mixer\" \
+    -DMODULE_NAME=trivial_mixer
+
+LOCAL_C_INCLUDES += \
+    $(VLCROOT) \
+    $(VLCROOT)/include \
+    $(VLCROOT)/src
+
+LOCAL_SRC_FILES := \
+    trivial.c
+
+include $(BUILD_STATIC_LIBRARY)
+
diff -Nurp vlc-a/modules/audio_output/android_AudioTrack.c vlc-b/modules/audio_output/android_AudioTrack.c
--- vlc-a/modules/audio_output/android_AudioTrack.c	1970-01-01 08:00:00.000000000 +0800
+++ vlc-b/modules/audio_output/android_AudioTrack.c	2011-07-18 15:13:03.522867926 +0800
@@ -0,0 +1,235 @@
+
+#ifdef HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include <vlc_common.h>
+#include <vlc_plugin.h>
+#include <vlc_aout.h>
+
+#include <dlfcn.h>
+
+// _ZN7android11AudioSystem19getOutputFrameCountEPii
+typedef int (*AudioSystem_getOutputFrameCount)(int *, int);
+// _ZN7android11AudioSystem16getOutputLatencyEPji
+typedef int (*AudioSystem_getOutputLatency)(unsigned int *, int);
+// _ZN7android11AudioSystem21getOutputSamplingRateEPii
+typedef int (*AudioSystem_getOutputSamplingRate)(int *, int);
+
+// _ZN7android10AudioTrack16getMinFrameCountEPiij
+typedef int (*AudioTrack_getMinFrameCount)(int *, int, unsigned int);
+
+// _ZN7android10AudioTrackC1EijiiijPFviPvS1_ES1_ii
+typedef void (*AudioTrack_ctor)(void *, int, unsigned int, int, int, int, unsigned int, void (*)(int, void *, void *), void *, int, int);
+// _ZN7android10AudioTrackC1EijiiijPFviPvS1_ES1_i
+typedef void (*AudioTrack_ctor_legacy)(void *, int, unsigned int, int, int, int, unsigned int, void (*)(int, void *, void *), void *, int);
+// _ZN7android10AudioTrackD1Ev
+typedef void (*AudioTrack_dtor)(void *);
+// _ZNK7android10AudioTrack9initCheckEv
+typedef int (*AudioTrack_initCheck)(void *);
+// _ZN7android10AudioTrack5startEv
+typedef int (*AudioTrack_start)(void *);
+// _ZN7android10AudioTrack4stopEv
+typedef int (*AudioTrack_stop)(void *);
+// _ZN7android10AudioTrack5writeEPKvj
+typedef int (*AudioTrack_write)(void *, void  const*, unsigned int);
+// _ZN7android10AudioTrack5flushEv
+typedef int (*AudioTrack_flush)(void *);
+
+struct aout_sys_t {
+    int type;
+    uint32_t rate;
+    int channel;
+    int format;
+    int size;
+    void *libmedia;
+    void *AudioTrack;
+};
+
+static AudioSystem_getOutputFrameCount as_getOutputFrameCount = NULL;
+static AudioSystem_getOutputLatency as_getOutputLatency = NULL;
+static AudioSystem_getOutputSamplingRate as_getOutputSamplingRate = NULL;
+static AudioTrack_getMinFrameCount at_getMinFrameCount = NULL;
+static AudioTrack_ctor at_ctor = NULL;
+static AudioTrack_ctor_legacy at_ctor_legacy = NULL;
+static AudioTrack_dtor at_dtor = NULL;
+static AudioTrack_initCheck at_initCheck = NULL;
+static AudioTrack_start at_start = NULL;
+static AudioTrack_stop at_stop = NULL;
+static AudioTrack_write at_write = NULL;
+static AudioTrack_flush at_flush = NULL;
+
+static void *InitLibrary();
+
+static int  Open(vlc_object_t *);
+static void Close(vlc_object_t *);
+static void Play(aout_instance_t *);
+
+vlc_module_begin ()
+    set_shortname("AndroidAudioTrack")
+    set_description(N_("Android AudioTrack audio output"))
+    set_capability("audio output", 25)
+    set_category(CAT_AUDIO)
+    set_subcategory(SUBCAT_AUDIO_AOUT)
+    add_shortcut("android")
+    set_callbacks(Open, Close)
+vlc_module_end ()
+
+void *InitLibrary() {
+    void *p_library;
+
+    p_library = dlopen("libmedia.so", RTLD_NOW);
+    if (!p_library)
+        return NULL;
+    as_getOutputFrameCount = (AudioSystem_getOutputFrameCount)(dlsym(p_library, "_ZN7android11AudioSystem19getOutputFrameCountEPii"));
+    as_getOutputLatency = (AudioSystem_getOutputLatency)(dlsym(p_library, "_ZN7android11AudioSystem16getOutputLatencyEPji"));
+    as_getOutputSamplingRate = (AudioSystem_getOutputSamplingRate)(dlsym(p_library, "_ZN7android11AudioSystem21getOutputSamplingRateEPii"));
+    at_getMinFrameCount = (AudioTrack_getMinFrameCount)(dlsym(p_library, "_ZN7android10AudioTrack16getMinFrameCountEPiij"));
+    at_ctor = (AudioTrack_ctor)(dlsym(p_library, "_ZN7android10AudioTrackC1EijiiijPFviPvS1_ES1_ii"));
+    at_ctor_legacy = (AudioTrack_ctor_legacy)(dlsym(p_library, "_ZN7android10AudioTrackC1EijiiijPFviPvS1_ES1_i"));
+    at_dtor = (AudioTrack_dtor)(dlsym(p_library, "_ZN7android10AudioTrackD1Ev"));
+    at_initCheck = (AudioTrack_initCheck)(dlsym(p_library, "_ZNK7android10AudioTrack9initCheckEv"));
+    at_start = (AudioTrack_start)(dlsym(p_library, "_ZN7android10AudioTrack5startEv"));
+    at_stop = (AudioTrack_stop)(dlsym(p_library, "_ZN7android10AudioTrack4stopEv"));
+    at_write = (AudioTrack_write)(dlsym(p_library, "_ZN7android10AudioTrack5writeEPKvj"));
+    at_flush = (AudioTrack_flush)(dlsym(p_library, "_ZN7android10AudioTrack5flushEv"));
+    // need the first 3 or the last 1
+    if (!((as_getOutputFrameCount && as_getOutputLatency && as_getOutputSamplingRate) || at_getMinFrameCount)) {
+        dlclose(p_library);
+        return NULL;
+    }
+    // need all in the list
+    if (!((at_ctor || at_ctor_legacy) && at_dtor && at_initCheck && at_start && at_stop && at_write && at_flush)) {
+        dlclose(p_library);
+        return NULL;
+    }
+    return p_library;
+}
+
+static int Open(vlc_object_t *p_this) {
+    struct aout_sys_t *p_sys;
+    void *p_library;
+    aout_instance_t *p_aout = (aout_instance_t*)(p_this);
+    int status;
+    int afSampleRate, afFrameCount, afLatency, minBufCount, minFrameCount;
+    int type, channel, rate, format, size;
+
+    p_library = InitLibrary();
+    if (!p_library) {
+        msg_Err(VLC_OBJECT(p_this), "Could not initialize libmedia.so!");
+        return VLC_EGENERIC;
+    }
+    p_sys = (struct aout_sys_t*)malloc(sizeof(aout_sys_t));
+    if (p_sys == NULL)
+        return VLC_ENOMEM;
+    p_sys->libmedia = p_library;
+    // AudioSystem::MUSIC = 3
+    type = 3;
+    p_sys->type = type;
+    // 4000 <= frequency <= 48000
+    if (p_aout->output.output.i_rate < 4000)
+        p_aout->output.output.i_rate = 4000;
+    if (p_aout->output.output.i_rate > 48000)
+        p_aout->output.output.i_rate = 48000;
+    rate = p_aout->output.output.i_rate;
+    p_sys->rate = rate;
+    // U8/S16 only
+    if (p_aout->output.output.i_format != VLC_CODEC_U8 && p_aout->output.output.i_format != VLC_CODEC_S16L)
+        p_aout->output.output.i_format = VLC_CODEC_S16L;
+    // AudioSystem::PCM_16_BIT = 1
+    // AudioSystem::PCM_8_BIT = 2
+    format = (p_aout->output.output.i_format == VLC_CODEC_S16L) ? 1 : 2;
+    p_sys->format = format;
+    // TODO: android supports more channels
+    channel = aout_FormatNbChannels(&p_aout->output.output);
+    if (channel > 2) {
+        channel = 2;
+        p_aout->output.output.i_physical_channels = AOUT_CHAN_LEFT | AOUT_CHAN_RIGHT;
+    }
+    // AudioSystem::CHANNEL_OUT_STEREO = 12
+    // AudioSystem::CHANNEL_OUT_MONO = 4
+    channel = (channel == 2) ? 12 : 4;
+    p_sys->channel = channel;
+    // use the minium value
+    if (!at_getMinFrameCount) {
+        status = as_getOutputSamplingRate(&afSampleRate, type);
+        status ^= as_getOutputFrameCount(&afFrameCount, type);
+        status ^= as_getOutputLatency((uint32_t*)(&afLatency), type);
+        if (status != 0) {
+            free(p_sys);
+            return VLC_EGENERIC;
+        }
+        minBufCount = afLatency / ((1000 * afFrameCount) / afSampleRate);
+        if (minBufCount < 2)
+            minBufCount = 2;
+        minFrameCount = (afFrameCount * rate * minBufCount) / afSampleRate;
+        p_aout->output.i_nb_samples = minFrameCount;
+    }
+    else {
+        status = at_getMinFrameCount(&p_aout->output.i_nb_samples, type, rate);
+        if (status != 0) {
+            free(p_sys);
+            return VLC_EGENERIC;
+        }
+    }
+    p_aout->output.i_nb_samples <<= 1;
+    p_sys->size = p_aout->output.i_nb_samples;
+    // sizeof(AudioTrack) == 0x58 (not sure) on 2.2.1, this should be enough
+    p_sys->AudioTrack = malloc(256);
+    if (!p_sys->AudioTrack) {
+        free(p_sys);
+        return VLC_ENOMEM;
+    }
+    // higher than android 2.2
+    if (at_ctor)
+        at_ctor(p_sys->AudioTrack, p_sys->type, p_sys->rate, p_sys->format, p_sys->channel, p_sys->size, 0, NULL, NULL, 0, 0);
+    // higher than android 1.6
+    else if (at_ctor_legacy)
+        at_ctor_legacy(p_sys->AudioTrack, p_sys->type, p_sys->rate, p_sys->format, p_sys->channel, p_sys->size, 0, NULL, NULL, 0);
+    status = at_initCheck(p_sys->AudioTrack);
+    // android 1.6
+    if (status != 0) {
+        p_sys->channel = (p_sys->channel == 12) ? 2 : 1;
+        at_ctor_legacy(p_sys->AudioTrack, p_sys->type, p_sys->rate, p_sys->format, p_sys->channel, p_sys->size, 0, NULL, NULL, 0);
+        status = at_initCheck(p_sys->AudioTrack);
+    }
+    if (status != 0) {
+        msg_Err(p_aout, "Cannot create AudioTrack!");
+        free(p_sys->AudioTrack);
+        free(p_sys);
+        return VLC_EGENERIC;
+    }
+
+    p_aout->output.p_sys = p_sys;
+    p_aout->output.pf_play = Play;
+
+    at_start(p_sys->AudioTrack);
+
+    return VLC_SUCCESS;
+}
+
+static void Close(vlc_object_t *p_this) {
+    aout_instance_t *p_aout = (aout_instance_t*)p_this;
+    struct aout_sys_t *p_sys = p_aout->output.p_sys;
+
+    at_stop(p_sys->AudioTrack);
+    at_flush(p_sys->AudioTrack);
+    at_dtor(p_sys->AudioTrack);
+    free(p_sys->AudioTrack);
+    free(p_sys);
+}
+
+static void Play(aout_instance_t *p_aout) {
+    struct aout_sys_t *p_sys = p_aout->output.p_sys;
+    int length;
+    aout_buffer_t *p_buffer;
+
+    while ((p_buffer = aout_FifoPop(&p_aout->output.fifo)) != NULL) {
+        length = 0;
+        while (length < p_buffer->i_buffer) {
+            length += at_write(p_sys->AudioTrack, (char*)(p_buffer->p_buffer) + length, p_buffer->i_buffer - length);
+        }
+        aout_BufferFree(p_buffer);
+    }
+}
+
diff -Nurp vlc-a/modules/audio_output/Android.mk vlc-b/modules/audio_output/Android.mk
--- vlc-a/modules/audio_output/Android.mk	1970-01-01 08:00:00.000000000 +0800
+++ vlc-b/modules/audio_output/Android.mk	2011-07-10 01:53:49.005262201 +0800
@@ -0,0 +1,79 @@
+
+LOCAL_PATH := $(call my-dir)
+
+include $(CLEAR_VARS)
+
+LOCAL_ARM_MODE := arm
+ifeq ($(BUILD_WITH_NEON),1)
+LOCAL_ARM_NEON := true
+endif
+
+LOCAL_MODULE := amem_plugin
+
+LOCAL_CFLAGS += \
+    -std=c99 \
+    -DHAVE_CONFIG_H \
+    -DMODULE_STRING=\"amem\" \
+    -DMODULE_NAME=amem
+
+LOCAL_C_INCLUDES += \
+    $(VLCROOT) \
+    $(VLCROOT)/include \
+    $(VLCROOT)/src
+
+LOCAL_SRC_FILES := \
+    amem.c
+
+include $(BUILD_STATIC_LIBRARY)
+
+include $(CLEAR_VARS)
+
+LOCAL_ARM_MODE := arm
+ifeq ($(BUILD_WITH_NEON),1)
+LOCAL_ARM_NEON := true
+endif
+
+LOCAL_MODULE := audiotrack_android_plugin
+
+LOCAL_CFLAGS += \
+    -std=c99 \
+    -DHAVE_CONFIG_H \
+    -DMODULE_STRING=\"audiotrack_android\" \
+    -DMODULE_NAME=audiotrack_android
+
+LOCAL_C_INCLUDES += \
+    $(VLCROOT) \
+    $(VLCROOT)/include \
+    $(VLCROOT)/src
+
+LOCAL_SRC_FILES := \
+    android_AudioTrack.c
+
+include $(BUILD_STATIC_LIBRARY)
+
+include $(CLEAR_VARS)
+
+LOCAL_ARM_MODE := arm
+ifeq ($(BUILD_WITH_NEON),1)
+LOCAL_ARM_NEON := true
+endif
+
+# TODO: enable this when >= android-9
+#LOCAL_MODULE := opensles_android_plugin
+
+LOCAL_CFLAGS += \
+    -std=c99 \
+    -DHAVE_CONFIG_H \
+    -DMODULE_STRING=\"opensles_android\" \
+    -DMODULE_NAME=opensles_android
+
+LOCAL_C_INCLUDES += \
+    $(VLCROOT) \
+    $(VLCROOT)/include \
+    $(VLCROOT)/src
+
+LOCAL_SRC_FILES := \
+    opensles_android.c
+
+#include $(BUILD_STATIC_LIBRARY)
+
diff -Nurp vlc-a/modules/codec/Android.mk vlc-b/modules/codec/Android.mk
--- vlc-a/modules/codec/Android.mk	1970-01-01 08:00:00.000000000 +0800
+++ vlc-b/modules/codec/Android.mk	2011-07-18 15:13:03.522867926 +0800
@@ -0,0 +1,110 @@
+
+LOCAL_PATH := $(call my-dir)
+
+include $(CLEAR_VARS)
+
+LOCAL_ARM_MODE := arm
+ifeq ($(BUILD_WITH_NEON),1)
+LOCAL_ARM_NEON := true
+endif
+
+LOCAL_MODULE := liblibass_plugin
+
+LOCAL_CFLAGS += \
+    -std=c99 \
+    -DHAVE_CONFIG_H \
+    -DMODULE_STRING=\"libass\" \
+    -DMODULE_NAME=libass
+
+LOCAL_C_INCLUDES += \
+    $(VLCROOT) \
+    $(VLCROOT)/include \
+    $(VLCROOT)/src \
+    $(EXTROOT)/iconv/include \
+    $(EXTROOT)/freetype/include \
+    $(EXTROOT)/libass/include
+
+LOCAL_SRC_FILES := \
+    libass.c
+
+include $(BUILD_STATIC_LIBRARY)
+
+include $(CLEAR_VARS)
+
+LOCAL_ARM_MODE := arm
+ifeq ($(BUILD_WITH_NEON),1)
+LOCAL_ARM_NEON := true
+endif
+
+LOCAL_MODULE := mpeg_audio_plugin
+
+LOCAL_CFLAGS += \
+    -std=c99 \
+    -DHAVE_CONFIG_H \
+    -DMODULE_STRING=\"mpeg_audio\" \
+    -DMODULE_NAME=mpeg_audio
+
+LOCAL_C_INCLUDES += \
+    $(VLCROOT) \
+    $(VLCROOT)/include \
+    $(VLCROOT)/src
+
+LOCAL_SRC_FILES := \
+    mpeg_audio.c
+
+include $(BUILD_STATIC_LIBRARY)
+
+include $(CLEAR_VARS)
+
+LOCAL_ARM_MODE := arm
+ifeq ($(BUILD_WITH_NEON),1)
+LOCAL_ARM_NEON := true
+endif
+
+LOCAL_MODULE := subsdec_plugin
+
+LOCAL_CFLAGS += \
+    -std=c99 \
+    -DHAVE_CONFIG_H \
+    -DMODULE_STRING=\"subsdec\" \
+    -DMODULE_NAME=subsdec
+
+LOCAL_C_INCLUDES += \
+    $(VLCROOT) \
+    $(VLCROOT)/include \
+    $(VLCROOT)/src
+
+LOCAL_SRC_FILES := \
+    subsdec.c
+
+include $(BUILD_STATIC_LIBRARY)
+
+include $(CLEAR_VARS)
+
+LOCAL_ARM_MODE := arm
+ifeq ($(BUILD_WITH_NEON),1)
+LOCAL_ARM_NEON := true
+endif
+
+LOCAL_MODULE := subsusf_plugin
+
+LOCAL_CFLAGS += \
+    -std=c99 \
+    -DHAVE_CONFIG_H \
+    -DMODULE_STRING=\"subsusf\" \
+    -DMODULE_NAME=subsusf
+
+LOCAL_C_INCLUDES += \
+    $(VLCROOT) \
+    $(VLCROOT)/include \
+    $(VLCROOT)/src
+
+LOCAL_SRC_FILES := \
+    subsusf.c
+
+include $(BUILD_STATIC_LIBRARY)
+
+include $(CLEAR_VARS)
+
+include $(call all-makefiles-under,$(LOCAL_PATH))
+
diff -Nurp vlc-a/modules/codec/avcodec/Android.mk vlc-b/modules/codec/avcodec/Android.mk
--- vlc-a/modules/codec/avcodec/Android.mk	1970-01-01 08:00:00.000000000 +0800
+++ vlc-b/modules/codec/avcodec/Android.mk	2011-07-10 01:53:49.011262233 +0800
@@ -0,0 +1,36 @@
+
+LOCAL_PATH := $(call my-dir)
+
+include $(CLEAR_VARS)
+
+LOCAL_ARM_MODE := arm
+ifeq ($(BUILD_WITH_NEON),1)
+LOCAL_ARM_NEON := true
+endif
+
+LOCAL_MODULE := avcodec_plugin
+
+LOCAL_CFLAGS += \
+    -std=c99 \
+    -DHAVE_CONFIG_H \
+    -DMODULE_STRING=\"avcodec\" \
+    -DMODULE_NAME=avcodec
+
+LOCAL_C_INCLUDES += \
+    $(VLCROOT) \
+    $(VLCROOT)/include \
+    $(VLCROOT)/src \
+    $(EXTROOT)/ffmpeg
+
+LOCAL_SRC_FILES := \
+    audio.c \
+    avcodec.c \
+    chroma.c \
+    copy.c \
+    deinterlace.c \
+    fourcc.c \
+    subtitle.c \
+    video.c
+
+include $(BUILD_STATIC_LIBRARY)
+
diff -Nurp vlc-a/modules/codec/avcodec/avcodec.c vlc-b/modules/codec/avcodec/avcodec.c
--- vlc-a/modules/codec/avcodec/avcodec.c	2011-07-18 20:34:11.633213779 +0800
+++ vlc-b/modules/codec/avcodec/avcodec.c	2011-07-10 01:53:49.011262233 +0800
@@ -400,8 +400,12 @@ int ffmpeg_OpenCodec( decoder_t *p_dec )
     {
         if( p_sys->i_codec_id == CODEC_ID_VC1 ||
             p_sys->i_codec_id == CODEC_ID_VORBIS ||
+#ifdef ANDROID
+            p_sys->i_codec_id == CODEC_ID_THEORA )
+#else
             p_sys->i_codec_id == CODEC_ID_THEORA ||
             p_sys->i_codec_id == CODEC_ID_AAC )
+#endif
         {
             msg_Warn( p_dec, "waiting for extra data for codec %s",
                       p_sys->psz_namecodec );
diff -Nurp vlc-a/modules/codec/avcodec/video.c vlc-b/modules/codec/avcodec/video.c
--- vlc-a/modules/codec/avcodec/video.c	2011-07-18 20:34:11.641213815 +0800
+++ vlc-b/modules/codec/avcodec/video.c	2011-07-10 01:53:49.015262257 +0800
@@ -77,6 +77,15 @@ struct decoder_sys_t
     int     i_late_frames;
     mtime_t i_late_frames_start;
 
+#ifdef ANDROID
+    int i_decode_called_count;
+    mtime_t i_decode_total_time;
+    mtime_t i_decode_average_time;
+    mtime_t i_decode_last_time;
+    mtime_t i_display_date_head;
+    int i_decode_may_suck;
+#endif
+
     /* for direct rendering */
     bool b_direct_rendering;
     int  i_direct_rendering_used;
@@ -419,6 +428,15 @@ int InitVideoDec( decoder_t *p_dec, AVCo
         return VLC_EGENERIC;
     }
 
+#ifdef ANDROID
+    p_sys->i_decode_called_count = 0;
+    p_sys->i_decode_total_time = 0;
+    p_sys->i_decode_average_time = 0;
+    p_sys->i_decode_last_time = 0;
+    p_sys->i_display_date_head = 0;
+    p_sys->i_decode_may_suck = 0;
+#endif
+
     return VLC_SUCCESS;
 }
 
@@ -474,6 +492,7 @@ picture_t *DecodeVideo( decoder_t *p_dec
         p_sys->i_late_frames = 0;
     }
 
+#ifndef ANDROID
     if( !p_dec->b_pace_control && (p_sys->i_late_frames > 0) &&
         (mdate() - p_sys->i_late_frames_start > INT64_C(5000000)) )
     {
@@ -535,6 +554,23 @@ picture_t *DecodeVideo( decoder_t *p_dec
                                                   AVDISCARD_NONREF );
 #endif
     }
+#else
+    mtime_t i_time_now = mdate();
+    mtime_t i_time_adv = p_sys->i_display_date_head > 0 ? (p_sys->i_display_date_head - p_sys->i_decode_average_time - i_time_now) : 0;
+    p_sys->i_decode_may_suck = (i_time_adv < 0) ? (p_sys->i_decode_may_suck + 1) : 0;
+    bool b_skip_pred = (p_sys->i_decode_may_suck > 0);
+    bool b_skip_late = (p_sys->i_late_frames > 4);
+    bool b_no_skip_pred = (p_sys->i_decode_last_time < p_sys->i_decode_average_time);
+    bool b_no_skip_late = (i_time_now + p_sys->i_decode_average_time - p_sys->i_late_frames_start < 200000);
+    bool b_skip = ( (!p_dec->b_pace_control) &&  ((b_skip_pred && !b_no_skip_pred) || (b_skip_late && !b_no_skip_late)) );
+    p_context->skip_frame = b_skip ? AVDISCARD_NONREF : AVDISCARD_DEFAULT;
+    if( !(p_block->i_flags & BLOCK_FLAG_PREROLL) )
+        b_drawpicture = 1;
+    else
+        b_drawpicture = 0;
+    if( p_context->width <= 0 || p_context->height <= 0 )
+        b_null_size = true;
+#endif
 
     /*
      * Do the actual decoding now */
@@ -576,6 +612,10 @@ picture_t *DecodeVideo( decoder_t *p_dec
 
         post_mt( p_sys );
 
+#ifdef ANDROID
+        mtime_t i_decode_start = mdate();
+#endif
+
         av_init_packet( &pkt );
         pkt.data = p_block->p_buffer;
         pkt.size = p_block->i_buffer;
@@ -592,6 +632,16 @@ picture_t *DecodeVideo( decoder_t *p_dec
             i_used = avcodec_decode_video2( p_context, p_sys->p_ff_pic,
                                            &b_gotpicture, &pkt );
         }
+
+#ifdef ANDROID
+        mtime_t i_decode_end = mdate();
+        mtime_t i_decode_time = i_decode_end - i_decode_start;
+        p_sys->i_decode_called_count += 1;
+        p_sys->i_decode_total_time += i_decode_time;
+        p_sys->i_decode_average_time = (p_sys->i_decode_total_time / p_sys->i_decode_called_count);
+        p_sys->i_decode_last_time = i_decode_time;
+#endif
+
         wait_mt( p_sys );
 
         if( p_sys->b_flush )
@@ -694,6 +744,10 @@ picture_t *DecodeVideo( decoder_t *p_dec
         if( !(p_block->i_flags & BLOCK_FLAG_PREROLL) )
             i_display_date = decoder_GetDisplayDate( p_dec, i_pts );
 
+#ifdef ANDROID
+        p_sys->i_display_date_head = i_display_date;
+#endif
+
         if( i_display_date > 0 && i_display_date <= mdate() )
         {
             p_sys->i_late_frames++;
diff -Nurp vlc-a/modules/codec/libass.c vlc-b/modules/codec/libass.c
--- vlc-a/modules/codec/libass.c	2011-07-18 20:34:11.649213851 +0800
+++ vlc-b/modules/codec/libass.c	2011-07-10 01:53:49.020262284 +0800
@@ -199,6 +199,13 @@ static int Create( vlc_object_t *p_this 
     const char *psz_font = NULL; /* We don't ship a default font with VLC */
     const char *psz_family = "Arial"; /* Use Arial if we can't find anything more suitable */
 
+#ifdef ANDROID
+    /* is this useful? */
+    ass_set_fonts_dir( p_library, "/system/fonts" );
+    /* don't crash libass */
+    psz_font = "/system/fonts/DroidSansFallback.ttf";
+#endif
+
 #ifdef HAVE_FONTCONFIG
 #if defined(WIN32)
     dialog_progress_bar_t *p_dialog =
diff -Nurp vlc-a/modules/demux/Android.mk vlc-b/modules/demux/Android.mk
--- vlc-a/modules/demux/Android.mk	1970-01-01 08:00:00.000000000 +0800
+++ vlc-b/modules/demux/Android.mk	2011-07-18 20:27:21.420386482 +0800
@@ -0,0 +1,59 @@
+
+LOCAL_PATH := $(call my-dir)
+
+include $(CLEAR_VARS)
+
+LOCAL_ARM_MODE := arm
+ifeq ($(BUILD_WITH_NEON),1)
+LOCAL_ARM_NEON := true
+endif
+
+LOCAL_MODULE := live555_plugin
+
+LOCAL_CPPFLAGS += \
+    -DHAVE_CONFIG_H \
+    -DMODULE_STRING=\"live555\" \
+    -DMODULE_NAME=live555
+
+LOCAL_C_INCLUDES += \
+    $(VLCROOT) \
+    $(VLCROOT)/include \
+    $(VLCROOT)/src \
+    $(EXTROOT)/live555/BasicUsageEnvironment/include \
+    $(EXTROOT)/live555/UsageEnvironment/include \
+    $(EXTROOT)/live555/groupsock/include \
+    $(EXTROOT)/live555/liveMedia/include
+
+LOCAL_SRC_FILES := \
+    live555.cpp
+
+include $(BUILD_STATIC_LIBRARY)
+
+include $(CLEAR_VARS)
+
+LOCAL_ARM_MODE := arm
+ifeq ($(BUILD_WITH_NEON),1)
+LOCAL_ARM_NEON := true
+endif
+
+LOCAL_MODULE := subtitle_plugin
+
+LOCAL_CFLAGS += \
+    -std=c99 \
+    -DHAVE_CONFIG_H \
+    -DMODULE_STRING=\"subtitle\" \
+    -DMODULE_NAME=subtitle
+
+LOCAL_C_INCLUDES += \
+    $(VLCROOT) \
+    $(VLCROOT)/include
+
+LOCAL_SRC_FILES := \
+    subtitle.c
+
+include $(BUILD_STATIC_LIBRARY)
+
+include $(CLEAR_VARS)
+
+include $(call all-makefiles-under,$(LOCAL_PATH))
+
diff -Nurp vlc-a/modules/demux/asf/Android.mk vlc-b/modules/demux/asf/Android.mk
--- vlc-a/modules/demux/asf/Android.mk	1970-01-01 08:00:00.000000000 +0800
+++ vlc-b/modules/demux/asf/Android.mk	2011-07-10 01:53:49.040262396 +0800
@@ -0,0 +1,28 @@
+
+LOCAL_PATH := $(call my-dir)
+
+include $(CLEAR_VARS)
+
+LOCAL_ARM_MODE := arm
+ifeq ($(BUILD_WITH_NEON),1)
+LOCAL_ARM_NEON := true
+endif
+
+LOCAL_MODULE := liblibasf_plugin
+
+LOCAL_CFLAGS += \
+    -std=c99 \
+    -DHAVE_CONFIG_H \
+    -DMODULE_STRING=\"libasf\" \
+    -DMODULE_NAME=libasf
+
+LOCAL_C_INCLUDES += \
+    $(VLCROOT) \
+    $(VLCROOT)/include
+
+LOCAL_SRC_FILES := \
+    asf.c \
+    libasf.c
+
+include $(BUILD_STATIC_LIBRARY)
+
diff -Nurp vlc-a/modules/demux/avformat/Android.mk vlc-b/modules/demux/avformat/Android.mk
--- vlc-a/modules/demux/avformat/Android.mk	1970-01-01 08:00:00.000000000 +0800
+++ vlc-b/modules/demux/avformat/Android.mk	2011-07-10 01:53:49.042262406 +0800
@@ -0,0 +1,30 @@
+
+LOCAL_PATH := $(call my-dir)
+
+include $(CLEAR_VARS)
+
+LOCAL_ARM_MODE := arm
+ifeq ($(BUILD_WITH_NEON),1)
+LOCAL_ARM_NEON := true
+endif
+
+LOCAL_MODULE := avformat_plugin
+
+LOCAL_CFLAGS += \
+    -std=c99 \
+    -DHAVE_CONFIG_H \
+    -DMODULE_STRING=\"avformat\" \
+    -DMODULE_NAME=avformat
+
+LOCAL_C_INCLUDES += \
+    $(VLCROOT) \
+    $(VLCROOT)/include \
+    $(VLCROOT)/src \
+    $(EXTROOT)/ffmpeg
+
+LOCAL_SRC_FILES := \
+    avformat.c \
+    demux.c
+
+include $(BUILD_STATIC_LIBRARY)
+
diff -Nurp vlc-a/modules/demux/avi/Android.mk vlc-b/modules/demux/avi/Android.mk
--- vlc-a/modules/demux/avi/Android.mk	1970-01-01 08:00:00.000000000 +0800
+++ vlc-b/modules/demux/avi/Android.mk	2011-07-10 01:53:49.043262412 +0800
@@ -0,0 +1,28 @@
+
+LOCAL_PATH := $(call my-dir)
+
+include $(CLEAR_VARS)
+
+LOCAL_ARM_MODE := arm
+ifeq ($(BUILD_WITH_NEON),1)
+LOCAL_ARM_NEON := true
+endif
+
+LOCAL_MODULE := liblibavi_plugin
+
+LOCAL_CFLAGS += \
+    -std=c99 \
+    -DHAVE_CONFIG_H \
+    -DMODULE_STRING=\"libavi\" \
+    -DMODULE_NAME=libavi
+
+LOCAL_C_INCLUDES += \
+    $(VLCROOT) \
+    $(VLCROOT)/include
+
+LOCAL_SRC_FILES := \
+    avi.c \
+    libavi.c
+
+include $(BUILD_STATIC_LIBRARY)
+
diff -Nurp vlc-a/modules/demux/mkv/Android.mk vlc-b/modules/demux/mkv/Android.mk
--- vlc-a/modules/demux/mkv/Android.mk	1970-01-01 08:00:00.000000000 +0800
+++ vlc-b/modules/demux/mkv/Android.mk	2011-07-18 15:13:03.522867926 +0800
@@ -0,0 +1,37 @@
+
+LOCAL_PATH := $(call my-dir)
+
+include $(CLEAR_VARS)
+
+LOCAL_ARM_MODE := arm
+ifeq ($(BUILD_WITH_NEON),1)
+LOCAL_ARM_NEON := true
+endif
+
+LOCAL_MODULE := libmkv_plugin
+
+LOCAL_CFLAGS += \
+    -DHAVE_CONFIG_H \
+    -DMODULE_STRING=\"mkv\" \
+    -DMODULE_NAME=mkv
+
+LOCAL_C_INCLUDES += \
+    $(VLCROOT) \
+    $(VLCROOT)/include \
+    $(EXTROOT)/libebml \
+    $(EXTROOT)/libmatroska
+
+LOCAL_SRC_FILES := \
+	chapter_command.cpp \
+	chapters.cpp \
+	demux.cpp \
+	Ebml_parser.cpp \
+	matroska_segment.cpp \
+	matroska_segment_parse.cpp \
+	mkv.cpp \
+	stream_io_callback.cpp \
+	util.cpp \
+	virtual_segment.cpp
+
+include $(BUILD_STATIC_LIBRARY)
+
diff -Nurp vlc-a/modules/demux/mp4/Android.mk vlc-b/modules/demux/mp4/Android.mk
--- vlc-a/modules/demux/mp4/Android.mk	1970-01-01 08:00:00.000000000 +0800
+++ vlc-b/modules/demux/mp4/Android.mk	2011-07-10 01:53:49.051262457 +0800
@@ -0,0 +1,29 @@
+
+LOCAL_PATH := $(call my-dir)
+
+include $(CLEAR_VARS)
+
+LOCAL_ARM_MODE := arm
+ifeq ($(BUILD_WITH_NEON),1)
+LOCAL_ARM_NEON := true
+endif
+
+LOCAL_MODULE := liblibmp4_plugin
+
+LOCAL_CFLAGS += \
+    -std=c99 \
+    -DHAVE_CONFIG_H \
+    -DMODULE_STRING=\"libmp4\" \
+    -DMODULE_NAME=libmp4
+
+LOCAL_C_INCLUDES += \
+    $(VLCROOT) \
+    $(VLCROOT)/include
+
+LOCAL_SRC_FILES := \
+    drms.c \
+    libmp4.c \
+    mp4.c
+
+include $(BUILD_STATIC_LIBRARY)
+
diff -Nurp vlc-a/modules/demux/mpeg/Android.mk vlc-b/modules/demux/mpeg/Android.mk
--- vlc-a/modules/demux/mpeg/Android.mk	1970-01-01 08:00:00.000000000 +0800
+++ vlc-b/modules/demux/mpeg/Android.mk	2011-07-10 01:53:49.055262479 +0800
@@ -0,0 +1,27 @@
+
+LOCAL_PATH := $(call my-dir)
+
+include $(CLEAR_VARS)
+
+LOCAL_ARM_MODE := arm
+ifeq ($(BUILD_WITH_NEON),1)
+LOCAL_ARM_NEON := true
+endif
+
+LOCAL_MODULE := mpgv_plugin
+
+LOCAL_CFLAGS += \
+    -std=c99 \
+    -DHAVE_CONFIG_H \
+    -DMODULE_STRING=\"mpgv\" \
+    -DMODULE_NAME=mpgv
+
+LOCAL_C_INCLUDES += \
+    $(VLCROOT) \
+    $(VLCROOT)/include
+
+LOCAL_SRC_FILES := \
+    mpgv.c
+
+include $(BUILD_STATIC_LIBRARY)
+
diff -Nurp vlc-a/modules/demux/playlist/Android.mk.bak vlc-b/modules/demux/playlist/Android.mk.bak
--- vlc-a/modules/demux/playlist/Android.mk.bak	1970-01-01 08:00:00.000000000 +0800
+++ vlc-b/modules/demux/playlist/Android.mk.bak	2011-07-10 01:53:49.057262490 +0800
@@ -0,0 +1,43 @@
+
+LOCAL_PATH := $(call my-dir)
+
+include $(CLEAR_VARS)
+
+LOCAL_ARM_MODE := arm
+ifeq ($(BUILD_WITH_NEON),1)
+LOCAL_ARM_NEON := true
+endif
+
+LOCAL_MODULE := liblibplaylist_plugin
+
+LOCAL_CFLAGS += \
+    -std=c99 \
+    -DHAVE_CONFIG_H \
+    -DMODULE_STRING=\"libplaylist\" \
+    -DMODULE_NAME=libplaylist
+
+LOCAL_C_INCLUDES += \
+    $(VLCROOT) \
+    $(VLCROOT)/include
+
+LOCAL_SRC_FILES := \
+    asx.c \
+    b4s.c \
+    dvb.c \
+    gvp.c \
+    ifo.c \
+    itml.c \
+    m3u.c \
+    playlist.c \
+    pls.c \
+    podcast.c \
+    qtl.c \
+    ram.c \
+    sgimb.c \
+    shoutcast.c \
+    wpl.c \
+    xspf.c \
+    zpl.c
+
+include $(BUILD_STATIC_LIBRARY)
+
diff -Nurp vlc-a/modules/misc/Android.mk vlc-b/modules/misc/Android.mk
--- vlc-a/modules/misc/Android.mk	1970-01-01 08:00:00.000000000 +0800
+++ vlc-b/modules/misc/Android.mk	2011-07-10 01:53:49.157263049 +0800
@@ -0,0 +1,3 @@
+LOCAL_PATH := $(call my-dir)
+include $(CLEAR_VARS)
+include $(call all-makefiles-under,$(LOCAL_PATH))
diff -Nurp vlc-a/modules/misc/dummy/Android.mk vlc-b/modules/misc/dummy/Android.mk
--- vlc-a/modules/misc/dummy/Android.mk	1970-01-01 08:00:00.000000000 +0800
+++ vlc-b/modules/misc/dummy/Android.mk	2011-07-10 01:53:49.158263054 +0800
@@ -0,0 +1,34 @@
+
+LOCAL_PATH := $(call my-dir)
+
+include $(CLEAR_VARS)
+
+LOCAL_ARM_MODE := arm
+ifeq ($(BUILD_WITH_NEON),1)
+LOCAL_ARM_NEON := true
+endif
+
+LOCAL_MODULE := dummy_plugin
+
+LOCAL_CFLAGS += \
+    -std=c99 \
+    -DHAVE_CONFIG_H \
+    -DMODULE_STRING=\"dummy\" \
+    -DMODULE_NAME=dummy
+
+LOCAL_C_INCLUDES += \
+    $(VLCROOT) \
+    $(VLCROOT)/include
+
+LOCAL_SRC_FILES := \
+    aout.c \
+    decoder.c \
+    dummy.c \
+    encoder.c \
+    input.c \
+    interface.c \
+    renderer.c \
+    vout.c
+
+include $(BUILD_STATIC_LIBRARY)
+
diff -Nurp vlc-a/modules/misc/text_renderer/Android.mk vlc-b/modules/misc/text_renderer/Android.mk
--- vlc-a/modules/misc/text_renderer/Android.mk	1970-01-01 08:00:00.000000000 +0800
+++ vlc-b/modules/misc/text_renderer/Android.mk	2011-07-10 01:53:49.176263153 +0800
@@ -0,0 +1,32 @@
+
+LOCAL_PATH := $(call my-dir)
+
+include $(CLEAR_VARS)
+
+LOCAL_ARM_MODE := arm
+ifeq ($(BUILD_WITH_NEON),1)
+LOCAL_ARM_NEON := true
+endif
+
+LOCAL_MODULE := freetype_plugin
+
+LOCAL_CFLAGS += \
+    -std=c99 \
+    -DHAVE_CONFIG_H \
+    -DMODULE_STRING=\"freetype\" \
+    -DMODULE_NAME=freetype
+
+LOCAL_C_INCLUDES += \
+    $(VLCROOT) \
+    $(VLCROOT)/include \
+    $(VLCROOT)/src \
+    $(EXTROOT)/iconv/include \
+    $(EXTROOT)/freetype/include
+
+LOCAL_SRC_FILES := \
+    freetype.c
+
+include $(BUILD_STATIC_LIBRARY)
+
+include $(CLEAR_VARS)
+
diff -Nurp vlc-a/modules/packetizer/Android.mk vlc-b/modules/packetizer/Android.mk
--- vlc-a/modules/packetizer/Android.mk	1970-01-01 08:00:00.000000000 +0800
+++ vlc-b/modules/packetizer/Android.mk	2011-07-10 01:53:49.184263199 +0800
@@ -0,0 +1,228 @@
+
+LOCAL_PATH := $(call my-dir)
+
+include $(CLEAR_VARS)
+
+LOCAL_ARM_MODE := arm
+ifeq ($(BUILD_WITH_NEON),1)
+LOCAL_ARM_NEON := true
+endif
+
+LOCAL_MODULE := packetizer_copy_plugin
+
+LOCAL_CFLAGS += \
+    -std=c99 \
+    -DHAVE_CONFIG_H \
+    -DMODULE_STRING=\"packetizer_copy\" \
+    -DMODULE_NAME=packetizer_copy
+
+LOCAL_C_INCLUDES += \
+    $(VLCROOT) \
+    $(VLCROOT)/include \
+    $(VLCROOT)/src
+
+LOCAL_SRC_FILES := \
+    copy.c
+
+include $(BUILD_STATIC_LIBRARY)
+
+include $(CLEAR_VARS)
+
+LOCAL_ARM_MODE := arm
+ifeq ($(BUILD_WITH_NEON),1)
+LOCAL_ARM_NEON := true
+endif
+
+LOCAL_MODULE := packetizer_dirac_plugin
+
+LOCAL_CFLAGS += \
+    -std=c99 \
+    -DHAVE_CONFIG_H \
+    -DMODULE_STRING=\"packetizer_dirac\" \
+    -DMODULE_NAME=packetizer_dirac
+
+LOCAL_C_INCLUDES += \
+    $(VLCROOT) \
+    $(VLCROOT)/include \
+    $(VLCROOT)/src
+
+LOCAL_SRC_FILES := \
+    dirac.c
+
+include $(BUILD_STATIC_LIBRARY)
+
+include $(CLEAR_VARS)
+
+LOCAL_ARM_MODE := arm
+ifeq ($(BUILD_WITH_NEON),1)
+LOCAL_ARM_NEON := true
+endif
+
+LOCAL_MODULE := packetizer_flac_plugin
+
+LOCAL_CFLAGS += \
+    -std=c99 \
+    -DHAVE_CONFIG_H \
+    -DMODULE_STRING=\"packetizer_flac\" \
+    -DMODULE_NAME=packetizer_flac
+
+LOCAL_C_INCLUDES += \
+    $(VLCROOT) \
+    $(VLCROOT)/include \
+    $(VLCROOT)/src
+
+LOCAL_SRC_FILES := \
+    flac.c
+
+include $(BUILD_STATIC_LIBRARY)
+
+include $(CLEAR_VARS)
+
+LOCAL_ARM_MODE := arm
+ifeq ($(BUILD_WITH_NEON),1)
+LOCAL_ARM_NEON := true
+endif
+
+LOCAL_MODULE := packetizer_h264_plugin
+
+LOCAL_CFLAGS += \
+    -std=c99 \
+    -DHAVE_CONFIG_H \
+    -DMODULE_STRING=\"packetizer_h264\" \
+    -DMODULE_NAME=packetizer_h264
+
+LOCAL_C_INCLUDES += \
+    $(VLCROOT) \
+    $(VLCROOT)/include \
+    $(VLCROOT)/src
+
+LOCAL_SRC_FILES := \
+    h264.c
+
+include $(BUILD_STATIC_LIBRARY)
+
+include $(CLEAR_VARS)
+
+LOCAL_ARM_MODE := arm
+ifeq ($(BUILD_WITH_NEON),1)
+LOCAL_ARM_NEON := true
+endif
+
+LOCAL_MODULE := packetizer_mlp_plugin
+
+LOCAL_CFLAGS += \
+    -std=c99 \
+    -DHAVE_CONFIG_H \
+    -DMODULE_STRING=\"packetizer_mlp\" \
+    -DMODULE_NAME=packetizer_mlp
+
+LOCAL_C_INCLUDES += \
+    $(VLCROOT) \
+    $(VLCROOT)/include \
+    $(VLCROOT)/src
+
+LOCAL_SRC_FILES := \
+    mlp.c
+
+include $(BUILD_STATIC_LIBRARY)
+
+include $(CLEAR_VARS)
+
+LOCAL_ARM_MODE := arm
+ifeq ($(BUILD_WITH_NEON),1)
+LOCAL_ARM_NEON := true
+endif
+
+LOCAL_MODULE := packetizer_mpeg4audio_plugin
+
+LOCAL_CFLAGS += \
+    -std=c99 \
+    -DHAVE_CONFIG_H \
+    -DMODULE_STRING=\"packetizer_mpeg4audio\" \
+    -DMODULE_NAME=packetizer_mpeg4audio
+
+LOCAL_C_INCLUDES += \
+    $(VLCROOT) \
+    $(VLCROOT)/include \
+    $(VLCROOT)/src
+
+LOCAL_SRC_FILES := \
+    mpeg4audio.c
+
+include $(BUILD_STATIC_LIBRARY)
+
+include $(CLEAR_VARS)
+
+LOCAL_ARM_MODE := arm
+ifeq ($(BUILD_WITH_NEON),1)
+LOCAL_ARM_NEON := true
+endif
+
+LOCAL_MODULE := packetizer_mpeg4video_plugin
+
+LOCAL_CFLAGS += \
+    -std=c99 \
+    -DHAVE_CONFIG_H \
+    -DMODULE_STRING=\"packetizer_mpeg4video\" \
+    -DMODULE_NAME=packetizer_mpeg4video
+
+LOCAL_C_INCLUDES += \
+    $(VLCROOT) \
+    $(VLCROOT)/include \
+    $(VLCROOT)/src
+
+LOCAL_SRC_FILES := \
+    mpeg4video.c
+
+include $(BUILD_STATIC_LIBRARY)
+
+include $(CLEAR_VARS)
+
+LOCAL_ARM_MODE := arm
+ifeq ($(BUILD_WITH_NEON),1)
+LOCAL_ARM_NEON := true
+endif
+
+LOCAL_MODULE := packetizer_mpegvideo_plugin
+
+LOCAL_CFLAGS += \
+    -std=c99 \
+    -DHAVE_CONFIG_H \
+    -DMODULE_STRING=\"packetizer_mpegvideo\" \
+    -DMODULE_NAME=packetizer_mpegvideo
+
+LOCAL_C_INCLUDES += \
+    $(VLCROOT) \
+    $(VLCROOT)/include \
+    $(VLCROOT)/src
+
+LOCAL_SRC_FILES := \
+    mpegvideo.c
+
+include $(BUILD_STATIC_LIBRARY)
+
+include $(CLEAR_VARS)
+
+LOCAL_ARM_MODE := arm
+ifeq ($(BUILD_WITH_NEON),1)
+LOCAL_ARM_NEON := true
+endif
+
+LOCAL_MODULE := packetizer_vc1_plugin
+
+LOCAL_CFLAGS += \
+    -std=c99 \
+    -DHAVE_CONFIG_H \
+    -DMODULE_STRING=\"packetizer_vc1\" \
+    -DMODULE_NAME=packetizer_vc1
+
+LOCAL_C_INCLUDES += \
+    $(VLCROOT) \
+    $(VLCROOT)/include \
+    $(VLCROOT)/src
+
+LOCAL_SRC_FILES := \
+    vc1.c
+
+include $(BUILD_STATIC_LIBRARY)
+
diff -Nurp vlc-a/modules/video_filter/Android.mk vlc-b/modules/video_filter/Android.mk
--- vlc-a/modules/video_filter/Android.mk	1970-01-01 08:00:00.000000000 +0800
+++ vlc-b/modules/video_filter/Android.mk	2011-07-10 01:53:49.200263288 +0800
@@ -0,0 +1,57 @@
+
+LOCAL_PATH := $(call my-dir)
+
+include $(CLEAR_VARS)
+
+LOCAL_ARM_MODE := arm
+ifeq ($(BUILD_WITH_NEON),1)
+LOCAL_ARM_NEON := true
+endif
+
+LOCAL_MODULE := blend_plugin
+
+LOCAL_CFLAGS += \
+    -std=c99 \
+    -DHAVE_CONFIG_H \
+    -DMODULE_STRING=\"blend\" \
+    -DMODULE_NAME=blend
+
+LOCAL_C_INCLUDES += \
+    $(VLCROOT) \
+    $(VLCROOT)/include \
+    $(VLCROOT)/src
+
+LOCAL_SRC_FILES := \
+    blend.c
+
+include $(BUILD_STATIC_LIBRARY)
+
+include $(CLEAR_VARS)
+
+LOCAL_ARM_MODE := arm
+ifeq ($(BUILD_WITH_NEON),1)
+LOCAL_ARM_NEON := true
+endif
+
+LOCAL_MODULE := swscale_plugin
+
+LOCAL_CFLAGS += \
+    -std=c99 \
+    -DHAVE_CONFIG_H \
+    -DMODULE_STRING=\"swscale\" \
+    -DMODULE_NAME=swscale
+
+LOCAL_CFLAGS += $(COMMON_TUNE_CFLAGS)
+LOCAL_LDFLAGS += $(COMMON_TUNE_LDFLAGS)
+
+LOCAL_C_INCLUDES += \
+    $(VLCROOT) \
+    $(VLCROOT)/include \
+    $(VLCROOT)/src \
+    $(EXTROOT)/ffmpeg
+
+LOCAL_SRC_FILES := \
+    swscale.c
+
+include $(BUILD_STATIC_LIBRARY)
+
diff -Nurp vlc-a/modules/video_output/Android.mk vlc-b/modules/video_output/Android.mk
--- vlc-a/modules/video_output/Android.mk	1970-01-01 08:00:00.000000000 +0800
+++ vlc-b/modules/video_output/Android.mk	2011-07-10 01:53:49.225263429 +0800
@@ -0,0 +1,53 @@
+
+LOCAL_PATH := $(call my-dir)
+
+include $(CLEAR_VARS)
+
+LOCAL_ARM_MODE := arm
+ifeq ($(BUILD_WITH_NEON),1)
+LOCAL_ARM_NEON := true
+endif
+
+LOCAL_MODULE := android_surface_plugin
+
+LOCAL_CFLAGS += \
+    -std=c99 \
+    -DHAVE_CONFIG_H \
+    -DMODULE_STRING=\"android_surface\" \
+    -DMODULE_NAME=android_surface
+
+LOCAL_C_INCLUDES += \
+    $(VLCROOT) \
+    $(VLCROOT)/include \
+    $(VLCROOT)/src
+
+LOCAL_SRC_FILES := \
+    androidsurface.c
+
+include $(BUILD_STATIC_LIBRARY)
+
+include $(CLEAR_VARS)
+
+LOCAL_ARM_MODE := arm
+ifeq ($(BUILD_WITH_NEON),1)
+LOCAL_ARM_NEON := true
+endif
+
+LOCAL_MODULE := vmem_plugin
+
+LOCAL_CFLAGS += \
+    -std=c99 \
+    -DHAVE_CONFIG_H \
+    -DMODULE_STRING=\"vmem\" \
+    -DMODULE_NAME=vmem
+
+LOCAL_C_INCLUDES += \
+    $(VLCROOT) \
+    $(VLCROOT)/include \
+    $(VLCROOT)/src
+
+LOCAL_SRC_FILES := \
+    vmem.c
+
+include $(BUILD_STATIC_LIBRARY)
+
diff -Nurp vlc-a/modules/video_output/androidsurface.c vlc-b/modules/video_output/androidsurface.c
--- vlc-a/modules/video_output/androidsurface.c	2011-07-18 20:34:11.972215276 +0800
+++ vlc-b/modules/video_output/androidsurface.c	2011-07-10 01:53:49.226263435 +0800
@@ -161,10 +161,10 @@ static int Open(vlc_object_t *p_this) {
 
     /* Setup chroma */
     video_format_t fmt = vd->fmt;
-    fmt.i_chroma = VLC_CODEC_RGB32;
-    fmt.i_rmask  = 0x000000ff;
-    fmt.i_gmask  = 0x0000ff00;
-    fmt.i_bmask  = 0x00ff0000;
+    fmt.i_chroma = VLC_CODEC_RGB16;
+    fmt.i_rmask  = 0x0000f800;
+    fmt.i_gmask  = 0x000007e0;
+    fmt.i_bmask  = 0x0000001f;
     video_format_FixRgb(&fmt);
 
     /* Create the associated picture */
@@ -265,7 +265,7 @@ static int  AndroidLockSurface(picture_t
     }
 
     picture->p->p_pixels = (uint8_t*)info->bits;
-    picture->p->i_pitch = 4 * info->s;
+    picture->p->i_pitch = 2 * info->s;
     picture->p->i_lines = info->h;
 
     return VLC_SUCCESS;
diff -Nurp vlc-a/Modules.mk vlc-b/Modules.mk
--- vlc-a/Modules.mk	1970-01-01 08:00:00.000000000 +0800
+++ vlc-b/Modules.mk	2011-07-18 20:27:21.391386353 +0800
@@ -0,0 +1,13 @@
+# modules begin
+LOCAL_STATIC_LIBRARIES += access_avio_plugin access_demux_avformat_plugin access_http_plugin access_mms_plugin amem_plugin android_surface_plugin audiotrack_android_plugin avcodec_plugin avformat_plugin bandlimited_resampler_plugin blend_plugin converter_fixed_plugin dummy_plugin filesystem_plugin fixed32_mixer_plugin float32_mixer_plugin freetype_plugin libasf_plugin libass_plugin libavi_plugin libmp4_plugin live555_plugin mkv_plugin mpeg_audio_plugin mpgv_plugin packetizer_copy_plugin packetizer_dirac_plugin packetizer_flac_plugin packetizer_h264_plugin packetizer_mlp_plugin packetizer_mpeg4audio_plugin packetizer_mpeg4video_plugin packetizer_mpegvideo_plugin packetizer_vc1_plugin realrtsp_plugin simple_channel_mixer_plugin subsdec_plugin subsusf_plugin subtitle_plugin swscale_plugin trivial_mixer_plugin ugly_resampler_plugin vmem_plugin yuv2rgb_plugin
+# modules end
+
+LOCAL_STATIC_LIBRARIES += ass freetype iconv charset live555 ebml matroska
+
+# it's the only choice
+ifeq ($(APP_STL),gnustl_static)
+LOCAL_STATIC_LIBRARIES += gnustl_static
+endif
+
+LOCAL_WHOLE_STATIC_LIBRARIES += avformat avfilter avcodec avdevice avutil swscale
+
diff -Nurp vlc-a/src/control/core.c vlc-b/src/control/core.c
--- vlc-a/src/control/core.c	2011-07-18 20:34:12.544217797 +0800
+++ vlc-b/src/control/core.c	2011-07-10 01:53:51.235274643 +0800
@@ -38,7 +38,8 @@
 
 static const char nomemstr[] = "Insufficient memory";
 
-libvlc_instance_t * libvlc_new( int argc, const char *const *argv )
+libvlc_instance_t * libvlc_new_with_builtins( int argc, const char *const *argv,
+                                             const void ** builtins_module)
 {
     libvlc_instance_t *p_new = malloc (sizeof (*p_new));
     if (unlikely(p_new == NULL))
@@ -56,7 +57,7 @@ libvlc_instance_t * libvlc_new( int argc
     if (unlikely (p_libvlc_int == NULL))
         goto error;
 
-    if (libvlc_InternalInit( p_libvlc_int, argc + 1, my_argv ))
+    if (libvlc_InternalInit( p_libvlc_int, argc + 1, my_argv, builtins_module ))
     {
         libvlc_InternalDestroy( p_libvlc_int );
         goto error;
@@ -80,6 +81,12 @@ error:
     return NULL;
 }
 
+libvlc_instance_t * libvlc_new( int argc, const char *const *argv)
+{
+    return libvlc_new_with_builtins(argc, argv, NULL);
+}
+
+
 void libvlc_retain( libvlc_instance_t *p_instance )
 {
     assert( p_instance != NULL );
diff -Nurp vlc-a/src/control/error.c vlc-b/src/control/error.c
--- vlc-a/src/control/error.c	2011-07-18 20:34:12.544217797 +0800
+++ vlc-b/src/control/error.c	2011-07-18 15:13:03.522867926 +0800
@@ -25,6 +25,14 @@
 #include <assert.h>
 #include <vlc/libvlc.h>
 
+#ifdef ANDROID
+
+#include <android/log.h>
+
+void pthread_cancel_initialize(void);
+void pthread_cancel_deinitialize(void);
+
+#endif
 
 static const char oom[] = "Out of memory";
 /* TODO: use only one thread-specific key for whole libvlc */
@@ -38,14 +46,27 @@ static void libvlc_setup_threads (bool i
     vlc_mutex_lock (&lock);
     if (init)
     {
+#ifdef ANDROID
+        if (refs++ == 0) {
+            vlc_threadvar_create (&context, free);
+            pthread_cancel_initialize ();
+        }
+#else
         if (refs++ == 0)
             vlc_threadvar_create (&context, free);
+#endif
     }
     else
     {
-        assert (refs > 0);
+#ifdef ANDROID
+        if (--refs == 0) {
+            vlc_threadvar_delete (&context);
+            pthread_cancel_deinitialize ();
+        }
+#else
         if (--refs == 0)
             vlc_threadvar_delete (&context);
+#endif
     }
     vlc_mutex_unlock (&lock);
 }
@@ -125,6 +146,9 @@ const char *libvlc_printerr (const char 
 
     va_start (ap, fmt);
     msg = libvlc_vprinterr (fmt, ap);
+#ifdef ANDROID
+	__android_log_vprint(ANDROID_LOG_ERROR, "LIBVLC", fmt, ap);
+#endif
     va_end (ap);
     return msg;
 }
diff -Nurp vlc-a/src/control/libvlc_internal.h vlc-b/src/control/libvlc_internal.h
--- vlc-a/src/control/libvlc_internal.h	2011-07-18 20:34:12.545217801 +0800
+++ vlc-b/src/control/libvlc_internal.h	2011-07-10 01:53:51.235274643 +0800
@@ -44,7 +44,7 @@
  * Internal creation and destruction functions
  ***************************************************************************/
 VLC_API libvlc_int_t *libvlc_InternalCreate( void );
-VLC_API int libvlc_InternalInit( libvlc_int_t *, int, const char *ppsz_argv[] );
+VLC_API int libvlc_InternalInit( libvlc_int_t *, int, const char *ppsz_argv[], const void **builtins_module );
 VLC_API void libvlc_InternalCleanup( libvlc_int_t * );
 VLC_API void libvlc_InternalDestroy( libvlc_int_t * );
 
diff -Nurp vlc-a/src/libvlc.c vlc-b/src/libvlc.c
--- vlc-a/src/libvlc.c	2011-07-18 20:34:12.566217894 +0800
+++ vlc-b/src/libvlc.c	2011-07-10 01:53:51.257274764 +0800
@@ -249,7 +249,7 @@ error:
  *  - configuration and commandline parsing
  */
 int libvlc_InternalInit( libvlc_int_t *p_libvlc, int i_argc,
-                         const char *ppsz_argv[] )
+                         const char *ppsz_argv[], const void **builtins_module )
 {
     libvlc_priv_t *priv = libvlc_priv (p_libvlc);
     char *       p_tmp = NULL;
@@ -410,7 +410,7 @@ int libvlc_InternalInit( libvlc_int_t *p
      * list of configuration options exported by each module and loads their
      * default values.
      */
-    module_LoadPlugins( p_libvlc );
+    module_LoadPlugins( p_libvlc, builtins_module );
     if( p_libvlc->b_die )
     {
         b_exit = true;
diff -Nurp vlc-a/src/libvlcjni.c vlc-b/src/libvlcjni.c
--- vlc-a/src/libvlcjni.c	1970-01-01 08:00:00.000000000 +0800
+++ vlc-b/src/libvlcjni.c	2011-07-18 15:16:32.346440513 +0800
@@ -0,0 +1,528 @@
+
+#ifdef HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include <vlc/vlc.h>
+#include <vlc_common.h>
+
+#ifdef ANDROID
+
+#include <jni.h>
+#include <android/log.h>
+#include <stdlib.h>
+
+#include "libvlcjni.h"
+
+#define NAME1(CLZ, FUN) Java_##CLZ##_##FUN
+#define NAME2(CLZ, FUN) NAME1(CLZ, FUN)
+
+#define NAME(FUN) NAME2(CLASS, FUN)
+
+#define CLASS org_stagex_danmaku_player_VlcMediaPlayer
+#define PREFIX "org/stagex/danmaku/player/"
+
+JavaVM *gJVM = NULL;
+
+static void *s_surface = 0;
+static pthread_mutex_t s_surface_mutex;
+
+static jclass clz_VlcEvent = 0;
+static jfieldID f_VlcEvent_eventType = 0;
+static jfieldID f_VlcEvent_booleanValue = 0;
+static jfieldID f_VlcEvent_intValue = 0;
+static jfieldID f_VlcEvent_longValue = 0;
+static jfieldID f_VlcEvent_floatValue = 0;
+static jfieldID f_VlcEvent_stringValue = 0;
+static jmethodID m_VlcMediaPlayer_onVlcEvent = 0;
+
+JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM* vm, void* reserved)
+{
+    gJVM = vm;
+    pthread_mutex_init(&s_surface_mutex, 0);
+
+    return JNI_VERSION_1_4;
+}
+
+JNIEXPORT void JNICALL JNI_OnUnload(JavaVM* vm, void* reserved)
+{
+    pthread_mutex_destroy(&s_surface_mutex);
+}
+
+void *jni_LockAndGetAndroidSurface()
+{
+    pthread_mutex_lock(&s_surface_mutex);
+    return s_surface;
+}
+
+void jni_UnlockAndroidSurface()
+{
+    pthread_mutex_unlock(&s_surface_mutex);
+}
+
+void jni_SetAndroidSurfaceSize(int width, int height)
+{
+}
+
+JNIEXPORT int Java_org_stagex_danmaku_helper_SystemUtility_setenv(JNIEnv *env, jclass klz, jstring key, jstring val, jboolean overwrite)
+{
+    const char *key_utf8 = (*env)->GetStringUTFChars(env, key, NULL);
+    const char *val_utf8 = (*env)->GetStringUTFChars(env, val, NULL);
+    int err = setenv(key_utf8, val_utf8, overwrite);
+    (*env)->ReleaseStringUTFChars(env, key, key_utf8);
+    (*env)->ReleaseStringUTFChars(env, val, val_utf8);
+    return err;
+}
+
+static int getIntValue(JNIEnv *env, jobject thiz, const char *name)
+{
+    jclass clz = (*env)->GetObjectClass(env, thiz);
+    jfieldID field = (*env)->GetFieldID(env, clz, name, "I");
+    int value = (*env)->GetIntField(env, thiz, field);
+    (*env)->DeleteLocalRef(env, clz);
+    return value;
+
+}
+
+static void setIntValue(JNIEnv *env, jobject thiz, const char *name, int value)
+{
+    jclass clz = (*env)->GetObjectClass(env, thiz);
+    jfieldID field = (*env)->GetFieldID(env, clz, name, "I");
+    (*env)->SetIntField(env, thiz, field, value);
+    (*env)->DeleteLocalRef(env, clz);
+}
+
+static void vlc_event_callback(const libvlc_event_t *ev, void *data)
+{
+    JNIEnv *env;
+    jobject obj_VlcMediaPlayer = (jobject) data;
+    jobject obj_VlcEvent;
+    int trigger = 1;
+
+    if ((*gJVM)->AttachCurrentThread(gJVM, &env, 0) < 0)
+        return;
+    obj_VlcEvent = (*env)->AllocObject(env, clz_VlcEvent);
+    if (!obj_VlcEvent)
+        return;
+    libvlc_media_t *media = (libvlc_media_t *) getIntValue(env, obj_VlcMediaPlayer, "mLibVlcMedia");
+    char *mrl = libvlc_media_get_mrl(media);
+    libvlc_media_player_t *mp = (libvlc_media_player_t *) getIntValue(env, obj_VlcMediaPlayer, "mLibVlcMediaPlayer");
+    vlc_mutex_t *parse_lock = (vlc_mutex_t *) getIntValue(env, obj_VlcMediaPlayer, "mNativeMediaParseLock");
+    vlc_cond_t *parse_cond = (vlc_cond_t *) getIntValue(env, obj_VlcMediaPlayer, "mNativeMediaParseCond");
+    (*env)->SetIntField(env, obj_VlcEvent, f_VlcEvent_eventType, ev->type);
+    switch (ev->type) {
+    case libvlc_MediaDurationChanged: {
+        int64_t duration = ev->u.media_duration_changed.new_duration;
+        (*env)->SetIntField(env, obj_VlcEvent, f_VlcEvent_longValue, (jlong) duration);
+        break;
+    }
+    case libvlc_MediaStateChanged: {
+        int state = ev->u.media_state_changed.new_state;
+        (*env)->SetIntField(env, obj_VlcEvent, f_VlcEvent_intValue, state);
+        /* wake up if there is an error */
+        if (state == libvlc_MediaPlayerEncounteredError) {
+            vlc_mutex_lock(parse_lock);
+            setIntValue(env, obj_VlcMediaPlayer, "mNativeMediaParsed", 2);
+            vlc_cond_broadcast(parse_cond);
+            vlc_mutex_unlock(parse_lock);
+        }
+        break;
+    }
+    case libvlc_MediaParsedChanged: {
+        libvlc_media_player_play(mp);
+        trigger = 0;
+        break;
+    }
+    case libvlc_MediaPlayerBuffering: {
+        float cache = ev->u.media_player_buffering.new_cache;
+        (*env)->SetFloatField(env, obj_VlcEvent, f_VlcEvent_floatValue, cache);
+        int count = getIntValue(env, obj_VlcMediaPlayer, "mNativeMediaBufferingCount");
+        if ((int) cache == 100) {
+            setIntValue(env, obj_VlcMediaPlayer, "mNativeMediaBufferingCount", count + 1);
+            /* if it's the first time */
+            if (count == 0) {
+                /* send buffering update event now */
+                (*env)->CallVoidMethod(env, obj_VlcMediaPlayer, m_VlcMediaPlayer_onVlcEvent, obj_VlcEvent);
+                libvlc_media_player_set_pause(mp, 1);
+                /* asynchonous preparing is done */
+                vlc_mutex_lock(parse_lock);
+                setIntValue(env, obj_VlcMediaPlayer, "mNativeMediaParsed", 1);
+                vlc_cond_broadcast(parse_cond);
+                vlc_mutex_unlock(parse_lock);
+                /* simulate a media prepared event */
+                (*env)->SetIntField(env, obj_VlcEvent, f_VlcEvent_eventType, libvlc_MediaParsedChanged);
+                (*env)->SetBooleanField(env, obj_VlcEvent, f_VlcEvent_booleanValue, 1);
+            }
+        }
+        break;
+    }
+    case libvlc_MediaPlayerTimeChanged: {
+        int64_t time = ev->u.media_player_time_changed.new_time;
+        (*env)->SetLongField(env, obj_VlcEvent, f_VlcEvent_longValue, (jlong) time);
+        break;
+    }
+    case libvlc_MediaPlayerPositionChanged: {
+        float position = ev->u.media_player_position_changed.new_position;
+        (*env)->SetFloatField(env, obj_VlcEvent, f_VlcEvent_floatValue, position);
+        break;
+    }
+    case libvlc_MediaPlayerSeekableChanged: {
+        int seekable = ev->u.media_player_seekable_changed.new_seekable;
+        (*env)->SetBooleanField(env, obj_VlcEvent, f_VlcEvent_booleanValue, seekable > 0);
+        break;
+    }
+    case libvlc_MediaPlayerPausableChanged: {
+        int pausable = ev->u.media_player_pausable_changed.new_pausable;
+        (*env)->SetBooleanField(env, obj_VlcEvent, f_VlcEvent_booleanValue, pausable > 0);
+        break;
+    }
+    case libvlc_MediaPlayerTitleChanged: {
+        int title = ev->u.media_player_title_changed.new_title;
+        (*env)->SetIntField(env, obj_VlcEvent, f_VlcEvent_intValue, title);
+        break;
+    }
+    case libvlc_MediaPlayerSnapshotTaken: {
+        char *p = ev->u.media_player_snapshot_taken.psz_filename;
+        jstring path = (*env)->NewStringUTF(env, p);
+        (*env)->SetObjectField(env, obj_VlcEvent, f_VlcEvent_stringValue, path);
+        break;
+    }
+    case libvlc_MediaPlayerLengthChanged: {
+        int64_t length = ev->u.media_player_length_changed.new_length;
+        (*env)->SetLongField(env, obj_VlcEvent, f_VlcEvent_longValue, (jlong) length);
+        break;
+    }
+    default:
+        break;
+    }
+    if (trigger)
+        (*env)->CallVoidMethod(env, obj_VlcMediaPlayer, m_VlcMediaPlayer_onVlcEvent, obj_VlcEvent);
+    (*env)->DeleteLocalRef(env, obj_VlcEvent);
+    free(mrl);
+    /* EXPLAIN: this is called in pthread wrapper routines */
+    // (*gJVM)->DetachCurrentThread(gJVM);
+}
+
+static void initClasses(JNIEnv *env, jobject thiz)
+{
+    jclass clz;
+
+    if (!m_VlcMediaPlayer_onVlcEvent)
+    {
+        clz = (*env)->GetObjectClass(env, thiz);
+        m_VlcMediaPlayer_onVlcEvent = (*env)->GetMethodID(env, clz, "onVlcEvent", "(L" PREFIX "VlcMediaPlayer$VlcEvent;)V");
+        (*env)->DeleteLocalRef(env, clz);
+    }
+    if (!clz_VlcEvent)
+    {
+        clz = (*env)->FindClass(env, PREFIX "VlcMediaPlayer$VlcEvent");
+        clz_VlcEvent = (*env)->NewGlobalRef(env, clz);
+        f_VlcEvent_eventType = (*env)->GetFieldID(env, clz, "eventType", "I");
+        f_VlcEvent_booleanValue = (*env)->GetFieldID(env, clz, "booleanValue", "Z");
+        f_VlcEvent_intValue = (*env)->GetFieldID(env, clz, "intValue", "I");
+        f_VlcEvent_longValue = (*env)->GetFieldID(env, clz, "longValue", "J");
+        f_VlcEvent_floatValue = (*env)->GetFieldID(env, clz, "floatValue", "F");
+        f_VlcEvent_stringValue = (*env)->GetFieldID(env, clz, "stringValue", "Ljava/lang/String;");
+    }
+}
+
+static void freeClasses(JNIEnv *env, jobject thiz)
+{
+    if (clz_VlcEvent)
+    {
+        (*env)->DeleteGlobalRef(env, clz_VlcEvent);
+        clz_VlcEvent = 0;
+    }
+}
+
+JNIEXPORT void JNICALL NAME(nativeAttachSurface)(JNIEnv *env, jobject thiz, jobject s)
+{
+    jint surface = 0;
+    jclass clz;
+    jfieldID f_Surface_mSurface;
+
+    clz = (*env)->GetObjectClass(env, s);
+    f_Surface_mSurface = (*env)->GetFieldID(env, clz, "mSurface", "I");
+    if (f_Surface_mSurface == 0)
+    {
+        jthrowable e = (*env)->ExceptionOccurred(env);
+        if (e)
+        {
+            (*env)->DeleteLocalRef(env, e);
+            (*env)->ExceptionClear(env);
+        }
+        f_Surface_mSurface = (*env)->GetFieldID(env, clz, "mNativeSurface", "I");
+    }
+    surface = (*env)->GetIntField(env, s, f_Surface_mSurface);
+    pthread_mutex_lock(&s_surface_mutex);
+    s_surface = (void *) surface;
+    pthread_mutex_unlock(&s_surface_mutex);
+}
+
+JNIEXPORT void JNICALL NAME(nativeDetachSurface)(JNIEnv *env, jobject thiz)
+{
+    pthread_mutex_lock(&s_surface_mutex);
+    s_surface = 0;
+    pthread_mutex_unlock(&s_surface_mutex);
+}
+
+static libvlc_event_type_t md_listening[] = {
+    libvlc_MediaDurationChanged,
+    libvlc_MediaParsedChanged,
+    libvlc_MediaStateChanged,
+};
+
+static libvlc_event_type_t mp_listening[] = {
+    libvlc_MediaPlayerOpening,
+    libvlc_MediaPlayerBuffering,
+    libvlc_MediaPlayerPlaying,
+    libvlc_MediaPlayerPaused,
+    libvlc_MediaPlayerStopped,
+    libvlc_MediaPlayerEndReached,
+    libvlc_MediaPlayerEncounteredError,
+    libvlc_MediaPlayerTimeChanged,
+    libvlc_MediaPlayerSeekableChanged,
+    libvlc_MediaPlayerPausableChanged,
+    libvlc_MediaPlayerLengthChanged,
+};
+
+JNIEXPORT void JNICALL NAME(nativeCreate)(JNIEnv *env, jobject thiz)
+{
+    initClasses(env, thiz);
+    vlc_mutex_t *parse_lock = calloc(1, sizeof(vlc_mutex_t));
+    vlc_mutex_init(parse_lock);
+    setIntValue(env, thiz, "mNativeMediaParseLock", (jint) parse_lock);
+    vlc_cond_t *parse_cond = calloc(1, sizeof(vlc_cond_t));
+    vlc_cond_init(parse_cond);
+    setIntValue(env, thiz, "mNativeMediaParseCond", (jint) parse_cond);
+    setIntValue(env, thiz, "mNativeMediaBufferingCount", 0);
+    const char *argv[] = {"-I", "dummy", "-vvv", "--no-plugins-cache", "--no-drop-late-frames", "--input-timeshift-path", "/data/local/tmp"};
+    libvlc_instance_t *instance = libvlc_new_with_builtins(sizeof(argv) / sizeof(*argv), argv, vlc_builtins_modules);
+    setIntValue(env, thiz, "mLibVlcInstance", (jint) instance);
+    libvlc_media_player_t *mp = libvlc_media_player_new(instance);
+    setIntValue(env, thiz, "mLibVlcMediaPlayer", (jint) mp);
+    /* throw? */
+    libvlc_event_manager_t *em = libvlc_media_player_event_manager(mp);
+    for (int i = 0; i < sizeof(mp_listening) / sizeof(*mp_listening); i++)
+    {
+        libvlc_event_attach(em, mp_listening[i], vlc_event_callback, thiz);
+    }
+}
+
+JNIEXPORT void JNICALL NAME(nativeRelease)(JNIEnv *env, jobject thiz)
+{
+    vlc_mutex_t *parse_lock = (vlc_mutex_t *) getIntValue(env, thiz, "mNativeMediaParseLock");
+    vlc_cond_t *parse_cond = (vlc_cond_t *) getIntValue(env, thiz, "mNativeMediaParseCond");
+    /* wake up threads that waiting on prepare */
+    vlc_mutex_lock(parse_lock);
+    setIntValue(env, thiz, "mNativeMediaParsed", 4);
+    vlc_cond_broadcast(parse_cond);
+    vlc_mutex_unlock(parse_lock);
+    jint mLibVlcMediaPlayer = getIntValue(env, thiz, "mLibVlcMediaPlayer");
+    if (mLibVlcMediaPlayer != 0)
+    {
+        libvlc_event_manager_t *em;
+        libvlc_media_player_t *mp = (libvlc_media_player_t*) mLibVlcMediaPlayer;
+        libvlc_media_t *md = libvlc_media_player_get_media(mp);
+        if (md) {
+            em = libvlc_media_event_manager(md);
+            for (int i = 0; i < sizeof(md_listening) / sizeof(*md_listening); i++)
+            {
+                libvlc_event_detach(em, md_listening[i], vlc_event_callback, thiz);
+            }
+        }
+        em = libvlc_media_player_event_manager(mp);
+        for (int i = 0; i < sizeof(mp_listening) / sizeof(*mp_listening); i++)
+        {
+            libvlc_event_detach(em, mp_listening[i], vlc_event_callback, thiz);
+        }
+        libvlc_media_player_stop(mp);
+        libvlc_media_player_release(mp);
+        setIntValue(env, thiz, "mLibVlcMediaPlayer", 0);
+    }
+    jint mLibVlcInstance = getIntValue(env, thiz, "mLibVlcInstance");
+    if (mLibVlcInstance != 0)
+    {
+        libvlc_instance_t *instance = (libvlc_instance_t*) mLibVlcInstance;
+        libvlc_release(instance);
+        setIntValue(env, thiz, "mLibVlcInstance", 0);
+    }
+    setIntValue(env, thiz, "mNativeMediaBufferingCount", 0);
+    vlc_mutex_destroy(parse_lock);
+    free(parse_lock);
+    setIntValue(env, thiz, "mNativeMediaParseLock", 0);
+    vlc_cond_destroy(parse_cond);
+    free(parse_cond);
+    setIntValue(env, thiz, "mNativeMediaParseCond", 0);
+    freeClasses(env, thiz);
+}
+
+JNIEXPORT jint JNICALL NAME(nativeGetCurrentPosition)(JNIEnv *env, jobject thiz)
+{
+    libvlc_media_player_t *mp = (libvlc_media_player_t *) getIntValue(env, thiz, "mLibVlcMediaPlayer");
+    int64_t position = libvlc_media_player_get_time(mp);
+    if (position < 0)
+    {
+        return -1;
+    }
+    return (jint) (position / 1000);
+}
+
+JNIEXPORT jint JNICALL NAME(nativeGetDuration)(JNIEnv *env, jobject thiz)
+{
+    libvlc_media_player_t *mp = (libvlc_media_player_t *) getIntValue(env, thiz, "mLibVlcMediaPlayer");
+    int64_t duration = libvlc_media_player_get_length(mp);
+    if (duration < 0)
+    {
+        return -1;
+    }
+    return (jint) (duration / 1000);
+}
+
+JNIEXPORT jint JNICALL NAME(nativeGetVideoHeight)(JNIEnv *env, jobject thiz)
+{
+    libvlc_media_t *media = (libvlc_media_t *) getIntValue(env, thiz, "mLibVlcMedia");
+    if (!media || !libvlc_media_is_parsed(media))
+        return 0;
+    /* FIXME: it returns the first video's information only */
+    int i, n;
+    int width = 0, height = 0;
+    libvlc_media_track_info_t *track = 0;
+    n = libvlc_media_get_tracks_info(media, &track);
+    if (n <= 0)
+        return 0;
+    for (i = 0; i < n; i++) {
+        libvlc_media_track_info_t t = track[i];
+        if (t.i_type == libvlc_track_video) {
+            width = t.u.video.i_width;
+            height = t.u.video.i_height;
+            break;
+        }
+    }
+    free(track);
+    return height;
+}
+
+JNIEXPORT jint JNICALL NAME(nativeGetVideoWidth)(JNIEnv *env, jobject thiz)
+{
+    libvlc_media_t *media = (libvlc_media_t *) getIntValue(env, thiz, "mLibVlcMedia");
+    if (!media || !libvlc_media_is_parsed(media))
+        return 0;
+    /* FIXME: it returns the first video's information only */
+    int i, n;
+    int width = 0, height = 0;
+    libvlc_media_track_info_t *track = 0;
+    n = libvlc_media_get_tracks_info(media, &track);
+    if (n <= 0)
+        return 0;
+    for (i = 0; i < n; i++) {
+        libvlc_media_track_info_t t = track[i];
+        if (t.i_type == libvlc_track_video) {
+            width = t.u.video.i_width;
+            height = t.u.video.i_height;
+            break;
+        }
+    }
+    free(track);
+    return width;
+}
+
+JNIEXPORT jboolean JNICALL NAME(nativeIsLooping)(JNIEnv *env, jobject thiz)
+{
+    return 0;
+}
+
+JNIEXPORT jboolean JNICALL NAME(nativeIsPlaying)(JNIEnv *env, jobject thiz)
+{
+    libvlc_media_player_t *mp = (libvlc_media_player_t *) getIntValue(env, thiz, "mLibVlcMediaPlayer");
+    return (libvlc_media_player_is_playing(mp) != 0);
+}
+
+JNIEXPORT void JNICALL NAME(nativePause)(JNIEnv *env, jobject thiz)
+{
+    libvlc_media_player_t *mp = (libvlc_media_player_t *) getIntValue(env, thiz, "mLibVlcMediaPlayer");
+    libvlc_media_player_set_pause(mp, 1);
+}
+
+JNIEXPORT void JNICALL NAME(nativePrepare)(JNIEnv *env, jobject thiz)
+{
+    libvlc_media_t *media = (libvlc_media_t *) getIntValue(env, thiz, "mLibVlcMedia");
+    char *mrl = libvlc_media_get_mrl(media);
+    if (strncmp(mrl, "file://", 7) == 0)
+        libvlc_media_parse(media);
+    else {
+        vlc_mutex_t *parse_lock = (vlc_mutex_t *) getIntValue(env, thiz, "mNativeMediaParseLock");
+        vlc_cond_t *parse_cond = (vlc_cond_t *) getIntValue(env, thiz, "mNativeMediaParseCond");
+        libvlc_media_player_t *mp = (libvlc_media_player_t *) getIntValue(env, thiz, "mLibVlcMediaPlayer");
+        libvlc_media_player_play(mp);
+        vlc_mutex_lock(parse_lock);
+        while (!getIntValue(env, thiz, "mNativeMediaParsed"))
+            vlc_cond_wait(parse_cond, parse_lock);
+        vlc_mutex_unlock(parse_lock);
+    }
+    free(mrl);
+}
+
+JNIEXPORT void JNICALL NAME(nativePrepareAsync)(JNIEnv *env, jobject thiz)
+{
+    libvlc_media_t *media = (libvlc_media_t *) getIntValue(env, thiz, "mLibVlcMedia");
+    char *mrl = libvlc_media_get_mrl(media);
+    if (strncmp(mrl, "file://", 7) == 0)
+        libvlc_media_parse_async(media);
+    else
+    {
+        libvlc_media_player_t *mp = (libvlc_media_player_t *) getIntValue(env, thiz, "mLibVlcMediaPlayer");
+        libvlc_media_player_play(mp);
+    }
+    free(mrl);
+}
+
+JNIEXPORT void JNICALL NAME(nativeSeekTo)(JNIEnv *env, jobject thiz, jint msec)
+{
+    libvlc_media_player_t *mp = (libvlc_media_player_t *) getIntValue(env, thiz, "mLibVlcMediaPlayer");
+    libvlc_media_player_set_time(mp, msec);
+}
+
+JNIEXPORT void JNICALL NAME(nativeSetDataSource)(JNIEnv *env, jobject thiz, jstring path)
+{
+    libvlc_instance_t *instance = (libvlc_instance_t *) getIntValue(env, thiz, "mLibVlcInstance");
+    libvlc_media_player_t *mp = (libvlc_media_player_t *) getIntValue(env, thiz, "mLibVlcMediaPlayer");
+    const char *str = (*env)->GetStringUTFChars(env, path, 0);
+    if (!str)
+    {
+        /* throw? */
+        return;
+    }
+    /* XXX: check and free mLibVlcMedia first */
+    libvlc_media_t *media = (*str == '/') ? libvlc_media_new_path(instance, str) : libvlc_media_new_location(instance, str);
+    if (media)
+    {
+        libvlc_event_manager_t *em = libvlc_media_event_manager(media);
+        for (int i = 0; i < sizeof(md_listening) / sizeof(*md_listening); i++)
+        {
+            libvlc_event_attach(em, md_listening[i], vlc_event_callback, thiz);
+        }
+        libvlc_media_player_set_media(mp, media);
+    }
+    (*env)->ReleaseStringUTFChars(env, path, str);
+    setIntValue(env, thiz, "mLibVlcMedia", (jint) media);
+}
+
+JNIEXPORT void JNICALL NAME(nativeSetLooping)(JNIEnv *env, jobject thiz, jboolean looping)
+{
+
+}
+
+JNIEXPORT void JNICALL NAME(nativeStart)(JNIEnv *env, jobject thiz)
+{
+    libvlc_media_player_t *mp = (libvlc_media_player_t *) getIntValue(env, thiz, "mLibVlcMediaPlayer");
+    libvlc_media_player_play(mp);
+}
+
+JNIEXPORT void JNICALL NAME(nativeStop)(JNIEnv *env, jobject thiz) {
+    libvlc_media_player_t *mp = (libvlc_media_player_t *) getIntValue(env, thiz, "mLibVlcMediaPlayer");
+    libvlc_media_player_stop(mp);
+}
+
+#endif
+
diff -Nurp vlc-a/src/libvlcjni.h vlc-b/src/libvlcjni.h
--- vlc-a/src/libvlcjni.h	1970-01-01 08:00:00.000000000 +0800
+++ vlc-b/src/libvlcjni.h	2011-07-18 20:27:21.421386488 +0800
@@ -0,0 +1,93 @@
+/* auto generated */
+vlc_declare_plugin(access_avio);
+vlc_declare_plugin(access_demux_avformat);
+vlc_declare_plugin(access_http);
+vlc_declare_plugin(access_mms);
+vlc_declare_plugin(amem);
+vlc_declare_plugin(android_surface);
+vlc_declare_plugin(audiotrack_android);
+vlc_declare_plugin(avcodec);
+vlc_declare_plugin(avformat);
+vlc_declare_plugin(bandlimited_resampler);
+vlc_declare_plugin(blend);
+vlc_declare_plugin(converter_fixed);
+vlc_declare_plugin(dummy);
+vlc_declare_plugin(filesystem);
+vlc_declare_plugin(fixed32_mixer);
+vlc_declare_plugin(float32_mixer);
+vlc_declare_plugin(freetype);
+vlc_declare_plugin(libasf);
+vlc_declare_plugin(libass);
+vlc_declare_plugin(libavi);
+vlc_declare_plugin(libmp4);
+vlc_declare_plugin(live555);
+vlc_declare_plugin(mkv);
+vlc_declare_plugin(mpeg_audio);
+vlc_declare_plugin(mpgv);
+vlc_declare_plugin(packetizer_copy);
+vlc_declare_plugin(packetizer_dirac);
+vlc_declare_plugin(packetizer_flac);
+vlc_declare_plugin(packetizer_h264);
+vlc_declare_plugin(packetizer_mlp);
+vlc_declare_plugin(packetizer_mpeg4audio);
+vlc_declare_plugin(packetizer_mpeg4video);
+vlc_declare_plugin(packetizer_mpegvideo);
+vlc_declare_plugin(packetizer_vc1);
+vlc_declare_plugin(realrtsp);
+vlc_declare_plugin(simple_channel_mixer);
+vlc_declare_plugin(subsdec);
+vlc_declare_plugin(subsusf);
+vlc_declare_plugin(subtitle);
+vlc_declare_plugin(swscale);
+vlc_declare_plugin(trivial_mixer);
+vlc_declare_plugin(ugly_resampler);
+vlc_declare_plugin(vmem);
+vlc_declare_plugin(yuv2rgb);
+const void *vlc_builtins_modules[] = {
+	vlc_plugin(access_avio),
+	vlc_plugin(access_demux_avformat),
+	vlc_plugin(access_http),
+	vlc_plugin(access_mms),
+	vlc_plugin(amem),
+	vlc_plugin(android_surface),
+	vlc_plugin(audiotrack_android),
+	vlc_plugin(avcodec),
+	vlc_plugin(avformat),
+	vlc_plugin(bandlimited_resampler),
+	vlc_plugin(blend),
+	vlc_plugin(converter_fixed),
+	vlc_plugin(dummy),
+	vlc_plugin(filesystem),
+	vlc_plugin(fixed32_mixer),
+	vlc_plugin(float32_mixer),
+	vlc_plugin(freetype),
+	vlc_plugin(libasf),
+	vlc_plugin(libass),
+	vlc_plugin(libavi),
+	vlc_plugin(libmp4),
+	vlc_plugin(live555),
+	vlc_plugin(mkv),
+	vlc_plugin(mpeg_audio),
+	vlc_plugin(mpgv),
+	vlc_plugin(packetizer_copy),
+	vlc_plugin(packetizer_dirac),
+	vlc_plugin(packetizer_flac),
+	vlc_plugin(packetizer_h264),
+	vlc_plugin(packetizer_mlp),
+	vlc_plugin(packetizer_mpeg4audio),
+	vlc_plugin(packetizer_mpeg4video),
+	vlc_plugin(packetizer_mpegvideo),
+	vlc_plugin(packetizer_vc1),
+	vlc_plugin(realrtsp),
+	vlc_plugin(simple_channel_mixer),
+	vlc_plugin(subsdec),
+	vlc_plugin(subsusf),
+	vlc_plugin(subtitle),
+	vlc_plugin(swscale),
+	vlc_plugin(trivial_mixer),
+	vlc_plugin(ugly_resampler),
+	vlc_plugin(vmem),
+	vlc_plugin(yuv2rgb),
+	NULL
+};
+/* auto generated */
diff -Nurp vlc-a/src/libvlc-module.c vlc-b/src/libvlc-module.c
--- vlc-a/src/libvlc-module.c	2011-07-18 20:34:12.565217890 +0800
+++ vlc-b/src/libvlc-module.c	2011-07-10 01:53:51.256274759 +0800
@@ -27,6 +27,7 @@
 // Pretend we are a builtin module
 #define MODULE_NAME main
 #define MODULE_PATH main
+#define __BUILTIN__
 
 
 #ifdef HAVE_CONFIG_H
diff -Nurp vlc-a/src/misc/messages.c vlc-b/src/misc/messages.c
--- vlc-a/src/misc/messages.c	2011-07-18 20:34:12.571217917 +0800
+++ vlc-b/src/misc/messages.c	2011-07-10 01:53:51.262274794 +0800
@@ -55,6 +55,10 @@
 #include <vlc_charset.h>
 #include "../libvlc.h"
 
+#ifdef ANDROID
+#include <android/log.h>
+#endif
+
 /*****************************************************************************
  * Local macros
  *****************************************************************************/
@@ -482,5 +486,18 @@ static void PrintMsg ( vlc_object_t *p_t
     fflush (stream);
 #endif
     funlockfile (stream);
+#ifdef ANDROID
+    int level[] = {ANDROID_LOG_INFO, ANDROID_LOG_ERROR, ANDROID_LOG_WARN, ANDROID_LOG_DEBUG};
+    __android_log_print(
+        level[p_item->i_type],
+        "faplayer",
+        p_item->psz_header ? "[%p][%s] %s %s: %s" : "[%p]%s%s %s: %s",
+        (void *) p_item->i_object_id,
+        p_item->psz_header ? p_item->psz_header : "",
+        p_item->psz_module,
+        p_item->psz_object_type,
+        p_item->psz_msg
+    );
+#endif
     vlc_restorecancel (canc);
 }
diff -Nurp vlc-a/src/modules/modules.c vlc-b/src/modules/modules.c
--- vlc-a/src/modules/modules.c	2011-07-18 20:34:12.578217948 +0800
+++ vlc-b/src/modules/modules.c	2011-07-10 01:53:51.342275240 +0800
@@ -186,13 +186,19 @@ void module_EndBank( vlc_object_t *p_thi
  * \param p_this vlc object structure
  * \return nothing
  */
-void module_LoadPlugins( vlc_object_t * p_this )
+void module_LoadPlugins( vlc_object_t * p_this, const void **builtins )
 {
     module_bank_t *p_bank = p_module_bank;
 
     assert( p_bank );
     /*vlc_assert_locked( &module_lock ); not for static mutexes :( */
 
+    if (builtins)
+    {
+        for (int i = 0; builtins[i]; i++)
+            AllocateBuiltinModule( p_this, builtins[i] );
+    }
+
 #ifdef HAVE_DYNAMIC_PLUGINS
     if( p_bank->i_usage == 1 )
     {
diff -Nurp vlc-a/src/modules/modules.h vlc-b/src/modules/modules.h
--- vlc-a/src/modules/modules.h	2011-07-18 20:34:12.578217948 +0800
+++ vlc-b/src/modules/modules.h	2011-07-10 01:53:51.342275240 +0800
@@ -133,8 +133,8 @@ module_t *vlc_submodule_create (module_t
 
 void  module_InitBank( vlc_object_t * );
 #define module_InitBank(a) module_InitBank(VLC_OBJECT(a))
-void module_LoadPlugins( vlc_object_t * );
-#define module_LoadPlugins(a) module_LoadPlugins(VLC_OBJECT(a))
+void module_LoadPlugins( vlc_object_t *, const void ** );
+#define module_LoadPlugins(a,b) module_LoadPlugins(VLC_OBJECT(a),b)
 void module_EndBank( vlc_object_t *, bool );
 #define module_EndBank(a,b) module_EndBank(VLC_OBJECT(a), b)
 
diff -Nurp vlc-a/src/network/udp.c vlc-b/src/network/udp.c
--- vlc-a/src/network/udp.c	2011-07-18 20:34:12.582217965 +0800
+++ vlc-b/src/network/udp.c	2011-07-10 01:53:52.572282095 +0800
@@ -370,9 +370,15 @@ net_IPv4Join (vlc_object_t *obj, int fd,
     {
 # if defined( IP_ADD_SOURCE_MEMBERSHIP ) && !defined( __ANDROID__ )
         cmd = IP_ADD_SOURCE_MEMBERSHIP;
+#ifdef ANDROID
+        opt.gsr4.imr_multiaddr = grp->sin_addr.s_addr;
+        opt.gsr4.imr_sourceaddr = src->sin_addr.s_addr;
+        opt.gsr4.imr_interface = id.s_addr;
+#else
         opt.gsr4.imr_multiaddr = grp->sin_addr;
         opt.gsr4.imr_sourceaddr = src->sin_addr;
         opt.gsr4.imr_interface = id;
+#endif
         optlen = sizeof (opt.gsr4);
 # else
         errno = ENOSYS;
diff -Nurp vlc-a/src/posix/thread.c vlc-b/src/posix/thread.c
--- vlc-a/src/posix/thread.c	2011-07-18 20:34:12.588217991 +0800
+++ vlc-b/src/posix/thread.c	2011-07-10 01:53:52.650282530 +0800
@@ -52,6 +52,23 @@
 # include <mach/mach_init.h> /* mach_task_self in semaphores */
 #endif
 
+#ifdef ANDROID
+#include <android/api-level.h>
+#if __ANDROID_API__ < 8
+#define pthread_condattr_init(a) 0
+#define pthread_condattr_destroy(a)
+#endif
+#define PTHREAD_CANCEL_DISABLE 1
+int pthread_create_cancel(pthread_t *thread, pthread_attr_t const * attr,
+                   void *(*start_routine)(void *), void * arg);
+int pthread_cond_timedwait_cancel(pthread_cond_t *cond,
+                           pthread_mutex_t * mutex,
+                           const struct timespec *abstime);
+int pthread_cancel(pthread_t thread);
+void pthread_testcancel();
+int pthread_setcancelstate(int state, int *old);
+#endif
+
 /**
  * Print a backtrace to the standard error for debugging purpose.
  */
@@ -396,7 +413,11 @@ int vlc_cond_timedwait (vlc_cond_t *p_co
 #else
     lldiv_t d = lldiv( deadline, CLOCK_FREQ );
     struct timespec ts = { d.quot, d.rem * (1000000000 / CLOCK_FREQ) };
+#ifdef ANDROID
+    int val = pthread_cond_timedwait_cancel (p_condvar, p_mutex, &ts);
+#else
     int val = pthread_cond_timedwait (p_condvar, p_mutex, &ts);
+#endif
     if (val != ETIMEDOUT)
         VLC_THREAD_ASSERT ("timed-waiting on condition");
     return val;
@@ -459,6 +480,14 @@ int vlc_sem_post (vlc_sem_t *sem)
     val = errno;
 #endif
 
+#ifdef ANDROID
+    /* Bionic is so broken that it will return EBUSY on sem_destroy
+     * if the semaphore has never been used...
+     */
+    if (likely(val == EBUSY))
+        return; // It may be a real error, but there's no way to know
+#endif
+
     if (unlikely(val != EOVERFLOW))
         VLC_THREAD_ASSERT ("unlocking semaphore");
     return val;
@@ -487,6 +516,82 @@ void vlc_sem_wait (vlc_sem_t *sem)
     VLC_THREAD_ASSERT ("locking semaphore");
 }
 
+#ifdef ANDROID
+/* SRW (Slim Read Write) locks are available in Vista+ only */
+/**
+ * Initializes a read/write lock.
+ */
+void vlc_rwlock_init (vlc_rwlock_t *lock)
+{
+    vlc_mutex_init (&lock->mutex);
+    vlc_cond_init (&lock->read_wait);
+    vlc_cond_init (&lock->write_wait);
+    lock->readers = 0; /* active readers */
+    lock->writers = 0; /* waiting or active writers */
+    lock->writer = 0; /* ID of active writer */
+}
+
+/**
+ * Destroys an initialized unused read/write lock.
+ */
+void vlc_rwlock_destroy (vlc_rwlock_t *lock)
+{
+    vlc_cond_destroy (&lock->read_wait);
+    vlc_cond_destroy (&lock->write_wait);
+    vlc_mutex_destroy (&lock->mutex);
+}
+
+/**
+ * Acquires a read/write lock for reading. Recursion is allowed.
+ */
+void vlc_rwlock_rdlock (vlc_rwlock_t *lock)
+{
+    vlc_mutex_lock (&lock->mutex);
+    while (lock->writer != 0)
+        vlc_cond_wait (&lock->read_wait, &lock->mutex);
+    if (lock->readers == ULONG_MAX)
+        abort ();
+    lock->readers++;
+    vlc_mutex_unlock (&lock->mutex);
+}
+
+/**
+ * Acquires a read/write lock for writing. Recursion is not allowed.
+ */
+void vlc_rwlock_wrlock (vlc_rwlock_t *lock)
+{
+    vlc_mutex_lock (&lock->mutex);
+    if (lock->writers == ULONG_MAX)
+        abort ();
+    lock->writers++;
+    while ((lock->readers > 0) || (lock->writer != 0))
+        vlc_cond_wait (&lock->write_wait, &lock->mutex);
+    lock->writers--;
+    lock->writer = 1;//GetCurrentThreadId ();
+    vlc_mutex_unlock (&lock->mutex);
+}
+
+/**
+ * Releases a read/write lock.
+ */
+void vlc_rwlock_unlock (vlc_rwlock_t *lock)
+{
+    vlc_mutex_lock (&lock->mutex);
+    if (lock->readers > 0)
+        lock->readers--; /* Read unlock */
+    else
+        lock->writer = 0; /* Write unlock */
+
+    if (lock->writers > 0)
+    {
+        if (lock->readers == 0)
+            vlc_cond_signal (&lock->write_wait);
+    }
+    else
+        vlc_cond_broadcast (&lock->read_wait);
+    vlc_mutex_unlock (&lock->mutex);
+}
+#else
 /**
  * Initializes a read/write lock.
  */
@@ -531,6 +636,7 @@ void vlc_rwlock_unlock (vlc_rwlock_t *lo
     int val = pthread_rwlock_unlock (lock);
     VLC_THREAD_ASSERT ("releasing R/W lock");
 }
+#endif
 
 /**
  * Allocates a thread-specific variable.
@@ -666,7 +772,11 @@ static int vlc_clone_attr (vlc_thread_t 
     assert (ret == 0); /* fails iif VLC_STACKSIZE is invalid */
 #endif
 
+#ifdef ANDROID
+    ret = pthread_create_cancel (th, attr, entry, data);
+#else
     ret = pthread_create (th, attr, entry, data);
+#endif
     pthread_sigmask (SIG_SETMASK, &oldset, NULL);
     pthread_attr_destroy (attr);
     return ret;
diff -Nurp vlc-a/src/revision.c vlc-b/src/revision.c
--- vlc-a/src/revision.c	1970-01-01 08:00:00.000000000 +0800
+++ vlc-b/src/revision.c	2011-07-10 01:53:52.650282530 +0800
@@ -0,0 +1 @@
+const char psz_vlc_changeset[] = "\\^_^/ - 32e84aaf456f758bd536fe08083ad2f2e7b4e7d3";
